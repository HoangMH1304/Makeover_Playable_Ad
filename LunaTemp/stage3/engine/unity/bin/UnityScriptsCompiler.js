if ( TRACE ) { TRACE( JSON.parse( '["BreathButton#init","BreathButton#Awake","BreathButton#OnEnable","BreathButton#DoScale","BreathButton#OnDisable","CameraHandler#Clickable#get","CameraHandler#Clickable#set","CameraHandler#FurnitureSelectable#get","CameraHandler#FurnitureSelectable#set","CameraHandler#CameraMain#get","CameraHandler#CameraMain#set","CameraHandler#init","CameraHandler#Awake","CameraHandler#SetSize","CameraHandler#RegisterListener","CameraHandler#DisplayCharacterInChallenge","CameraHandler#SetCamForPk","CameraHandler#ResetCameraHome","CameraHandler#CheckConditionOrthoCameraConfig","CameraHandler#SetPosOfCamera","CameraHandler#CameraInGameplay","CameraHandler#CameraForConfetti","CameraHandler#FocusItem","CameraHandler#ZoomIn","CameraHandler#ZoomOut","CameraHandler#DoZoom","CanvasHandler#Awake","CharacterManager#init","CharacterManager#SetScale","CharacterManager#SetPos","CharacterManager#SetTypeOfAnim","CharacterManager#ChangeToDanceAnim","CurrencyConvert#RoundConvert","CurrencyConvert#DecimalConvert","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI#DOShapeCircle","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","DragDropTut#OnEnable","EventDispatcher#Instance#get","EventDispatcher#Instance#set","EventDispatcher#HasInstance","EventDispatcher#init","EventDispatcher#Awake","EventDispatcher#OnDestroy","EventDispatcher#RegisterListener","EventDispatcher#PostEvent","EventDispatcher#RemoveListener","EventDispatcher#ClearAllListener","EventDispatcherExtension#RegisterListener","EventDispatcherExtension#PostEvent$1","EventDispatcherExtension#PostEvent","GridHandler#Start","GridHandler#RestoreInitialPos","GridHandler#SetStateContent","Item#init","ItemDisplay#OnDisable","ItemDisplay#Show","ItemDisplay#OnClick","ItemDisplay#Deselect","ItemDisplay#SetSib","MoneyFly#init","MoneyFly#Start","MoneyFly#InitSequence","MoneyFly#Update","MonsterCreator#CreateMonster","MonsterCreator#HandleBodyType","MonsterCreator#SetTypeOfAnim","MyDebug#init","MyDebug#Log$1","MyDebug#Log","MyDebug#LogError","MyDebug#LogError$1","MyDebug#LogWarning$1","MyDebug#LogWarning","PopupPanel#init","PopupPanel#OnEnable","PopupPanel#OnDisable","PopupPanel#CanTurnOff","PopupPanel#SetText","PopupPanel#InitEffect","PopupPanel#EntranceAnim","PopupPanel#OnExit","PrefInfo#GetProgress#get","PrefInfo#GetTier#get","PrefInfo#GetKeyOwned#get","PrefInfo#init","PrefInfo#SetSubState","PrefInfo#IsSub","PrefInfo#GetLastSpinTime","PrefInfo#SetLastSpinTime","PrefInfo#GetLastAdInChallenge","PrefInfo#SetLastAdInChallenge","PrefInfo#SetTotalExtraLife","PrefInfo#TotalExtraLife","PrefInfo#Distance","PrefInfo#GetLastDieTime","PrefInfo#SetLastDieTime","PrefInfo#GetPlayTime","PrefInfo#SetPlayTime","PrefInfo#IncreasePlayTime","PrefInfo#GetIQ","PrefInfo#SetIQ","PrefInfo#GetHeart","PrefInfo#SetHeart","PrefInfo#GetSpin","PrefInfo#SetSpin","PrefInfo#GetGem","PrefInfo#SetGem","PrefInfo#AddGem","PrefInfo#GetItemStatus","PrefInfo#SetItemStatus","PrefInfo#GetName","PrefInfo#SetName","PrefInfo#IsUnlimited","PrefInfo#SetUnlimited","PrefInfo#IsUsingAd","PrefInfo#SetAd","PrefInfo#GetSensitivity","PrefInfo#SetSensitivity","PrefInfo#GetCurrentSkin","PrefInfo#SetCurrentSkin","PrefInfo#GetCoin","PrefInfo#SetCoin","PrefInfo#AddCoin","PrefInfo#IsUnlocked","PrefInfo#SetUnlocked","PrefInfo#SetHint","PrefInfo#TotalHint","PrefInfo#SetCurrentDailyGiftIndex","PrefInfo#SetCurrentDailyGiftIndexAd","PrefInfo#GetDayClaim","PrefInfo#SetDayClaimed","PrefInfo#CurrentDailyIndex","PrefInfo#CurrentDailyIndexAd","PrefInfo#Complete7Day","PrefInfo#SetComplete7Day","PrefInfo#SaveTimeLastLogin","PrefInfo#SaveTimeLastLoginAd","PrefInfo#TimeLastDayLogin","PrefInfo#TimeLastDayLoginAd","PrefInfo#SetProgress","PrefInfo#SetTier","PrefInfo#SetKeyOwned","PrefInfo#AddKey","Scale#OnEnable","Scale#OnEnter","Scale#OnExit","SfxController#init","SfxController#Awake","SfxController#OnEnable","SfxController#UpdateSFXUI","SfxController#SwitchSoundState","SfxController#SwitchVibrationState","SfxController#ChangeIcon","SfxController#PlayTapSound","SfxController#PlayPopupSound","SfxController#PlayBoosterSound2","SfxController#PauseBoosterSound","SfxController#PlayCashSound","SfxController#Vibrate","ShopController#IsPickBody#get","ShopController#IsPickBody#set","ShopController#Bodies#get","ShopController#Bodies#set","ShopController#CurrentHead#get","ShopController#CurrentHead#set","ShopController#CurrentEye#get","ShopController#CurrentEye#set","ShopController#CurrentMouth#get","ShopController#CurrentMouth#set","ShopController#CurrentAcc#get","ShopController#CurrentAcc#set","ShopController#CurrentBody#get","ShopController#CurrentBody#set","ShopController#init","ShopController#Awake","ShopController#GetReference","ShopController#Start","ShopController#CheckNextStep","ShopController#OnClickItem","ShopController#SetCurrenBodyPartController","ShopController#ForcusEntireCharacter","ShopController#FocusHeadCharacter","ShopController#InitItems","ShopController#HandleSortItemIngame","ShopController#SortArr","SortingLayerCharacter#init","SortingLayerCharacter#Awake","SortingLayerCharacter#SetDragState","SortingLayerCharacter#LateUpdate","SoundAudioClip#init","SoundManager#init","SoundManager#init","SoundManager#Awake","SoundManager#Start","SoundManager#PlaySound","SoundManager#PlaySFX","SoundManager#PauseSound","SoundManager#PlayItemClickedSound","SoundManager#GetAudioClip","SoundManager#ChangePitch","Spine.BoneMatrix#CalculateSetupWorld","Spine.BoneMatrix#GetInheritedInternal","Spine.BoneMatrix#getDefaultValue","Spine.BoneMatrix#$ctor2","Spine.BoneMatrix#$ctor1","Spine.BoneMatrix#ctor","Spine.BoneMatrix#TransformMatrix","Spine.BoneMatrix#getHashCode","Spine.BoneMatrix#equals","Spine.BoneMatrix#$clone","Spine.SpineSkeletonExtensions#IsWeighted","Spine.SpineSkeletonExtensions#InheritsRotation","Spine.SpineSkeletonExtensions#InheritsScale","Spine.Unity.ActivateBasedOnFlipDirection#init","Spine.Unity.ActivateBasedOnFlipDirection#Start","Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate","Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip","Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions","Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix","Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set","Spine.Unity.BlendModeMaterials#init","Spine.Unity.BlendModeMaterials#BlendModeForMaterial","Spine.Unity.BlendModeMaterials#ApplyMaterials","Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose","Spine.Unity.BoneFollower#SkeletonRenderer#get","Spine.Unity.BoneFollower#SkeletonRenderer#set","Spine.Unity.BoneFollower#init","Spine.Unity.BoneFollower#SetBone","Spine.Unity.BoneFollower#Awake","Spine.Unity.BoneFollower#HandleRebuildRenderer","Spine.Unity.BoneFollower#Initialize","Spine.Unity.BoneFollower#OnDestroy","Spine.Unity.BoneFollower#LateUpdate","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set","Spine.Unity.BoneFollowerGraphic#init","Spine.Unity.BoneFollowerGraphic#SetBone","Spine.Unity.BoneFollowerGraphic#Awake","Spine.Unity.BoneFollowerGraphic#Initialize","Spine.Unity.BoneFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Slot#get","Spine.Unity.BoundingBoxFollower#CurrentAttachment#get","Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollower#CurrentCollider#get","Spine.Unity.BoundingBoxFollower#IsTrigger#get","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Start","Spine.Unity.BoundingBoxFollower#OnEnable","Spine.Unity.BoundingBoxFollower#HandleRebuild","Spine.Unity.BoundingBoxFollower#Initialize","Spine.Unity.BoundingBoxFollower#AddCollidersForSkin","Spine.Unity.BoundingBoxFollower#OnDisable","Spine.Unity.BoundingBoxFollower#ClearState","Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollower#LateUpdate","Spine.Unity.BoundingBoxFollower#MatchAttachment","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Slot#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get","Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Start","Spine.Unity.BoundingBoxFollowerGraphic#OnEnable","Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild","Spine.Unity.BoundingBoxFollowerGraphic#Initialize","Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin","Spine.Unity.BoundingBoxFollowerGraphic#OnDisable","Spine.Unity.BoundingBoxFollowerGraphic#ClearState","Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment","Spine.Unity.DoubleBuffered$1#init","Spine.Unity.DoubleBuffered$1#GetCurrent","Spine.Unity.DoubleBuffered$1#GetNext","Spine.Unity.EventDataReferenceAsset#init","Spine.Unity.EventDataReferenceAsset#op_Implicit","Spine.Unity.EventDataReferenceAsset#EventData#get","Spine.Unity.EventDataReferenceAsset#Initialize","Spine.Unity.FollowLocationRigidbody#Awake","Spine.Unity.FollowLocationRigidbody#FixedUpdate","Spine.Unity.FollowLocationRigidbody2D#Awake","Spine.Unity.FollowLocationRigidbody2D#FixedUpdate","Spine.Unity.FollowSkeletonUtilityRootRotation#init","Spine.Unity.FollowSkeletonUtilityRootRotation#init","Spine.Unity.FollowSkeletonUtilityRootRotation#Start","Spine.Unity.FollowSkeletonUtilityRootRotation#FixedUpdate","Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToYRotation","Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToXRotation","Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed","Spine.Unity.MaterialsTextureLoader#ctor","Spine.Unity.MaterialsTextureLoader#Load","Spine.Unity.MaterialsTextureLoader#Unload","Spine.Unity.MathUtilities#InverseLerp","Spine.Unity.MathUtilities#InverseLerp$1","Spine.Unity.MathUtilities#InverseLerp$2","Spine.Unity.MathUtilities#InverseLerp$3","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction","Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder","Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction","Spine.Unity.MeshGenerator#TryReplaceMaterials","Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize","Spine.Unity.MeshGenerator#SolveTangents2DTriangles","Spine.Unity.MeshGenerator#SolveTangents2DBuffer","Spine.Unity.MeshGenerator#FillMeshLocal$1","Spine.Unity.MeshGenerator#FillMeshLocal","Spine.Unity.MeshGenerator#VertexCount#get","Spine.Unity.MeshGenerator#Buffers#get","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#ctor","Spine.Unity.MeshGenerator#SubmeshIndexCount","Spine.Unity.MeshGenerator#Begin","Spine.Unity.MeshGenerator#AddSubmesh","Spine.Unity.MeshGenerator#BuildMesh","Spine.Unity.MeshGenerator#BuildMeshWithArrays","Spine.Unity.MeshGenerator#ScaleVertexData","Spine.Unity.MeshGenerator#GetMeshBounds","Spine.Unity.MeshGenerator#AddAttachmentTintBlack","Spine.Unity.MeshGenerator#FillVertexData","Spine.Unity.MeshGenerator#FillLateVertexData","Spine.Unity.MeshGenerator#FillTriangles","Spine.Unity.MeshGenerator#EnsureVertexCapacity","Spine.Unity.MeshGenerator#TrimExcess","Spine.Unity.MeshGenerator.Settings#Default#get","Spine.Unity.MeshGenerator.Settings#getDefaultValue","Spine.Unity.MeshGenerator.Settings#ctor","Spine.Unity.MeshGenerator.Settings#getHashCode","Spine.Unity.MeshGenerator.Settings#equals","Spine.Unity.MeshGenerator.Settings#$clone","Spine.Unity.MeshGeneratorBuffers#getDefaultValue","Spine.Unity.MeshGeneratorBuffers#ctor","Spine.Unity.MeshGeneratorBuffers#getHashCode","Spine.Unity.MeshGeneratorBuffers#equals","Spine.Unity.MeshGeneratorBuffers#$clone","Spine.Unity.MeshRendererBuffers#init","Spine.Unity.MeshRendererBuffers#Initialize","Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray","Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate","Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials","Spine.Unity.MeshRendererBuffers#GetNextMesh","Spine.Unity.MeshRendererBuffers#Clear","Spine.Unity.MeshRendererBuffers#Dispose","Spine.Unity.MeshRendererBuffers.SmartMesh#init","Spine.Unity.MeshRendererBuffers.SmartMesh#Clear","Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose","Spine.Unity.NoOpTextureLoader#Load","Spine.Unity.NoOpTextureLoader#Unload","Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get","Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment","Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment","Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment","Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1","Spine.Unity.SkeletonDataAsset#ReadSkeletonData","Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1","Spine.Unity.SkeletonDataAsset#IsLoaded#get","Spine.Unity.SkeletonDataAsset#init","Spine.Unity.SkeletonDataAsset#Reset","Spine.Unity.SkeletonDataAsset#Clear","Spine.Unity.SkeletonDataAsset#GetAnimationStateData","Spine.Unity.SkeletonDataAsset#GetSkeletonData","Spine.Unity.SkeletonDataAsset#InitializeWithData","Spine.Unity.SkeletonDataAsset#FillStateData","Spine.Unity.SkeletonDataAsset#GetAtlasArray","Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString","Spine.Unity.SkeletonExtensions#init","Spine.Unity.SkeletonExtensions#GetColor$2","Spine.Unity.SkeletonExtensions#GetColor$1","Spine.Unity.SkeletonExtensions#GetColor","Spine.Unity.SkeletonExtensions#GetColor$3","Spine.Unity.SkeletonExtensions#GetColorTintBlack","Spine.Unity.SkeletonExtensions#SetColor$4","Spine.Unity.SkeletonExtensions#SetColor$5","Spine.Unity.SkeletonExtensions#SetColor$6","Spine.Unity.SkeletonExtensions#SetColor$7","Spine.Unity.SkeletonExtensions#SetColor$2","Spine.Unity.SkeletonExtensions#SetColor$3","Spine.Unity.SkeletonExtensions#SetColor","Spine.Unity.SkeletonExtensions#SetColor$1","Spine.Unity.SkeletonExtensions#SetLocalScale","Spine.Unity.SkeletonExtensions#GetMatrix4x4","Spine.Unity.SkeletonExtensions#SetLocalPosition","Spine.Unity.SkeletonExtensions#SetLocalPosition$1","Spine.Unity.SkeletonExtensions#GetLocalPosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition","Spine.Unity.SkeletonExtensions#GetWorldPosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition$3","Spine.Unity.SkeletonExtensions#GetWorldPosition$2","Spine.Unity.SkeletonExtensions#GetQuaternion","Spine.Unity.SkeletonExtensions#GetLocalQuaternion","Spine.Unity.SkeletonExtensions#GetLocalScale","Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix","Spine.Unity.SkeletonExtensions#WorldToLocal","Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace","Spine.Unity.SkeletonExtensions#GetMaterial","Spine.Unity.SkeletonExtensions#GetLocalVertices","Spine.Unity.SkeletonExtensions#GetWorldVertices","Spine.Unity.SkeletonGraphicCustomMaterials#init","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable","Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback","Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2","Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2","Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get","Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set","Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get","Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get","Spine.Unity.SkeletonRootMotionBase#init","Spine.Unity.SkeletonRootMotionBase#Reset","Spine.Unity.SkeletonRootMotionBase#Start","Spine.Unity.SkeletonRootMotionBase#FixedUpdate","Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate","Spine.Unity.SkeletonRootMotionBase#OnDisable","Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent","Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone","Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo","Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex","Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone","Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta","Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones","Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal","Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion","Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo","Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets","Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement","Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject","Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get","Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get","Spine.Unity.SkeletonPartsRenderer#MeshFilter#get","Spine.Unity.SkeletonPartsRenderer#init","Spine.Unity.SkeletonPartsRenderer#LazyIntialize","Spine.Unity.SkeletonPartsRenderer#ClearMesh","Spine.Unity.SkeletonPartsRenderer#RenderParts","Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#OnEnable","Spine.Unity.SkeletonRendererCustomMaterials#OnDisable","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone","Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual","Spine.Unity.SkeletonRendererInstruction#init","Spine.Unity.SkeletonRendererInstruction#Clear","Spine.Unity.SkeletonRendererInstruction#Dispose","Spine.Unity.SkeletonRendererInstruction#SetWithSubset","Spine.Unity.SkeletonRendererInstruction#Set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer","Spine.Unity.SkeletonRenderSeparator#OnEnable","Spine.Unity.SkeletonRenderSeparator#OnDisable","Spine.Unity.SkeletonRenderSeparator#HandleRender","Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone","Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty","Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty","Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1","Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent","Spine.Unity.SkeletonUtility#SetColliderPointsLocal","Spine.Unity.SkeletonUtility#GetBoundingBoxBounds","Spine.Unity.SkeletonUtility#AddBoneRigidbody2D","Spine.Unity.SkeletonUtility#SkeletonComponent#get","Spine.Unity.SkeletonUtility#Skeleton#get","Spine.Unity.SkeletonUtility#IsValid#get","Spine.Unity.SkeletonUtility#PositionScale#get","Spine.Unity.SkeletonUtility#init","Spine.Unity.SkeletonUtility#Update","Spine.Unity.SkeletonUtility#ResubscribeEvents","Spine.Unity.SkeletonUtility#OnEnable","Spine.Unity.SkeletonUtility#Start","Spine.Unity.SkeletonUtility#OnDisable","Spine.Unity.SkeletonUtility#HandleRendererReset$1","Spine.Unity.SkeletonUtility#HandleRendererReset","Spine.Unity.SkeletonUtility#RegisterBone","Spine.Unity.SkeletonUtility#UnregisterBone","Spine.Unity.SkeletonUtility#RegisterConstraint","Spine.Unity.SkeletonUtility#UnregisterConstraint","Spine.Unity.SkeletonUtility#CollectBones","Spine.Unity.SkeletonUtility#UpdateLocal","Spine.Unity.SkeletonUtility#UpdateWorld","Spine.Unity.SkeletonUtility#UpdateComplete","Spine.Unity.SkeletonUtility#UpdateAllBones","Spine.Unity.SkeletonUtility#GetBoneRoot","Spine.Unity.SkeletonUtility#SpawnRoot","Spine.Unity.SkeletonUtility#SpawnHierarchy","Spine.Unity.SkeletonUtility#SpawnBoneRecursively","Spine.Unity.SkeletonUtility#SpawnBone","Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible","Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get","Spine.Unity.SkeletonUtilityBone#init","Spine.Unity.SkeletonUtilityBone#Reset","Spine.Unity.SkeletonUtilityBone#OnEnable","Spine.Unity.SkeletonUtilityBone#HandleOnReset","Spine.Unity.SkeletonUtilityBone#OnDisable","Spine.Unity.SkeletonUtilityBone#DoUpdate","Spine.Unity.SkeletonUtilityBone#AddBoundingBox","Spine.Unity.SkeletonUtilityConstraint#OnEnable","Spine.Unity.SkeletonUtilityConstraint#OnDisable","Spine.Unity.SpineAttributeBase#init","Spine.Unity.SpineAtlasRegion#ctor","Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue","Spine.Unity.SpineAttachment.Hierarchy#$ctor1","Spine.Unity.SpineAttachment.Hierarchy#ctor","Spine.Unity.SpineAttachment.Hierarchy#getHashCode","Spine.Unity.SpineAttachment.Hierarchy#equals","Spine.Unity.SpineAttachment.Hierarchy#$clone","Spine.Unity.SpineMesh#init","Spine.Unity.SpineMesh#NewSkeletonMesh","Spine.Unity.SubmeshInstruction#getDefaultValue","Spine.Unity.SubmeshInstruction#SlotCount#get","Spine.Unity.SubmeshInstruction#ctor","Spine.Unity.SubmeshInstruction#toString","Spine.Unity.SubmeshInstruction#getHashCode","Spine.Unity.SubmeshInstruction#equals","Spine.Unity.SubmeshInstruction#$clone","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineAnimation#init","Spine.Unity.WaitForSpineAnimation#ctor","Spine.Unity.WaitForSpineAnimation#NowWaitFor","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineAnimation#SafeSubscribe","Spine.Unity.WaitForSpineAnimation#HandleComplete","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineEvent#init","Spine.Unity.WaitForSpineEvent#ctor","Spine.Unity.WaitForSpineEvent#$ctor2","Spine.Unity.WaitForSpineEvent#$ctor1","Spine.Unity.WaitForSpineEvent#$ctor3","Spine.Unity.WaitForSpineEvent#Subscribe","Spine.Unity.WaitForSpineEvent#SubscribeByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent","Spine.Unity.WaitForSpineEvent#NowWaitFor","Spine.Unity.WaitForSpineEvent#NowWaitFor$1","Spine.Unity.WaitForSpineEvent#Clear","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineTrackEntryEnd#init","Spine.Unity.WaitForSpineTrackEntryEnd#ctor","Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd","Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe","Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset","Tab#init","Tab#OnValidate","Tab#OnDisplay","Tab#OnExit","Tab#Reset","TabMenuHandler#init","TabMenuHandler#Awake","TabMenuHandler#Start","TabMenuHandler#OnEnable","TabMenuHandler#InitState","TabMenuHandler#ResetTabs","TabMenuHandler#TurnOnNextBtn","TabMenuHandler#SetStateNextBtn","TabMenuHandler#NextTab","TouchController#init","TouchController#Start","TouchController#OnValidate","TouchController#Update","TouchController#LimitPosition","TouchController#Drawing","TouchController#BeginDraw","TouchController#InDraw","TouchController#EndDraw","TutHand#OnEnable","TutHand#OnDisable","UI_Endgame#OnEntrance","UI_Endgame#OnClickDownload","UI_Ingame#OnEnable","UI_Ingame#Start","UI_Ingame#DeactiveDoneBtn","UI_Ingame#ChangeIconToDone","UI_Result#init","UI_Result#OnEnable","UI_Result#Update","UI_Result#HandleExtraMonster1","UI_Result#HandleExtraMonster2","UI_Transition#Start","UI_Transition#OnExit","UIHandler#UI_Ingame#get","UIHandler#UI_Ingame#set","UIHandler#PauseGameplay","UIHandler#ResumeGameplay","UIHandler#Awake","UIHandler#Start","UIHandler#HandleDoneBtn","UIHandler#Done","UIHandler#PlayEffect","UIHandler#PlayDanceAnimForMonster","Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials","Spine.Unity.BlendModeMaterialsAsset#init","Spine.Unity.BlendModeMaterialsAsset#Apply","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonMecanimRootMotion#Reset","Spine.Unity.SkeletonMecanimRootMotion#Start","Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#AdditionalScale#get","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonRootMotion#Reset","Spine.Unity.SkeletonRootMotion#Start","Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta","Spine.Unity.SkeletonRootMotion#GetMixAlpha","Spine.Unity.SpineAnimation#ctor","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2","Spine.Unity.SpineAtlasAsset#IsLoaded#get","Spine.Unity.SpineAtlasAsset#Materials#get","Spine.Unity.SpineAtlasAsset#MaterialCount#get","Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineAtlasAsset#Reset","Spine.Unity.SpineAtlasAsset#Clear","Spine.Unity.SpineAtlasAsset#GetAtlas","Spine.Unity.SpineAtlasAsset#GenerateMesh","Spine.Unity.SpineAttachment#getHierarchy","Spine.Unity.SpineAttachment#getAttachment","Spine.Unity.SpineAttachment#getAttachment$1","Spine.Unity.SpineAttachment#init","Spine.Unity.SpineAttachment#ctor","Spine.Unity.SpineBone#getBone","Spine.Unity.SpineBone#getBoneData","Spine.Unity.SpineBone#ctor","Spine.Unity.SpineEvent#init","Spine.Unity.SpineEvent#ctor","Spine.Unity.SpineIkConstraint#ctor","Spine.Unity.SpinePathConstraint#ctor","Spine.Unity.SpineSkin#init","Spine.Unity.SpineSkin#ctor","Spine.Unity.SpineSlot#init","Spine.Unity.SpineSlot#ctor","Spine.Unity.SpineTransformConstraint#ctor","Spine.Unity.WaitForSpineAnimationComplete#ctor","Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1","Spine.Unity.WaitForSpineAnimationEnd#ctor","Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1","Spine.Unity.AnimationReferenceAsset#init","Spine.Unity.AnimationReferenceAsset#op_Implicit","Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get","Spine.Unity.AnimationReferenceAsset#Animation#get","Spine.Unity.AnimationReferenceAsset#Clear","Spine.Unity.AnimationReferenceAsset#Initialize","Spine.Unity.PointFollower#SkeletonRenderer#get","Spine.Unity.PointFollower#SkeletonComponent#get","Spine.Unity.PointFollower#IsValid#get","Spine.Unity.PointFollower#init","Spine.Unity.PointFollower#Initialize","Spine.Unity.PointFollower#HandleRebuildRenderer","Spine.Unity.PointFollower#UpdateReferences","Spine.Unity.PointFollower#OnDestroy","Spine.Unity.PointFollower#LateUpdate","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#NewSpineGameObject","Spine.Unity.SkeletonRenderer#AddSpineComponent","Spine.Unity.SkeletonRenderer#UpdateMode#get","Spine.Unity.SkeletonRenderer#UpdateMode#set","Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get","Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get","Spine.Unity.SkeletonRenderer#Skeleton#get","Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#addGenerateMeshOverride","Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride","Spine.Unity.SkeletonRenderer#SetMeshSettings","Spine.Unity.SkeletonRenderer#Awake","Spine.Unity.SkeletonRenderer#OnDisable","Spine.Unity.SkeletonRenderer#OnDestroy","Spine.Unity.SkeletonRenderer#ClearState","Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity","Spine.Unity.SkeletonRenderer#Initialize","Spine.Unity.SkeletonRenderer#LateUpdate","Spine.Unity.SkeletonRenderer#LateUpdateMesh","Spine.Unity.SkeletonRenderer#OnBecameVisible","Spine.Unity.SkeletonRenderer#OnBecameInvisible","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots","Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType","Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject","Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent","Spine.Unity.SkeletonGraphic#SetRectTransformSize","Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get","Spine.Unity.SkeletonGraphic#UpdateMode#get","Spine.Unity.SkeletonGraphic#UpdateMode#set","Spine.Unity.SkeletonGraphic#SeparatorParts#get","Spine.Unity.SkeletonGraphic#CustomTextureOverride#get","Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get","Spine.Unity.SkeletonGraphic#OverrideTexture#get","Spine.Unity.SkeletonGraphic#OverrideTexture#set","Spine.Unity.SkeletonGraphic#mainTexture#get","Spine.Unity.SkeletonGraphic#Skeleton#get","Spine.Unity.SkeletonGraphic#Skeleton#set","Spine.Unity.SkeletonGraphic#SkeletonData#get","Spine.Unity.SkeletonGraphic#IsValid#get","Spine.Unity.SkeletonGraphic#AnimationState#get","Spine.Unity.SkeletonGraphic#MeshGenerator#get","Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#UpdateTiming#get","Spine.Unity.SkeletonGraphic#UpdateTiming#set","Spine.Unity.SkeletonGraphic#UnscaledTime#get","Spine.Unity.SkeletonGraphic#UnscaledTime#set","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#Awake","Spine.Unity.SkeletonGraphic#OnDestroy","Spine.Unity.SkeletonGraphic#Rebuild","Spine.Unity.SkeletonGraphic#OnDisable","Spine.Unity.SkeletonGraphic#Update","Spine.Unity.SkeletonGraphic#Update$1","Spine.Unity.SkeletonGraphic#FixedUpdate","Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateAnimationStatus","Spine.Unity.SkeletonGraphic#ApplyAnimation","Spine.Unity.SkeletonGraphic#LateUpdate","Spine.Unity.SkeletonGraphic#OnCullStateChanged","Spine.Unity.SkeletonGraphic#OnBecameVisible","Spine.Unity.SkeletonGraphic#OnBecameInvisible","Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames","Spine.Unity.SkeletonGraphic#GetLastMesh","Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds","Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer","Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers","Spine.Unity.SkeletonGraphic#SetRectTransformBounds","Spine.Unity.SkeletonGraphic#Clear","Spine.Unity.SkeletonGraphic#TrimRenderers","Spine.Unity.SkeletonGraphic#Initialize","Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers","Spine.Unity.SkeletonGraphic#UpdateMesh","Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions","Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions","Spine.Unity.SkeletonGraphic#InitMeshBuffers","Spine.Unity.SkeletonGraphic#DisposeMeshBuffers","Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer","Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount","Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects","Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureMeshesCount","Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount","Spine.Unity.SkeletonGraphic#DestroyMeshes","Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount","Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents","Spine.Unity.SkeletonGraphic#GetLayoutScale","Spine.Unity.SkeletonGraphic#GetCurrentRectSize","Spine.Unity.SkeletonAnimation#AddToGameObject","Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject","Spine.Unity.SkeletonAnimation#AnimationState#get","Spine.Unity.SkeletonAnimation#UpdateTiming#get","Spine.Unity.SkeletonAnimation#UpdateTiming#set","Spine.Unity.SkeletonAnimation#UnscaledTime#get","Spine.Unity.SkeletonAnimation#UnscaledTime#set","Spine.Unity.SkeletonAnimation#AnimationName#get","Spine.Unity.SkeletonAnimation#AnimationName#set","Spine.Unity.SkeletonAnimation#init","Spine.Unity.SkeletonAnimation#addOnAnimationRebuild","Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild","Spine.Unity.SkeletonAnimation#addBeforeApply","Spine.Unity.SkeletonAnimation#removeBeforeApply","Spine.Unity.SkeletonAnimation#addUpdateLocal","Spine.Unity.SkeletonAnimation#removeUpdateLocal","Spine.Unity.SkeletonAnimation#addUpdateWorld","Spine.Unity.SkeletonAnimation#removeUpdateWorld","Spine.Unity.SkeletonAnimation#addUpdateComplete","Spine.Unity.SkeletonAnimation#removeUpdateComplete","Spine.Unity.SkeletonAnimation#ClearState","Spine.Unity.SkeletonAnimation#Initialize","Spine.Unity.SkeletonAnimation#Update$1","Spine.Unity.SkeletonAnimation#Update","Spine.Unity.SkeletonAnimation#FixedUpdate","Spine.Unity.SkeletonAnimation#UpdateAnimationStatus","Spine.Unity.SkeletonAnimation#ApplyAnimation","Spine.Unity.SkeletonAnimation#LateUpdate","Spine.Unity.SkeletonAnimation#OnBecameVisible","Spine.Unity.SkeletonMecanim#Translator#get","Spine.Unity.SkeletonMecanim#UpdateTiming#get","Spine.Unity.SkeletonMecanim#UpdateTiming#set","Spine.Unity.SkeletonMecanim#init","Spine.Unity.SkeletonMecanim#addOnAnimationRebuild","Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild","Spine.Unity.SkeletonMecanim#addBeforeApply","Spine.Unity.SkeletonMecanim#removeBeforeApply","Spine.Unity.SkeletonMecanim#addUpdateLocal","Spine.Unity.SkeletonMecanim#removeUpdateLocal","Spine.Unity.SkeletonMecanim#addUpdateWorld","Spine.Unity.SkeletonMecanim#removeUpdateWorld","Spine.Unity.SkeletonMecanim#addUpdateComplete","Spine.Unity.SkeletonMecanim#removeUpdateComplete","Spine.Unity.SkeletonMecanim#Initialize","Spine.Unity.SkeletonMecanim#Update","Spine.Unity.SkeletonMecanim#FixedUpdate","Spine.Unity.SkeletonMecanim#UpdateAnimation","Spine.Unity.SkeletonMecanim#ApplyAnimation","Spine.Unity.SkeletonMecanim#LateUpdate","Spine.Unity.SkeletonMecanim#OnBecameVisible"]' ) ); }
/**
 * @version 1.0.8777.33196
 * @copyright anton
 * @compiler Bridge.NET 17.9.40-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*AspectRatio start.*/
    Bridge.define("AspectRatio", {
        $kind: 6,
        statics: {
            fields: {
                AR920: 0,
                AR919: 1,
                AR918: 2,
                AR916: 3,
                AR34: 4
            }
        }
    });
    /*AspectRatio end.*/

    /*BodyPart start.*/
    Bridge.define("BodyPart", {
        $kind: 6,
        statics: {
            fields: {
                Head: 0,
                Eye: 1,
                Mouth: 2,
                Acc: 3,
                Body: 4
            }
        }
    });
    /*BodyPart end.*/

    /*BreathButton start.*/
    Bridge.define("BreathButton", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            buttonScale: 0,
            sq: null,
            constantBreath: false,
            increaseScale: false,
            delayFirstTime: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "BreathButton#init", this ); }

                this.constantBreath = false;
                this.increaseScale = false;
                this.delayFirstTime = 0;
            }
        },
        methods: {
            /*BreathButton.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "BreathButton#Awake", this ); }

                this.buttonScale = this.transform.localScale.y;
            },
            /*BreathButton.Awake end.*/

            /*BreathButton.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "BreathButton#OnEnable", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                DG.Tweening.ShortcutExtensions.DOScale(this.transform, this.buttonScale, 0);
                this.Invoke("DoScale", this.delayFirstTime);
                //DoScale();
            },
            /*BreathButton.OnEnable end.*/

            /*BreathButton.DoScale start.*/
            DoScale: function () {
if ( TRACE ) { TRACE( "BreathButton#DoScale", this ); }

                this.sq = DG.Tweening.DOTween.Sequence();

                var t = UnityEngine.Random.Range$1(0.8, 1.2);
                if (this.constantBreath) {
                    t = 1;
                    DG.Tweening.TweenSettingsExtensions.AppendInterval(this.sq, 1);

                }
                if (this.increaseScale) {
                    DG.Tweening.TweenSettingsExtensions.Append(this.sq, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale(this.transform, this.buttonScale + 0.1, 0.3), DG.Tweening.Ease.OutQuad));
                } else {
                    DG.Tweening.TweenSettingsExtensions.Append(this.sq, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale(this.transform, this.buttonScale - 0.1, 0.3), DG.Tweening.Ease.OutQuad));
                }
                DG.Tweening.TweenSettingsExtensions.Append(this.sq, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale(this.transform, this.buttonScale, 0.3), DG.Tweening.Ease.InQuad));
                DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Sequence, this.sq, -1, DG.Tweening.LoopType.Yoyo);

                if (!this.constantBreath) {
                    DG.Tweening.TweenSettingsExtensions.PrependInterval(this.sq, t);
                }
            },
            /*BreathButton.DoScale end.*/

            /*BreathButton.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "BreathButton#OnDisable", this ); }

                this.CancelInvoke$1("DoScale");
                DG.Tweening.TweenExtensions.Kill(this.sq);
            },
            /*BreathButton.OnDisable end.*/


        }
    });
    /*BreathButton end.*/

    /*CameraController start.*/
    /**
     * @public
     * @class CameraController
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("CameraController", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            characterManager: null
        }
    });
    /*CameraController end.*/

    /*CameraHandler start.*/
    Bridge.define("CameraHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            characterManager: null,
            cams: null,
            cameras: null,
            _transform: null,
            shakeTimer: 0,
            shakePower: 0,
            defaultPos: null,
            cameraMain: null,
            defaultSize: 0,
            clickable: false,
            furnitureSelectable: false,
            aspectRatio: 0,
            zoomPos: null,
            orthoSize: 0
        },
        props: {
            Clickable: {
                get: function () {
if ( TRACE ) { TRACE( "CameraHandler#Clickable#get", this ); }

                    return this.clickable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "CameraHandler#Clickable#set", this ); }

                    this.clickable = value;
                }
            },
            FurnitureSelectable: {
                get: function () {
if ( TRACE ) { TRACE( "CameraHandler#FurnitureSelectable#get", this ); }

                    return this.furnitureSelectable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "CameraHandler#FurnitureSelectable#set", this ); }

                    this.furnitureSelectable = value;
                }
            },
            CameraMain: {
                get: function () {
if ( TRACE ) { TRACE( "CameraHandler#CameraMain#get", this ); }

                    return this.cameraMain;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "CameraHandler#CameraMain#set", this ); }

                    this.cameraMain = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CameraHandler#init", this ); }

                this.defaultPos = new UnityEngine.Vector3();
                this.zoomPos = new UnityEngine.Vector3();
                this.defaultSize = 6.5;
                this.clickable = true;
            }
        },
        methods: {
            /*CameraHandler.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CameraHandler#Awake", this ); }

                CameraHandler.Instance = this;

                this.RegisterListener();

                this.SetSize();
            },
            /*CameraHandler.Awake end.*/

            /*CameraHandler.SetSize start.*/
            SetSize: function () {
if ( TRACE ) { TRACE( "CameraHandler#SetSize", this ); }

                this.cameraMain = this.cameras[0]; //default camera


                if (this.cameraMain.aspect <= 0.451) {
                    MyDebug.Log("9:20");
                    this.aspectRatio = AspectRatio.AR920;
                } else if (this.cameraMain.aspect <= 0.474) {
                    MyDebug.Log("9:19");
                    this.aspectRatio = AspectRatio.AR919;

                } else if (this.cameraMain.aspect <= 0.5) {
                    MyDebug.Log("9:18");
                    this.aspectRatio = AspectRatio.AR918;
                } else if (this.cameraMain.aspect <= 0.563) {
                    MyDebug.Log("9:16");
                    this.aspectRatio = AspectRatio.AR916;
                } else {
                    MyDebug.Log("3:4");
                    this.aspectRatio = AspectRatio.AR34;
                }

            },
            /*CameraHandler.SetSize end.*/

            /*CameraHandler.RegisterListener start.*/
            RegisterListener: function () {
if ( TRACE ) { TRACE( "CameraHandler#RegisterListener", this ); }

                EventDispatcherExtension.RegisterListener(this, EventID.OnReplayPK, Bridge.fn.bind(this, function (param) {
                    this.SetCamForPk();
                }));
                EventDispatcherExtension.RegisterListener(this, EventID.OnEnterLeaderboard, Bridge.fn.bind(this, function (param) {
                    this.ResetCameraHome();
                }));
            },
            /*CameraHandler.RegisterListener end.*/

            /*CameraHandler.DisplayCharacterInChallenge start.*/
            DisplayCharacterInChallenge: function () {
if ( TRACE ) { TRACE( "CameraHandler#DisplayCharacterInChallenge", this ); }

                this.characterManager.transform.position = new pc.Vec3( 0, -1.0, 0 );
            },
            /*CameraHandler.DisplayCharacterInChallenge end.*/

            /*CameraHandler.SetCamForPk start.*/
            SetCamForPk: function () {
if ( TRACE ) { TRACE( "CameraHandler#SetCamForPk", this ); }

                //CameraInGameplay(6.5f);
            },
            /*CameraHandler.SetCamForPk end.*/

            /*CameraHandler.ResetCameraHome start.*/
            ResetCameraHome: function () {
if ( TRACE ) { TRACE( "CameraHandler#ResetCameraHome", this ); }

                this.CheckConditionOrthoCameraConfig();
            },
            /*CameraHandler.ResetCameraHome end.*/

            /*CameraHandler.CheckConditionOrthoCameraConfig start.*/
            CheckConditionOrthoCameraConfig: function () {
if ( TRACE ) { TRACE( "CameraHandler#CheckConditionOrthoCameraConfig", this ); }

                //if (aspectRatio == AspectRatio.AR919)
                //{
                //    CameraInGameplay(20);
                //}
                //else
                //{
                //    CameraInGameplay(15);
                //}
            },
            /*CameraHandler.CheckConditionOrthoCameraConfig end.*/

            /*CameraHandler.SetPosOfCamera start.*/
            SetPosOfCamera: function (pos) {
if ( TRACE ) { TRACE( "CameraHandler#SetPosOfCamera", this ); }

                this.cams[0].position = pos.$clone();
                this.cameras[0].orthographicSize = 11;
            },
            /*CameraHandler.SetPosOfCamera end.*/

            /*CameraHandler.CameraInGameplay start.*/
            CameraInGameplay: function (camSize) {
if ( TRACE ) { TRACE( "CameraHandler#CameraInGameplay", this ); }

                for (var i = 0; i < this.cameras.length; i = (i + 1) | 0) {
                    this.cameras[i].orthographicSize = camSize;
                    this.cams[i].position = new pc.Vec3( 0, 0, -10 );
                }
                this.clickable = true;
            },
            /*CameraHandler.CameraInGameplay end.*/

            /*CameraHandler.CameraForConfetti start.*/
            CameraForConfetti: function (camSize) {
if ( TRACE ) { TRACE( "CameraHandler#CameraForConfetti", this ); }

                for (var i = 0; i < this.cameras.length; i = (i + 1) | 0) {
                    this.cameras[i].orthographicSize = camSize;
                }
            },
            /*CameraHandler.CameraForConfetti end.*/

            /*CameraHandler.FocusItem start.*/
            FocusItem: function (pos, toSize) {
if ( TRACE ) { TRACE( "CameraHandler#FocusItem", this ); }

                if (toSize === void 0) { toSize = 11.0; }
                pos = pos.$clone().add( new pc.Vec3( 0, -4.0, -10 ) );
                this.furnitureSelectable = false;
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.ShortcutExtensions.DOOrthoSize(this.cameras[0], toSize, 0.2), DG.Tweening.Ease.InOutQuad), Bridge.fn.bind(this, function () {
                    this.furnitureSelectable = true;
                }));
            },
            /*CameraHandler.FocusItem end.*/

            /*CameraHandler.ZoomIn start.*/
            ZoomIn: function () {
if ( TRACE ) { TRACE( "CameraHandler#ZoomIn", this ); }

                this.zoomPos = pc.Vec3.ZERO.clone();
                this.orthoSize = 6.5;
                this.DoZoom(this.zoomPos.$clone(), this.orthoSize);
            },
            /*CameraHandler.ZoomIn end.*/

            /*CameraHandler.ZoomOut start.*/
            ZoomOut: function () {
if ( TRACE ) { TRACE( "CameraHandler#ZoomOut", this ); }

                this.zoomPos = new pc.Vec3( 0, -4.8, 0 );
                this.orthoSize = 11;
                this.DoZoom(this.zoomPos.$clone(), this.orthoSize);
            },
            /*CameraHandler.ZoomOut end.*/

            /*CameraHandler.DoZoom start.*/
            DoZoom: function (pos, toSize) {
if ( TRACE ) { TRACE( "CameraHandler#DoZoom", this ); }

                this.clickable = false;
                this.defaultSize = this.cameras[0].orthographicSize;
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(this.cams[0], pos.y, 0.3), DG.Tweening.Ease.InOutSine);
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.ShortcutExtensions.DOOrthoSize(this.cameras[0], toSize, 0.3), DG.Tweening.Ease.InOutSine), Bridge.fn.bind(this, function () {
                    this.clickable = true;
                }));
            },
            /*CameraHandler.DoZoom end.*/


        }
    });
    /*CameraHandler end.*/

    /*CanvasHandler start.*/
    Bridge.define("CanvasHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*CanvasHandler.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CanvasHandler#Awake", this ); }

                var sx = (((Bridge.Int.div(UnityEngine.Screen.width, 1080)) | 0));
                var sy = (UnityEngine.Screen.height / 1920.0);
                this.GetComponent(UnityEngine.UI.CanvasScaler).matchWidthOrHeight = (sx < sy ? 0 : 1);
            },
            /*CanvasHandler.Awake end.*/


        }
    });
    /*CanvasHandler end.*/

    /*CatalogueTheme start.*/
    Bridge.define("CatalogueTheme", {
        $kind: 6,
        statics: {
            fields: {
                Skibidi: 0,
                alime: 1,
                trend: 2,
                Normal: 3
            }
        }
    });
    /*CatalogueTheme end.*/

    /*CharacterManager start.*/
    Bridge.define("CharacterManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            monsterBody: null,
            spawnMoney: false,
            headHolder: null,
            bodies: null,
            boneFollowers: null,
            numberVariantBody: 0,
            sortingGroup: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CharacterManager#init", this ); }

                this.monsterBody = "";
                this.spawnMoney = true;
            }
        },
        methods: {
            /*CharacterManager.SetScale start.*/
            SetScale: function (range) {
if ( TRACE ) { TRACE( "CharacterManager#SetScale", this ); }

                this.transform.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( 0.8 );
            },
            /*CharacterManager.SetScale end.*/

            /*CharacterManager.SetPos start.*/
            SetPos: function (pos) {
if ( TRACE ) { TRACE( "CharacterManager#SetPos", this ); }

                this.transform.localPosition = pos.$clone();
            },
            /*CharacterManager.SetPos end.*/

            /*CharacterManager.SetTypeOfAnim start.*/
            SetTypeOfAnim: function (body, id) {
if ( TRACE ) { TRACE( "CharacterManager#SetTypeOfAnim", this ); }

                if (id === void 0) { id = -1; }
                if (id === 0) {
                    body.AnimationState.setAnimation(0, "Zerotwo", true).mixDuration = 0;
                    body.skeleton.setToSetupPose();
                    return;
                }
                var randomIdx = UnityEngine.Random.Range(0, 4);
                if (randomIdx <= 1) {
                    body.AnimationState.setAnimation(0, "Zerotwo", true).mixDuration = 0;
                } else {
                    body.AnimationState.setAnimation(0, "Zerotwo" + randomIdx, true).mixDuration = 0;
                }
                body.skeleton.setToSetupPose();
            },
            /*CharacterManager.SetTypeOfAnim end.*/

            /*CharacterManager.ChangeToDanceAnim start.*/
            ChangeToDanceAnim: function (saveDance) {
if ( TRACE ) { TRACE( "CharacterManager#ChangeToDanceAnim", this ); }

                if (saveDance === void 0) { saveDance = false; }
                for (var i = 0; i < this.bodies.length; i = (i + 1) | 0) {
                    if (!this.bodies[i].gameObject.activeSelf) {
                        continue;
                    }
                    if (saveDance) {
                        if (i === 0) {
                            this.bodies[i].Skeleton.setSkinByName(this.monsterBody);
                        } else {
                            try {
                                this.bodies[i].Skeleton.setSkinByName("trend/" + (this.monsterBody || "")); //
                            } catch ($e1) {
                                $e1 = System.Exception.create($e1);
                            }
                            try {
                                this.bodies[i].Skeleton.setSkinByName("alime/" + (this.monsterBody || "")); //
                            } catch ($e2) {
                                $e2 = System.Exception.create($e2);
                            }
                            try {
                                this.bodies[i].Skeleton.setSkinByName("Skibidi/" + (this.monsterBody || "")); //
                            } catch ($e3) {
                                $e3 = System.Exception.create($e3);
                            }
                        }
                        //bodies[i].Skeleton.SetSkin(monsterBody);//
                        this.bodies[i].Skeleton.setToSetupPose();
                    }

                    this.SetTypeOfAnim(this.bodies[i], i);
                    if (!saveDance) {
                        return;
                    }
                    this.boneFollowers[i].skeletonRenderer = this.bodies[i]; //
                    this.boneFollowers[i].enabled = false; //
                    this.boneFollowers[i].SetBone(i === 0 ? "face" : (this.monsterBody || "") + "_head"); //
                    this.boneFollowers[i].enabled = true; //
                }
            },
            /*CharacterManager.ChangeToDanceAnim end.*/


        }
    });
    /*CharacterManager end.*/

    /*CurrencyConvert start.*/
    Bridge.define("CurrencyConvert", {
        statics: {
            methods: {
                /*CurrencyConvert.RoundConvert:static start.*/
                RoundConvert: function (money) {
if ( TRACE ) { TRACE( "CurrencyConvert#RoundConvert", this ); }

                    var res = Bridge.toString(money);
                    if (res.length > 9) {
                        return (Bridge.toString((System.Int64.clip32(money.div(System.Int64(1000000000))))) || "") + "B";
                    }
                    if (res.length > 6) {
                        return (Bridge.toString((System.Int64.clip32(money.div(System.Int64(1000000))))) || "") + "M";
                    }
                    if (res.length > 3) {
                        return (Bridge.toString((System.Int64.clip32(money.div(System.Int64(1000))))) || "") + "K";
                    }
                    return res;
                },
                /*CurrencyConvert.RoundConvert:static end.*/

                /*CurrencyConvert.DecimalConvert:static start.*/
                DecimalConvert: function (money, precision) {
if ( TRACE ) { TRACE( "CurrencyConvert#DecimalConvert", this ); }

                    if (precision === void 0) { precision = 1; }
                    var res = Bridge.toString(money);

                    if (precision === 3) {
                        if (res.length > 9) {
                            return (System.Single.format((money / 1000000000), "#.000") || "") + "B";
                        }
                        if (res.length > 6) {
                            return (System.Single.format((money / 1000000), "#.000") || "") + "M";
                        }
                        if (res.length > 3) {
                            return (System.Single.format((money / 1000), "#.000") || "") + "K";
                        }
                        return res;
                    }
                    if (res.length > 9) {
                        if (money.mod(System.Int64(1000000000)).equals(System.Int64(0))) {
                            return (Bridge.toString((System.Int64.clip32(money.div(System.Int64(1000000000))))) || "") + "B";
                        }
                        return (System.Single.format((money / 1000000000), "#.0") || "") + "B";
                    }
                    if (res.length > 6) {
                        if (money.mod(System.Int64(1000000)).equals(System.Int64(0))) {
                            return (System.Single.format((money / 1000000)) || "") + "M";
                        }
                        return (System.Single.format((money / 1000000), "#.0") || "") + "M";
                    }
                    if (res.length > 3) {
                        if (money.mod(System.Int64(1000)).equals(System.Int64(0))) {
                            return (Bridge.toString((System.Int64.clip32(money.div(System.Int64(1000))))) || "") + "K";
                        }
                        return (System.Single.format((money / 1000), "#.0") || "") + "K";
                    }
                    return res;
                },
                /*CurrencyConvert.DecimalConvert:static end.*/


            }
        }
    });
    /*CurrencyConvert end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {pc.ColorGradient}              gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Outline's effectColor alpha to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Outline's effectColor to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                /**
                 * Tweens a Outline's effectDistance to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector2}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                /**
                 * Tweens a Text's text from one integer to another, with options for thousands separators
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}                 target                   
                 * @param   {number}                              fromValue                The value to start from
                 * @param   {number}                              endValue                 The end value to reach
                 * @param   {number}                              duration                 The duration of the tween
                 * @param   {boolean}                             addThousandsSeparator    If TRUE (default) also adds thousands separators
                 * @param   {System.Globalization.CultureInfo}    culture                  The {@link } to use (InvariantCulture if NULL)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var v = fromValue;
                    var cInfo = !addThousandsSeparator ? null : culture || System.Globalization.CultureInfo.invariantCulture;
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        target.text = addThousandsSeparator ? System.Int32.format(v, "N0", cInfo) : Bridge.toString(v);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition so that it draws a circle around the given center.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations.<p />
                 IMPORTANT: SetFrom(value) requires a {@link } instead of a float, where the X property represents the "from degrees value"
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target             
                 * @param   {UnityEngine.Vector2}               center             Circle-center/pivot around which to rotate (in UI anchoredPosition coordinates)
                 * @param   {number}                            endValueDegrees    The end value degrees to reach (to rotate counter-clockwise pass a negative value)
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           relativeCenter     If TRUE the {@link } coordinates will be considered as relative to the target's current anchoredPosition
                 * @param   {boolean}                           snapping           If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOShapeCircle: function (target, center, endValueDegrees, duration, relativeCenter, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShapeCircle", this ); }

                    if (relativeCenter === void 0) { relativeCenter = false; }
                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To(UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions, DG.Tweening.Plugins.CirclePlugin.Get(), function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, center.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$7(t, endValueDegrees, relativeCenter, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position.$clone());
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color.$clone());
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed
                 or has reached the given time position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP  TextMesh Pro
     - DOTWEEN_TK2D  2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    trans.rotation = newRot.$clone();
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return false;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return false;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t = null;
                    var rBodyFoundAndTweened = false;
                    if (!rBodyFoundAndTweened) {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*DragDropTut start.*/
    Bridge.define("DragDropTut", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*DragDropTut.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "DragDropTut#OnEnable", this ); }

                DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMove(this.transform, new pc.Vec3( -110.0, 250.0, 0 ), 1.5), DG.Tweening.Ease.InOutSine), -1, DG.Tweening.LoopType.Restart);
            },
            /*DragDropTut.OnEnable end.*/


        }
    });
    /*DragDropTut end.*/
    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Action
     * @param   {System.Object}    arg
     * @return  {void}
     */


    /*EventDispatcher start.*/
    Bridge.define("EventDispatcher", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                s_instance: null
            },
            props: {
                Instance: {
                    get: function () {
if ( TRACE ) { TRACE( "EventDispatcher#Instance#get", this ); }

                        // instance not exist, then create new one
                        if (UnityEngine.MonoBehaviour.op_Equality(EventDispatcher.s_instance, null)) {
                            // create new Gameobject, and add EventDispatcher component
                            var singletonObject = new UnityEngine.GameObject.ctor();
                            EventDispatcher.s_instance = singletonObject.AddComponent(EventDispatcher);
                            singletonObject.name = "Singleton - EventDispatcher";
                        }
                        return EventDispatcher.s_instance;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "EventDispatcher#Instance#set", this ); }
 }
                }
            },
            methods: {
                /*EventDispatcher.HasInstance:static start.*/
                HasInstance: function () {
if ( TRACE ) { TRACE( "EventDispatcher#HasInstance", this ); }

                    return UnityEngine.MonoBehaviour.op_Inequality(EventDispatcher.s_instance, null);
                },
                /*EventDispatcher.HasInstance:static end.*/


            }
        },
        fields: {
            /**
             * @instance
             * @private
             * @memberof EventDispatcher
             * @type System.Collections.Generic.Dictionary$2
             */
            _listeners: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "EventDispatcher#init", this ); }

                this._listeners = new (System.Collections.Generic.Dictionary$2(EventID,Function)).ctor();
            }
        },
        methods: {
            /*EventDispatcher.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "EventDispatcher#Awake", this ); }

                // check if there's another instance already exist in scene
                if (UnityEngine.MonoBehaviour.op_Inequality(EventDispatcher.s_instance, null) && EventDispatcher.s_instance.GetInstanceID() !== this.GetInstanceID()) {
                    // Destroy this instances because already exist the singleton of EventsDispatcer

                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                } else {
                    // set instance
                    EventDispatcher.s_instance = this;
                }
            },
            /*EventDispatcher.Awake end.*/

            /*EventDispatcher.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "EventDispatcher#OnDestroy", this ); }

                // reset this static var to null if it's the singleton instance
                if (UnityEngine.MonoBehaviour.op_Equality(EventDispatcher.s_instance, this)) {
                    this.ClearAllListener();
                    EventDispatcher.s_instance = null;
                }
            },
            /*EventDispatcher.OnDestroy end.*/

            /*EventDispatcher.RegisterListener start.*/
            /**
             * Register to listen for eventID
             *
             * @instance
             * @public
             * @this EventDispatcher
             * @memberof EventDispatcher
             * @param   {EventID}          eventID     EventID that object want to listen
             * @param   {System.Action}    callback    Callback will be invoked when this eventID be raised
             * @return  {void}
             */
            RegisterListener: function (eventID, callback) {
if ( TRACE ) { TRACE( "EventDispatcher#RegisterListener", this ); }



                // check if listener exist in distionary
                if (this._listeners.containsKey(eventID)) {
                    // add callback to our collection
                    this._listeners.setItem(eventID, Bridge.fn.combine(this._listeners.getItem(eventID), callback));
                } else {
                    // add new key-value pair
                    this._listeners.add(eventID, null);
                    this._listeners.setItem(eventID, Bridge.fn.combine(this._listeners.getItem(eventID), callback));
                }
            },
            /*EventDispatcher.RegisterListener end.*/

            /*EventDispatcher.PostEvent start.*/
            /**
             * Posts the event. This will notify all listener that register for this event
             *
             * @instance
             * @public
             * @this EventDispatcher
             * @memberof EventDispatcher
             * @param   {EventID}          eventID    EventID.
             * @param   {System.Object}    param      Parameter. Can be anything (struct, class ...), Listener will make a cast to get the data
             * @return  {void}
             */
            PostEvent: function (eventID, param) {
if ( TRACE ) { TRACE( "EventDispatcher#PostEvent", this ); }

                if (param === void 0) { param = null; }
                if (!this._listeners.containsKey(eventID)) {
                    return;
                }

                // posting event
                var callbacks = this._listeners.getItem(eventID);
                // if there's no listener remain, then do nothing
                if (!Bridge.staticEquals(callbacks, null)) {
                    callbacks(param);
                } else {
                    this._listeners.remove(eventID);
                }
            },
            /*EventDispatcher.PostEvent end.*/

            /*EventDispatcher.RemoveListener start.*/
            /**
             * Removes the listener. Use to Unregister listener
             *
             * @instance
             * @public
             * @this EventDispatcher
             * @memberof EventDispatcher
             * @param   {EventID}          eventID     EventID.
             * @param   {System.Action}    callback    Callback.
             * @return  {void}
             */
            RemoveListener: function (eventID, callback) {
if ( TRACE ) { TRACE( "EventDispatcher#RemoveListener", this ); }


                if (this._listeners.containsKey(eventID)) {
                    this._listeners.setItem(eventID, Bridge.fn.remove(this._listeners.getItem(eventID), callback));
                }
            },
            /*EventDispatcher.RemoveListener end.*/

            /*EventDispatcher.ClearAllListener start.*/
            /**
             * Clears all the listener.
             *
             * @instance
             * @public
             * @this EventDispatcher
             * @memberof EventDispatcher
             * @return  {void}
             */
            ClearAllListener: function () {
if ( TRACE ) { TRACE( "EventDispatcher#ClearAllListener", this ); }

                this._listeners.clear();
            },
            /*EventDispatcher.ClearAllListener end.*/


        }
    });
    /*EventDispatcher end.*/

    /*EventDispatcherExtension start.*/
    /**
     * Delare some "shortcut" for using EventDispatcher easier
     *
     * @static
     * @abstract
     * @public
     * @class EventDispatcherExtension
     */
    Bridge.define("EventDispatcherExtension", {
        statics: {
            methods: {
                /*EventDispatcherExtension.RegisterListener:static start.*/
                /**
                 * @static
                 * @public
                 * @this EventDispatcherExtension
                 * @memberof EventDispatcherExtension
                 * @param   {UnityEngine.MonoBehaviour}    listener    
                 * @param   {EventID}                      eventID     
                 * @param   {System.Action}                callback
                 * @return  {void}
                 */
                RegisterListener: function (listener, eventID, callback) {
if ( TRACE ) { TRACE( "EventDispatcherExtension#RegisterListener", this ); }

                    EventDispatcher.Instance.RegisterListener(eventID, callback);
                },
                /*EventDispatcherExtension.RegisterListener:static end.*/

                /*EventDispatcherExtension.PostEvent$1:static start.*/
                /**
                 * @static
                 * @public
                 * @this EventDispatcherExtension
                 * @memberof EventDispatcherExtension
                 * @param   {UnityEngine.MonoBehaviour}    listener    
                 * @param   {EventID}                      eventID     
                 * @param   {System.Object}                param
                 * @return  {void}
                 */
                PostEvent$1: function (listener, eventID, param) {
if ( TRACE ) { TRACE( "EventDispatcherExtension#PostEvent$1", this ); }

                    EventDispatcher.Instance.PostEvent(eventID, param);
                },
                /*EventDispatcherExtension.PostEvent$1:static end.*/

                /*EventDispatcherExtension.PostEvent:static start.*/
                /**
                 * @static
                 * @public
                 * @this EventDispatcherExtension
                 * @memberof EventDispatcherExtension
                 * @param   {UnityEngine.MonoBehaviour}    sender     
                 * @param   {EventID}                      eventID
                 * @return  {void}
                 */
                PostEvent: function (sender, eventID) {
if ( TRACE ) { TRACE( "EventDispatcherExtension#PostEvent", this ); }

                    EventDispatcher.Instance.PostEvent(eventID, null);
                },
                /*EventDispatcherExtension.PostEvent:static end.*/


            }
        }
    });
    /*EventDispatcherExtension end.*/

    /*EventID start.*/
    Bridge.define("EventID", {
        $kind: 6,
        statics: {
            fields: {
                OnClick: 0,
                OnReplay: 1,
                OnStart: 2,
                OnBuyItem: 3,
                /**
                 * Unlock all ad, coin items
                 *
                 * @static
                 * @public
                 * @memberof EventID
                 * @constant
                 * @default 4
                 * @type EventID
                 */
                OnUnlock: 4,
                /**
                 * Unlock all ad items
                 *
                 * @static
                 * @public
                 * @memberof EventID
                 * @constant
                 * @default 5
                 * @type EventID
                 */
                OnUnlockAdItems: 5,
                /**
                 * On change state skip ad -&gt; ad
                 *
                 * @static
                 * @public
                 * @memberof EventID
                 * @constant
                 * @default 6
                 * @type EventID
                 */
                OnDisplayAdItem: 6,
                OnRewardSpin: 7,
                OnPickLevel: 8,
                OnUnlockLevel: 9,
                OnTakeAShot: 10,
                OnEnterIdleMode: 11,
                OnEnterLeaderboard: 12,
                OnEnterShop: 13,
                OnEnterPkMode: 14,
                OnTurnOffSuggestSymbolItems: 15,
                OnReplayPK: 16,
                OnUnlockPkMode: 17,
                OnSubcribe: 18,
                OnRewardTop1: 19,
                OnRewardTop2: 20,
                OnRewardTop3: 21,
                OnRewardTop10: 22,
                OnRewardTop50: 23,
                OnRewardTop100: 24,
                OnTurnOffInteractNativeAd: 25
            }
        }
    });
    /*EventID end.*/

    /*GridHandler start.*/
    Bridge.define("GridHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            content: null,
            grid: null,
            cellSize: 0
        },
        methods: {
            /*GridHandler.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GridHandler#Start", this ); }

                //cellSize = (UIHandler.Instance.WidthCanvas - 6 * 25) / 5;
                //grid.cellSize = new Vector2(cellSize, cellSize);
            },
            /*GridHandler.Start end.*/

            /*GridHandler.RestoreInitialPos start.*/
            RestoreInitialPos: function () {
if ( TRACE ) { TRACE( "GridHandler#RestoreInitialPos", this ); }

                //set pos
                //grid.
                var y = this.content.localPosition.y;
                this.content.localPosition = this.content.localPosition.$clone().sub( new pc.Vec3( 0, y, 0 ) );
            },
            /*GridHandler.RestoreInitialPos end.*/

            /*GridHandler.SetStateContent start.*/
            SetStateContent: function (state) {
if ( TRACE ) { TRACE( "GridHandler#SetStateContent", this ); }

                this.gameObject.SetActive(state);
                this.RestoreInitialPos();
            },
            /*GridHandler.SetStateContent end.*/


        }
    });
    /*GridHandler end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*IdleActions start.*/
    Bridge.define("IdleActions", {
        statics: {
            fields: {
                OnUnlockLeftMap: null,
                OnUnlockRightMap: null,
                OnUnlockTopMap: null,
                OnUnlockBottomMap: null,
                OnDisplayIdleUI: null,
                OnHideIdleUI: null,
                OnCalculatePrice: null,
                OnClaimOfflineReward: null,
                OnBoost: null,
                OnDeboost: null,
                OnIncreaseBoosterPercent: null,
                OnDecreaseBoosterPercent: null,
                OnFocusItemInBuilding: null,
                OnPopUpOfflineReward: null,
                OnNotiLimitCharacter: null,
                OnNotiUpgradeSlot: null,
                OnRaiseMoneyAllMonster: null,
                OnSwitchConditionToRaiseMoneyMonster: null,
                OnGlitch: null,
                OnNotiCollection: null,
                OnUpdateInBg: null,
                OnUpdateScaleBodyPart: null,
                OnDisplayAdSkipInBuilding: null,
                OnDisplayAdBooster: null
            }
        }
    });
    /*IdleActions end.*/

    /*Item start.*/
    Bridge.define("Item", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            id: 0,
            bodypartName: null,
            preview: null,
            part: null,
            isAd: false,
            adNum: 0,
            price: 0,
            bodyPart: 0,
            specialPos: false,
            realPos: null,
            catalogue: 0,
            /**
             * 0: l nhng con monster c dng chung xng, 1 l monster mi xng k dng chung
             *
             * @instance
             * @public
             * @memberof Item
             * @type number
             */
            dataAsset: 0,
            pkTheme: 0,
            priority: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Item#init", this ); }

                this.realPos = new UnityEngine.Vector3();
                this.adNum = 1;
                this.catalogue = CatalogueTheme.Normal;
                this.priority = Priority.Low;
            }
        }
    });
    /*Item end.*/

    /*ItemDisplay start.*/
    Bridge.define("ItemDisplay", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            _id: 0,
            iconScale: null,
            itemSprite: null,
            fill: null,
            item: null
        },
        methods: {
            /*ItemDisplay.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "ItemDisplay#OnDisable", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
            },
            /*ItemDisplay.OnDisable end.*/

            /*ItemDisplay.Show start.*/
            Show: function (_item, id) {
if ( TRACE ) { TRACE( "ItemDisplay#Show", this ); }

                this.gameObject.SetActive(true);

                this.item = _item;
                this._id = id;

                this.itemSprite.sprite = this.item.preview;
                this.itemSprite.SetNativeSize();

                this.iconScale.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( 0.8 );
            },
            /*ItemDisplay.Show end.*/

            /*ItemDisplay.OnClick start.*/
            OnClick: function () {
if ( TRACE ) { TRACE( "ItemDisplay#OnClick", this ); }

                EventDispatcherExtension.PostEvent$1(this, EventID.OnClick, Bridge.box(this.item.id, System.Int32));

                this.fill.SetActive(true);
                UnityEngine.PlayerPrefs.SetInt(System.Enum.toString(BodyPart, this.item.bodyPart), this.item.id);
                SoundManager.Instance.PlayItemClickedSound();
            },
            /*ItemDisplay.OnClick end.*/

            /*ItemDisplay.Deselect start.*/
            Deselect: function () {
if ( TRACE ) { TRACE( "ItemDisplay#Deselect", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                DG.Tweening.ShortcutExtensions.DOScale(this.transform, 1, 0);
                this.fill.SetActive(false);
            },
            /*ItemDisplay.Deselect end.*/

            /*ItemDisplay.SetSib start.*/
            SetSib: function (idx) {
if ( TRACE ) { TRACE( "ItemDisplay#SetSib", this ); }

                this.transform.SetSiblingIndex(idx);
            },
            /*ItemDisplay.SetSib end.*/


        }
    });
    /*ItemDisplay end.*/

    /*MoneyFly start.*/
    Bridge.define("MoneyFly", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            money: null,
            outline: null,
            moneyTxt: null,
            autoMoneySq: null,
            time: 0,
            countTime: 0,
            orgPos: 0,
            mainChar: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "MoneyFly#init", this ); }

                this.countTime = 1.0;
            }
        },
        methods: {
            /*MoneyFly.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "MoneyFly#Start", this ); }

                this.orgPos = this.transform.localPosition.y;
                var moneyNum;
                if (this.mainChar) {
                    moneyNum = UnityEngine.Random.Range(800, 1000);
                } else {
                    moneyNum = UnityEngine.Random.Range(100, 500);
                }
                this.moneyTxt.text = "+" + moneyNum;
                this.InitSequence();
            },
            /*MoneyFly.Start end.*/

            /*MoneyFly.InitSequence start.*/
            InitSequence: function () {
if ( TRACE ) { TRACE( "MoneyFly#InitSequence", this ); }

                this.autoMoneySq = DG.Tweening.DOTween.Sequence();
                DG.Tweening.TweenSettingsExtensions.SetAutoKill$1(DG.Tweening.Sequence, this.autoMoneySq, false);

                DG.Tweening.TweenSettingsExtensions.Append(this.autoMoneySq, DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.transform, this.orgPos, 0.0));
                DG.Tweening.TweenSettingsExtensions.Append(this.autoMoneySq, DG.Tweening.DOTweenModuleUI.DOFade$2(this.money, 1, 0));
                DG.Tweening.TweenSettingsExtensions.Join(this.autoMoneySq, DG.Tweening.DOTweenModuleUI.DOFade$4(this.moneyTxt, 1, 0));
                DG.Tweening.TweenSettingsExtensions.Join(this.autoMoneySq, DG.Tweening.DOTweenModuleUI.DOFade$3(this.outline, 1, 0));
                DG.Tweening.TweenSettingsExtensions.Join(this.autoMoneySq, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.transform, this.orgPos + 100, 0.8), DG.Tweening.Ease.OutCubic));

                DG.Tweening.TweenSettingsExtensions.Insert(this.autoMoneySq, 0.5, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOFade$2(this.money, 0, 0.3), DG.Tweening.Ease.OutSine));
                DG.Tweening.TweenSettingsExtensions.Insert(this.autoMoneySq, 0.5, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOFade$4(this.moneyTxt, 0, 0.3), DG.Tweening.Ease.OutSine));
                DG.Tweening.TweenSettingsExtensions.Insert(this.autoMoneySq, 0.5, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOFade$3(this.outline, 0, 0.1), DG.Tweening.Ease.OutSine));
                DG.Tweening.TweenExtensions.Play(DG.Tweening.Sequence, this.autoMoneySq);
            },
            /*MoneyFly.InitSequence end.*/

            /*MoneyFly.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "MoneyFly#Update", this ); }

                this.time += UnityEngine.Time.deltaTime;
                if (this.time >= this.countTime) {
                    this.time = 0;
                    DG.Tweening.TweenExtensions.Restart(this.autoMoneySq);
                    //FloatEffect();
                }
            },
            /*MoneyFly.Update end.*/


        }
    });
    /*MoneyFly end.*/

    /*MonsterCreator start.*/
    Bridge.define("MonsterCreator", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            headHolder: null,
            headSR: null,
            eyeSR: null,
            mouthSR: null,
            accSR: null,
            boneFollower1: null,
            boneFollower2: null,
            body1: null,
            body2: null
        },
        methods: {
            /*MonsterCreator.CreateMonster start.*/
            CreateMonster: function (head, eye, mouth, acc, body) {
if ( TRACE ) { TRACE( "MonsterCreator#CreateMonster", this ); }

                this.headSR.sprite = head.part;
                this.eyeSR.sprite = eye.part;
                this.mouthSR.sprite = mouth.part;
                this.accSR.sprite = acc.part;

                if (acc.specialPos) {
                    this.accSR.transform.localPosition = acc.realPos.$clone();

                }
                this.HandleBodyType(body);

                this.transform.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( 0.6 );
                this.gameObject.SetActive(true);
            },
            /*MonsterCreator.CreateMonster end.*/

            /*MonsterCreator.HandleBodyType start.*/
            HandleBodyType: function (body) {
if ( TRACE ) { TRACE( "MonsterCreator#HandleBodyType", this ); }

                if (body.dataAsset === 0) {
                    this.body2.gameObject.SetActive(false);
                    this.body1.gameObject.SetActive(true);

                    this.body1.Skeleton.setSkinByName((body.bodypartName || "") + "_hold");
                    this.SetTypeOfAnim(this.body1, 0);

                    this.boneFollower1.enabled = false;
                    this.boneFollower1.SetBone("face"); //dng chung xng face
                    this.boneFollower1.enabled = true;
                    this.headHolder.SetParent(this.boneFollower1.transform);


                    this.headHolder.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, -89.145 );
                } else {
                    this.body1.gameObject.SetActive(false);
                    this.body2.gameObject.SetActive(true);

                    this.body2.Skeleton.setSkinByName((System.Enum.toString(CatalogueTheme, body.catalogue) || "") + "/" + (body.bodypartName || ""));
                    this.SetTypeOfAnim(this.body2, 1);

                    this.boneFollower2.enabled = false;
                    this.boneFollower2.SetBone((body.bodypartName || "") + "_head");
                    this.boneFollower2.enabled = true;
                    this.headHolder.SetParent(this.boneFollower2.transform);

                    this.headHolder.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, -89.12 );
                }
            },
            /*MonsterCreator.HandleBodyType end.*/

            /*MonsterCreator.SetTypeOfAnim start.*/
            SetTypeOfAnim: function (body, id) {
if ( TRACE ) { TRACE( "MonsterCreator#SetTypeOfAnim", this ); }

                if (id === void 0) { id = -1; }
                if (id === 0) {
                    body.AnimationState.setAnimation(0, "Zerotwo", true).mixDuration = 0;
                    body.Skeleton.setToSetupPose();
                    return;
                }
                var randomIdx = UnityEngine.Random.Range(0, 4);
                if (randomIdx <= 1) {
                    body.AnimationState.setAnimation(0, "Zerotwo", true).mixDuration = 0;
                } else {
                    body.AnimationState.setAnimation(0, "Zerotwo" + randomIdx, true).mixDuration = 0;
                }
                body.skeleton.setToSetupPose();
            },
            /*MonsterCreator.SetTypeOfAnim end.*/


        }
    });
    /*MonsterCreator end.*/

    /*MyDebug start.*/
    Bridge.define("MyDebug", {
        statics: {
            fields: {
                canLog: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "MyDebug#init", this ); }

                    this.canLog = false;
                }
            },
            methods: {
                /*MyDebug.Log$1:static start.*/
                Log$1: function (message, context) {
if ( TRACE ) { TRACE( "MyDebug#Log$1", this ); }

                    if (MyDebug.canLog) {
                        UnityEngine.Debug.Log(message, context);
                    }
                },
                /*MyDebug.Log$1:static end.*/

                /*MyDebug.Log:static start.*/
                Log: function (message) {
if ( TRACE ) { TRACE( "MyDebug#Log", this ); }

                    if (MyDebug.canLog) {
                        UnityEngine.Debug.Log(message);
                    }
                },
                /*MyDebug.Log:static end.*/

                /*MyDebug.LogError:static start.*/
                LogError: function (message) {
if ( TRACE ) { TRACE( "MyDebug#LogError", this ); }

                    if (MyDebug.canLog) {
                        UnityEngine.Debug.LogError$1(message);
                    }
                },
                /*MyDebug.LogError:static end.*/

                /*MyDebug.LogError$1:static start.*/
                LogError$1: function (message, context) {
if ( TRACE ) { TRACE( "MyDebug#LogError$1", this ); }

                    if (MyDebug.canLog) {
                        UnityEngine.Debug.LogError$1(message, context);
                    }
                },
                /*MyDebug.LogError$1:static end.*/

                /*MyDebug.LogWarning$1:static start.*/
                LogWarning$1: function (message, context) {
if ( TRACE ) { TRACE( "MyDebug#LogWarning$1", this ); }

                    if (MyDebug.canLog) {
                        UnityEngine.Debug.LogWarning(message, context);
                    }
                },
                /*MyDebug.LogWarning$1:static end.*/

                /*MyDebug.LogWarning:static start.*/
                LogWarning: function (message) {
if ( TRACE ) { TRACE( "MyDebug#LogWarning", this ); }

                    if (MyDebug.canLog) {
                        UnityEngine.Debug.LogWarning(message);
                    }
                },
                /*MyDebug.LogWarning:static end.*/


            }
        }
    });
    /*MyDebug end.*/

    /*PopupPanel start.*/
    Bridge.define("PopupPanel", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            panel: null,
            conffeti: null,
            adjustCamera: false,
            dailySpinPanel: false,
            lastCamOrthoSize: 0,
            entranceTime: 0,
            scaleY: 0,
            closeable: false,
            closed: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "PopupPanel#init", this ); }

                this.adjustCamera = false;
                this.dailySpinPanel = false;
                this.entranceTime = 0.3;
                this.scaleY = 1;
                this.closeable = false;
                this.closed = false;
            }
        },
        methods: {
            /*PopupPanel.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "PopupPanel#OnEnable", this ); }

                if (!this.dailySpinPanel) {
                    !Bridge.staticEquals(IdleActions.OnSwitchConditionToRaiseMoneyMonster, null) ? IdleActions.OnSwitchConditionToRaiseMoneyMonster(false) : null;
                }
                this.InitEffect();

                this.closeable = false;
                this.closed = false;

                this.Invoke("CanTurnOff", 0.6);
            },
            /*PopupPanel.OnEnable end.*/

            /*PopupPanel.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "PopupPanel#OnDisable", this ); }

                if (!this.dailySpinPanel) {
                    !Bridge.staticEquals(IdleActions.OnSwitchConditionToRaiseMoneyMonster, null) ? IdleActions.OnSwitchConditionToRaiseMoneyMonster(true) : null;
                }
            },
            /*PopupPanel.OnDisable end.*/

            /*PopupPanel.CanTurnOff start.*/
            CanTurnOff: function () {
if ( TRACE ) { TRACE( "PopupPanel#CanTurnOff", this ); }

                this.closeable = true;
            },
            /*PopupPanel.CanTurnOff end.*/

            /*PopupPanel.SetText start.*/
            SetText: function (msg) {
if ( TRACE ) { TRACE( "PopupPanel#SetText", this ); }

                if (msg === void 0) { msg = ""; }

            },
            /*PopupPanel.SetText end.*/

            /*PopupPanel.InitEffect start.*/
            InitEffect: function () {
if ( TRACE ) { TRACE( "PopupPanel#InitEffect", this ); }

                EventDispatcherExtension.PostEvent$1(this, EventID.OnTurnOffInteractNativeAd, Bridge.box(false, System.Boolean, System.Boolean.toString));
                this.EntranceAnim();

                this.SetText();

                if (UnityEngine.Component.op_Equality(this.conffeti, null)) {
                    return;
                }
                SoundManager.Instance.PlaySFX(Sound.winSFX, 1.0);
                if (this.adjustCamera) {
                    this.lastCamOrthoSize = UnityEngine.Camera.main.orthographicSize;
                    CameraHandler.Instance.CameraForConfetti(6.5);
                }
            },
            /*PopupPanel.InitEffect end.*/

            /*PopupPanel.EntranceAnim start.*/
            EntranceAnim: function () {
if ( TRACE ) { TRACE( "PopupPanel#EntranceAnim", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.panel);
                DG.Tweening.ShortcutExtensions.DOScaleY(this.panel, 0.5, 0);
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleY(this.panel, this.scaleY, this.entranceTime), DG.Tweening.Ease.OutBack);
            },
            /*PopupPanel.EntranceAnim end.*/

            /*PopupPanel.OnExit start.*/
            OnExit: function () {
if ( TRACE ) { TRACE( "PopupPanel#OnExit", this ); }

                if (!this.closeable || this.closed) {
                    return;
                }
                if (this.adjustCamera) {
                    CameraHandler.Instance.CameraForConfetti(this.lastCamOrthoSize);
                }
                EventDispatcherExtension.PostEvent$1(this, EventID.OnTurnOffInteractNativeAd, Bridge.box(true, System.Boolean, System.Boolean.toString));
                this.closed = true;

                DG.Tweening.ShortcutExtensions.DOKill(this.panel);
                DG.Tweening.ShortcutExtensions.DOScaleY(this.panel, this.scaleY, 0);
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleY(this.panel, 0.5, 0.2), DG.Tweening.Ease.InBack), Bridge.fn.bind(this, function () {
                    this.gameObject.SetActive(false);
                }));
            },
            /*PopupPanel.OnExit end.*/


        }
    });
    /*PopupPanel end.*/

    /*PrefInfo start.*/
    Bridge.define("PrefInfo", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                CurrentDailyIndexStr: null,
                CurrentDailyIndexAdStr: null,
                DayClaimed: null,
                Complete7DayStr: null,
                LastDayLoginStr: null,
                LastDayLoginAdStr: null
            },
            props: {
                GetProgress: {
                    get: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetProgress#get", this ); }

                        return UnityEngine.PlayerPrefs.GetInt("progress", 0);
                    }
                },
                GetTier: {
                    get: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetTier#get", this ); }

                        return UnityEngine.PlayerPrefs.GetInt("tier", 0);
                    }
                },
                GetKeyOwned: {
                    get: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetKeyOwned#get", this ); }

                        return UnityEngine.PlayerPrefs.GetInt("KeyOwn", 0);
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "PrefInfo#init", this ); }

                    this.CurrentDailyIndexStr = "CurrentDailyIndex";
                    this.CurrentDailyIndexAdStr = "CurrentDailyIndexAd";
                    this.DayClaimed = "DayClaimed";
                    this.Complete7DayStr = "Complete7Day";
                    this.LastDayLoginStr = "LastDayLogin";
                    this.LastDayLoginAdStr = "LastDayLoginAd";
                }
            },
            methods: {
                /*PrefInfo.SetSubState:static start.*/
                SetSubState: function (purchased) {
if ( TRACE ) { TRACE( "PrefInfo#SetSubState", this ); }

                    UnityEngine.PlayerPrefs.SetInt("IsSub", purchased ? 1 : 0);
                },
                /*PrefInfo.SetSubState:static end.*/

                /*PrefInfo.IsSub:static start.*/
                IsSub: function () {
if ( TRACE ) { TRACE( "PrefInfo#IsSub", this ); }

                    return UnityEngine.PlayerPrefs.GetInt("IsSub", 0) === 1 ? true : false;
                },
                /*PrefInfo.IsSub:static end.*/

                /*PrefInfo.GetLastSpinTime:static start.*/
                GetLastSpinTime: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetLastSpinTime", this ); }

                    if (!UnityEngine.PlayerPrefs.HasKey("LastSpinTime")) {
                        PrefInfo.SetLastSpinTime(System.DateTime.addDays(System.DateTime.getNow(), -1));
                    }
                    return System.DateTime.parse(UnityEngine.PlayerPrefs.GetString("LastSpinTime"));
                },
                /*PrefInfo.GetLastSpinTime:static end.*/

                /*PrefInfo.SetLastSpinTime:static start.*/
                SetLastSpinTime: function (time) {
if ( TRACE ) { TRACE( "PrefInfo#SetLastSpinTime", this ); }

                    UnityEngine.PlayerPrefs.SetString("LastSpinTime", System.DateTime.format(time));
                },
                /*PrefInfo.SetLastSpinTime:static end.*/

                /*PrefInfo.GetLastAdInChallenge:static start.*/
                GetLastAdInChallenge: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetLastAdInChallenge", this ); }

                    if (!UnityEngine.PlayerPrefs.HasKey("LastAdChallenge")) {
                        PrefInfo.SetLastAdInChallenge(System.DateTime.addDays(System.DateTime.getNow(), -1));
                    }
                    return System.DateTime.parse(UnityEngine.PlayerPrefs.GetString("LastAdChallenge"));
                },
                /*PrefInfo.GetLastAdInChallenge:static end.*/

                /*PrefInfo.SetLastAdInChallenge:static start.*/
                SetLastAdInChallenge: function (time) {
if ( TRACE ) { TRACE( "PrefInfo#SetLastAdInChallenge", this ); }

                    UnityEngine.PlayerPrefs.SetString("LastAdChallenge", System.DateTime.format(time));
                },
                /*PrefInfo.SetLastAdInChallenge:static end.*/

                /*PrefInfo.SetTotalExtraLife:static start.*/
                SetTotalExtraLife: function (total) {
if ( TRACE ) { TRACE( "PrefInfo#SetTotalExtraLife", this ); }

                    UnityEngine.PlayerPrefs.SetInt("TotalExtraLife", total);
                },
                /*PrefInfo.SetTotalExtraLife:static end.*/

                /*PrefInfo.TotalExtraLife:static start.*/
                TotalExtraLife: function () {
if ( TRACE ) { TRACE( "PrefInfo#TotalExtraLife", this ); }

                    return UnityEngine.PlayerPrefs.GetInt("TotalExtraLife", 5);
                },
                /*PrefInfo.TotalExtraLife:static end.*/

                /*PrefInfo.Distance:static start.*/
                Distance: function (a, b) {
if ( TRACE ) { TRACE( "PrefInfo#Distance", this ); }

                    return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
                },
                /*PrefInfo.Distance:static end.*/

                /*PrefInfo.GetLastDieTime:static start.*/
                GetLastDieTime: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetLastDieTime", this ); }

                    return System.DateTime.parse(UnityEngine.PlayerPrefs.GetString("LastDieTime", System.DateTime.format(System.DateTime.getNow())));
                },
                /*PrefInfo.GetLastDieTime:static end.*/

                /*PrefInfo.SetLastDieTime:static start.*/
                SetLastDieTime: function (time) {
if ( TRACE ) { TRACE( "PrefInfo#SetLastDieTime", this ); }

                    UnityEngine.PlayerPrefs.SetString("LastDieTime", System.DateTime.format(time));
                },
                /*PrefInfo.SetLastDieTime:static end.*/

                /*PrefInfo.GetPlayTime:static start.*/
                GetPlayTime: function (id) {
if ( TRACE ) { TRACE( "PrefInfo#GetPlayTime", this ); }

                    if (id === void 0) { id = ""; }
                    return UnityEngine.PlayerPrefs.GetInt("PlayTime" + (id || ""), 0);
                },
                /*PrefInfo.GetPlayTime:static end.*/

                /*PrefInfo.SetPlayTime:static start.*/
                SetPlayTime: function (c, id) {
if ( TRACE ) { TRACE( "PrefInfo#SetPlayTime", this ); }

                    if (id === void 0) { id = ""; }
                    UnityEngine.PlayerPrefs.SetInt("PlayTime" + (id || ""), c);
                },
                /*PrefInfo.SetPlayTime:static end.*/

                /*PrefInfo.IncreasePlayTime:static start.*/
                IncreasePlayTime: function (am, id) {
if ( TRACE ) { TRACE( "PrefInfo#IncreasePlayTime", this ); }

                    if (id === void 0) { id = ""; }
                    UnityEngine.PlayerPrefs.SetInt("PlayTime" + (id || ""), ((PrefInfo.GetPlayTime(id) + am) | 0));
                },
                /*PrefInfo.IncreasePlayTime:static end.*/

                /*PrefInfo.GetIQ:static start.*/
                GetIQ: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetIQ", this ); }

                    return UnityEngine.PlayerPrefs.GetFloat("IQ", 85);
                },
                /*PrefInfo.GetIQ:static end.*/

                /*PrefInfo.SetIQ:static start.*/
                SetIQ: function (c) {
if ( TRACE ) { TRACE( "PrefInfo#SetIQ", this ); }

                    UnityEngine.PlayerPrefs.SetFloat("IQ", c);
                },
                /*PrefInfo.SetIQ:static end.*/

                /*PrefInfo.GetHeart:static start.*/
                GetHeart: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetHeart", this ); }

                    if (PrefInfo.IsUnlimited()) {
                        return PrefInfo.TotalExtraLife();
                    }
                    return UnityEngine.Mathf.Max(0, UnityEngine.PlayerPrefs.GetInt("Heart", PrefInfo.TotalExtraLife()));
                },
                /*PrefInfo.GetHeart:static end.*/

                /*PrefInfo.SetHeart:static start.*/
                SetHeart: function (c) {
if ( TRACE ) { TRACE( "PrefInfo#SetHeart", this ); }

                    UnityEngine.PlayerPrefs.SetInt("Heart", c);
                },
                /*PrefInfo.SetHeart:static end.*/

                /*PrefInfo.GetSpin:static start.*/
                GetSpin: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetSpin", this ); }

                    return UnityEngine.PlayerPrefs.GetInt("Spin", 0);
                },
                /*PrefInfo.GetSpin:static end.*/

                /*PrefInfo.SetSpin:static start.*/
                SetSpin: function (c) {
if ( TRACE ) { TRACE( "PrefInfo#SetSpin", this ); }

                    UnityEngine.PlayerPrefs.SetInt("Spin", c);
                },
                /*PrefInfo.SetSpin:static end.*/

                /*PrefInfo.GetGem:static start.*/
                GetGem: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetGem", this ); }

                    return UnityEngine.PlayerPrefs.GetInt("Gem", 0);
                },
                /*PrefInfo.GetGem:static end.*/

                /*PrefInfo.SetGem:static start.*/
                SetGem: function (c) {
if ( TRACE ) { TRACE( "PrefInfo#SetGem", this ); }

                    UnityEngine.PlayerPrefs.SetInt("Gem", c);
                },
                /*PrefInfo.SetGem:static end.*/

                /*PrefInfo.AddGem:static start.*/
                AddGem: function (c) {
if ( TRACE ) { TRACE( "PrefInfo#AddGem", this ); }

                    UnityEngine.PlayerPrefs.SetInt("Gem", ((PrefInfo.GetGem() + c) | 0));
                },
                /*PrefInfo.AddGem:static end.*/

                /*PrefInfo.GetItemStatus:static start.*/
                GetItemStatus: function (id) {
if ( TRACE ) { TRACE( "PrefInfo#GetItemStatus", this ); }

                    if (id === 0) {
                        return true;
                    }
                    return UnityEngine.PlayerPrefs.GetInt("Equipment_" + id, 0) !== 0;
                },
                /*PrefInfo.GetItemStatus:static end.*/

                /*PrefInfo.SetItemStatus:static start.*/
                SetItemStatus: function (id, status) {
if ( TRACE ) { TRACE( "PrefInfo#SetItemStatus", this ); }

                    if (status === void 0) { status = true; }
                    UnityEngine.PlayerPrefs.SetInt("Equipment_" + id, status ? 1 : 0);
                },
                /*PrefInfo.SetItemStatus:static end.*/

                /*PrefInfo.GetName:static start.*/
                GetName: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetName", this ); }

                    return UnityEngine.PlayerPrefs.GetString("PlayerName", "You");
                },
                /*PrefInfo.GetName:static end.*/

                /*PrefInfo.SetName:static start.*/
                SetName: function (name) {
if ( TRACE ) { TRACE( "PrefInfo#SetName", this ); }

                    UnityEngine.PlayerPrefs.SetString("PlayerName", name);
                },
                /*PrefInfo.SetName:static end.*/

                /*PrefInfo.IsUnlimited:static start.*/
                IsUnlimited: function () {
if ( TRACE ) { TRACE( "PrefInfo#IsUnlimited", this ); }

                    return UnityEngine.PlayerPrefs.GetInt("UnlimitedHeart", 0) === 1;
                },
                /*PrefInfo.IsUnlimited:static end.*/

                /*PrefInfo.SetUnlimited:static start.*/
                SetUnlimited: function (active) {
if ( TRACE ) { TRACE( "PrefInfo#SetUnlimited", this ); }

                    if (active === void 0) { active = false; }
                    UnityEngine.PlayerPrefs.SetInt("UnlimitedHeart", active ? 1 : 0);
                },
                /*PrefInfo.SetUnlimited:static end.*/

                /*PrefInfo.IsUsingAd:static start.*/
                IsUsingAd: function () {
if ( TRACE ) { TRACE( "PrefInfo#IsUsingAd", this ); }

                    return UnityEngine.PlayerPrefs.GetInt("AdEnabled", 1) === 1 && !PrefInfo.IsSub();
                },
                /*PrefInfo.IsUsingAd:static end.*/

                /*PrefInfo.SetAd:static start.*/
                SetAd: function (active) {
if ( TRACE ) { TRACE( "PrefInfo#SetAd", this ); }

                    if (active === void 0) { active = false; }
                    UnityEngine.PlayerPrefs.SetInt("AdEnabled", active ? 1 : 0);
                },
                /*PrefInfo.SetAd:static end.*/

                /*PrefInfo.GetSensitivity:static start.*/
                GetSensitivity: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetSensitivity", this ); }

                    return UnityEngine.PlayerPrefs.GetFloat("Sensitivity", 0.5);
                },
                /*PrefInfo.GetSensitivity:static end.*/

                /*PrefInfo.SetSensitivity:static start.*/
                SetSensitivity: function (total) {
if ( TRACE ) { TRACE( "PrefInfo#SetSensitivity", this ); }

                    UnityEngine.PlayerPrefs.SetFloat("Sensitivity", total);
                },
                /*PrefInfo.SetSensitivity:static end.*/

                /*PrefInfo.GetCurrentSkin:static start.*/
                GetCurrentSkin: function (type) {
if ( TRACE ) { TRACE( "PrefInfo#GetCurrentSkin", this ); }


                    return UnityEngine.PlayerPrefs.GetInt("Skin" + type, 0);
                },
                /*PrefInfo.GetCurrentSkin:static end.*/

                /*PrefInfo.SetCurrentSkin:static start.*/
                SetCurrentSkin: function (c, type) {
if ( TRACE ) { TRACE( "PrefInfo#SetCurrentSkin", this ); }

                    UnityEngine.PlayerPrefs.SetInt("Skin" + type, c);
                },
                /*PrefInfo.SetCurrentSkin:static end.*/

                /*PrefInfo.GetCoin:static start.*/
                GetCoin: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetCoin", this ); }

                    return UnityEngine.PlayerPrefs.GetInt("Coin", 0);
                },
                /*PrefInfo.GetCoin:static end.*/

                /*PrefInfo.SetCoin:static start.*/
                SetCoin: function (total) {
if ( TRACE ) { TRACE( "PrefInfo#SetCoin", this ); }

                    UnityEngine.PlayerPrefs.SetInt("Coin", total);
                },
                /*PrefInfo.SetCoin:static end.*/

                /*PrefInfo.AddCoin:static start.*/
                AddCoin: function (total) {
if ( TRACE ) { TRACE( "PrefInfo#AddCoin", this ); }

                    UnityEngine.PlayerPrefs.SetInt("Coin", ((PrefInfo.GetCoin() + total) | 0));
                },
                /*PrefInfo.AddCoin:static end.*/

                /*PrefInfo.IsUnlocked:static start.*/
                IsUnlocked: function (id, type) {
if ( TRACE ) { TRACE( "PrefInfo#IsUnlocked", this ); }

                    if ((id === 0 && type === 0)) {
                        return true;
                    }
                    return UnityEngine.PlayerPrefs.GetInt("Lock_" + type + "_" + id, 0) === 0 ? false : true;
                },
                /*PrefInfo.IsUnlocked:static end.*/

                /*PrefInfo.SetUnlocked:static start.*/
                SetUnlocked: function (id, active, type) {
if ( TRACE ) { TRACE( "PrefInfo#SetUnlocked", this ); }

                    UnityEngine.PlayerPrefs.SetInt("Lock_" + type + "_" + id, active ? 1 : 0);
                    //FireBaseManager.Instance.LogEvent("CHARACTER_UNLOCK_" + (id + 1));
                },
                /*PrefInfo.SetUnlocked:static end.*/

                /*PrefInfo.SetHint:static start.*/
                SetHint: function (currenHint) {
if ( TRACE ) { TRACE( "PrefInfo#SetHint", this ); }

                    UnityEngine.PlayerPrefs.SetInt("Hint", currenHint);
                },
                /*PrefInfo.SetHint:static end.*/

                /*PrefInfo.TotalHint:static start.*/
                TotalHint: function () {
if ( TRACE ) { TRACE( "PrefInfo#TotalHint", this ); }

                    return UnityEngine.PlayerPrefs.GetInt("Hint", 1);
                },
                /*PrefInfo.TotalHint:static end.*/

                /*PrefInfo.SetCurrentDailyGiftIndex:static start.*/
                SetCurrentDailyGiftIndex: function () {
if ( TRACE ) { TRACE( "PrefInfo#SetCurrentDailyGiftIndex", this ); }

                    UnityEngine.PlayerPrefs.SetInt(PrefInfo.CurrentDailyIndexStr, ((PrefInfo.CurrentDailyIndex() + 1) | 0));
                    if (PrefInfo.CurrentDailyIndex() > 6) {
                        if (PrefInfo.Complete7Day() === false) {
                            PrefInfo.SetComplete7Day();

                        }
                        UnityEngine.PlayerPrefs.SetInt(PrefInfo.CurrentDailyIndexStr, 0);
                    }
                    PrefInfo.SetDayClaimed();
                },
                /*PrefInfo.SetCurrentDailyGiftIndex:static end.*/

                /*PrefInfo.SetCurrentDailyGiftIndexAd:static start.*/
                SetCurrentDailyGiftIndexAd: function () {
if ( TRACE ) { TRACE( "PrefInfo#SetCurrentDailyGiftIndexAd", this ); }

                    UnityEngine.PlayerPrefs.SetInt(PrefInfo.CurrentDailyIndexAdStr, 1);
                    //if (CurrentDailyIndex() > 6)
                    //{
                    //    if (Complete7Day() == false)
                    //    {
                    //        SetComplete7Day();

                    //    }
                    //    PlayerPrefs.SetInt(CurrentDailyIndexStr, 0);
                    //}
                    //SetDayClaimed();
                },
                /*PrefInfo.SetCurrentDailyGiftIndexAd:static end.*/

                /*PrefInfo.GetDayClaim:static start.*/
                GetDayClaim: function () {
if ( TRACE ) { TRACE( "PrefInfo#GetDayClaim", this ); }

                    return UnityEngine.PlayerPrefs.GetInt(PrefInfo.DayClaimed, 0);
                },
                /*PrefInfo.GetDayClaim:static end.*/

                /*PrefInfo.SetDayClaimed:static start.*/
                SetDayClaimed: function () {
if ( TRACE ) { TRACE( "PrefInfo#SetDayClaimed", this ); }

                    UnityEngine.PlayerPrefs.SetInt(PrefInfo.DayClaimed, ((PrefInfo.GetDayClaim() + 1) | 0));
                },
                /*PrefInfo.SetDayClaimed:static end.*/

                /*PrefInfo.CurrentDailyIndex:static start.*/
                CurrentDailyIndex: function () {
if ( TRACE ) { TRACE( "PrefInfo#CurrentDailyIndex", this ); }

                    return UnityEngine.PlayerPrefs.GetInt(PrefInfo.CurrentDailyIndexStr);
                },
                /*PrefInfo.CurrentDailyIndex:static end.*/

                /*PrefInfo.CurrentDailyIndexAd:static start.*/
                CurrentDailyIndexAd: function () {
if ( TRACE ) { TRACE( "PrefInfo#CurrentDailyIndexAd", this ); }

                    return UnityEngine.PlayerPrefs.GetInt(PrefInfo.CurrentDailyIndexAdStr);
                },
                /*PrefInfo.CurrentDailyIndexAd:static end.*/

                /*PrefInfo.Complete7Day:static start.*/
                Complete7Day: function () {
if ( TRACE ) { TRACE( "PrefInfo#Complete7Day", this ); }

                    return UnityEngine.PlayerPrefs.GetInt(PrefInfo.Complete7DayStr, 0) === 0 ? false : true;
                },
                /*PrefInfo.Complete7Day:static end.*/

                /*PrefInfo.SetComplete7Day:static start.*/
                SetComplete7Day: function () {
if ( TRACE ) { TRACE( "PrefInfo#SetComplete7Day", this ); }

                    UnityEngine.PlayerPrefs.SetInt(PrefInfo.Complete7DayStr, 1);
                },
                /*PrefInfo.SetComplete7Day:static end.*/

                /*PrefInfo.SaveTimeLastLogin:static start.*/
                SaveTimeLastLogin: function (time) {
if ( TRACE ) { TRACE( "PrefInfo#SaveTimeLastLogin", this ); }

                    UnityEngine.PlayerPrefs.SetString(PrefInfo.LastDayLoginStr, time);
                },
                /*PrefInfo.SaveTimeLastLogin:static end.*/

                /*PrefInfo.SaveTimeLastLoginAd:static start.*/
                SaveTimeLastLoginAd: function (time) {
if ( TRACE ) { TRACE( "PrefInfo#SaveTimeLastLoginAd", this ); }

                    UnityEngine.PlayerPrefs.SetString(PrefInfo.LastDayLoginAdStr, time);
                },
                /*PrefInfo.SaveTimeLastLoginAd:static end.*/

                /*PrefInfo.TimeLastDayLogin:static start.*/
                TimeLastDayLogin: function () {
if ( TRACE ) { TRACE( "PrefInfo#TimeLastDayLogin", this ); }

                    return UnityEngine.PlayerPrefs.GetString(PrefInfo.LastDayLoginStr);
                },
                /*PrefInfo.TimeLastDayLogin:static end.*/

                /*PrefInfo.TimeLastDayLoginAd:static start.*/
                TimeLastDayLoginAd: function () {
if ( TRACE ) { TRACE( "PrefInfo#TimeLastDayLoginAd", this ); }

                    return UnityEngine.PlayerPrefs.GetString(PrefInfo.LastDayLoginAdStr);
                },
                /*PrefInfo.TimeLastDayLoginAd:static end.*/

                /*PrefInfo.SetProgress:static start.*/
                SetProgress: function (progress) {
if ( TRACE ) { TRACE( "PrefInfo#SetProgress", this ); }

                    UnityEngine.PlayerPrefs.SetInt("progress", progress);
                },
                /*PrefInfo.SetProgress:static end.*/

                /*PrefInfo.SetTier:static start.*/
                SetTier: function (tier) {
if ( TRACE ) { TRACE( "PrefInfo#SetTier", this ); }

                    UnityEngine.PlayerPrefs.SetInt("tier", tier);
                },
                /*PrefInfo.SetTier:static end.*/

                /*PrefInfo.SetKeyOwned:static start.*/
                SetKeyOwned: function (key) {
if ( TRACE ) { TRACE( "PrefInfo#SetKeyOwned", this ); }

                    UnityEngine.PlayerPrefs.SetInt("KeyOwn", key);
                },
                /*PrefInfo.SetKeyOwned:static end.*/

                /*PrefInfo.AddKey:static start.*/
                AddKey: function (amout) {
if ( TRACE ) { TRACE( "PrefInfo#AddKey", this ); }

                    UnityEngine.PlayerPrefs.SetInt("KeyOwn", ((PrefInfo.GetKeyOwned + amout) | 0));
                },
                /*PrefInfo.AddKey:static end.*/


            }
        }
    });
    /*PrefInfo end.*/

    /*Priority start.*/
    Bridge.define("Priority", {
        $kind: 6,
        statics: {
            fields: {
                Low: 0,
                High: 1,
                SeasonReward: 2
            }
        }
    });
    /*Priority end.*/

    /*Scale start.*/
    Bridge.define("Scale", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*Scale.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Scale#OnEnable", this ); }

                this.transform.localScale = pc.Vec3.ZERO.clone();
            },
            /*Scale.OnEnable end.*/

            /*Scale.OnEnter start.*/
            OnEnter: function () {
if ( TRACE ) { TRACE( "Scale#OnEnter", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                DG.Tweening.ShortcutExtensions.DOScale(this.transform, 0, 0);
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale(this.transform, 1, 0.2), DG.Tweening.Ease.InOutSine);
                this.transform.localScale = new pc.Vec3( 1, 1, 1 );
            },
            /*Scale.OnEnter end.*/

            /*Scale.OnExit start.*/
            OnExit: function () {
if ( TRACE ) { TRACE( "Scale#OnExit", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale(this.transform, 0, 0.2), DG.Tweening.Ease.InOutSine);
            },
            /*Scale.OnExit end.*/


        }
    });
    /*Scale end.*/

    /*SfxController start.*/
    Bridge.define("SfxController", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                SOUND: null,
                VIBRATE: null,
                FIRST_PLAY: null,
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "SfxController#init", this ); }

                    this.SOUND = "Sound";
                    this.VIBRATE = "Vibrate";
                    this.FIRST_PLAY = "FirstPlaySFX";
                }
            }
        },
        fields: {
            soundOn: null,
            soundOff: null,
            vibrateOn: null,
            vibrateOff: null,
            sound: null,
            vibrate: null,
            soundImg: null,
            vibrateImg: null,
            soundState: 0,
            vibrateState: 0
        },
        methods: {
            /*SfxController.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "SfxController#Awake", this ); }

                SfxController.Instance = this;
            },
            /*SfxController.Awake end.*/

            /*SfxController.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "SfxController#OnEnable", this ); }

                this.UpdateSFXUI();
            },
            /*SfxController.OnEnable end.*/

            /*SfxController.UpdateSFXUI start.*/
            UpdateSFXUI: function () {
if ( TRACE ) { TRACE( "SfxController#UpdateSFXUI", this ); }

                if (UnityEngine.PlayerPrefs.GetInt(SfxController.FIRST_PLAY) === 0) {
                    UnityEngine.PlayerPrefs.SetInt(SfxController.FIRST_PLAY, 1);
                    UnityEngine.PlayerPrefs.SetInt(SfxController.SOUND, 1);
                    UnityEngine.PlayerPrefs.SetInt(SfxController.VIBRATE, 1);
                }
                this.soundState = UnityEngine.PlayerPrefs.GetInt(SfxController.SOUND);
                this.vibrateState = UnityEngine.PlayerPrefs.GetInt(SfxController.VIBRATE);
                this.ChangeIcon();
            },
            /*SfxController.UpdateSFXUI end.*/

            /*SfxController.SwitchSoundState start.*/
            SwitchSoundState: function () {
if ( TRACE ) { TRACE( "SfxController#SwitchSoundState", this ); }

                this.soundState = (1 - this.soundState) | 0;
                UnityEngine.PlayerPrefs.SetInt(SfxController.SOUND, this.soundState);
                if (this.soundState === 1) {
                    this.PlayTapSound();
                    SoundManager.Instance.PlaySound(Sound.bg2);
                } else {
                    SoundManager.Instance.PauseSound(Sound.bg2, true);
                }
                this.ChangeIcon();
            },
            /*SfxController.SwitchSoundState end.*/

            /*SfxController.SwitchVibrationState start.*/
            SwitchVibrationState: function () {
if ( TRACE ) { TRACE( "SfxController#SwitchVibrationState", this ); }

                this.vibrateState = (1 - this.vibrateState) | 0;
                UnityEngine.PlayerPrefs.SetInt(SfxController.VIBRATE, this.vibrateState);
                this.ChangeIcon();
            },
            /*SfxController.SwitchVibrationState end.*/

            /*SfxController.ChangeIcon start.*/
            ChangeIcon: function () {
if ( TRACE ) { TRACE( "SfxController#ChangeIcon", this ); }

                if (this.soundState === 1) {
                    this.soundImg = this.soundOn;
                } else {
                    this.soundImg = this.soundOff;
                }
                if (this.vibrateState === 1) {
                    this.vibrateImg = this.vibrateOn;
                } else {
                    this.vibrateImg = this.vibrateOff;
                }

                for (var i = 0; i < this.sound.Count; i = (i + 1) | 0) {
                    this.sound.getItem(i).sprite = this.soundImg;
                    this.vibrate.getItem(i).sprite = this.vibrateImg;
                }
            },
            /*SfxController.ChangeIcon end.*/

            /*SfxController.PlayTapSound start.*/
            PlayTapSound: function () {
if ( TRACE ) { TRACE( "SfxController#PlayTapSound", this ); }

                SoundManager.Instance.PlaySound(Sound.done);
            },
            /*SfxController.PlayTapSound end.*/

            /*SfxController.PlayPopupSound start.*/
            PlayPopupSound: function () {
if ( TRACE ) { TRACE( "SfxController#PlayPopupSound", this ); }

                SoundManager.Instance.PlaySound(Sound.popup);
            },
            /*SfxController.PlayPopupSound end.*/

            /*SfxController.PlayBoosterSound2 start.*/
            PlayBoosterSound2: function () {
if ( TRACE ) { TRACE( "SfxController#PlayBoosterSound2", this ); }

                SoundManager.Instance.PlaySound(Sound.rocket);
            },
            /*SfxController.PlayBoosterSound2 end.*/

            /*SfxController.PauseBoosterSound start.*/
            PauseBoosterSound: function () {
if ( TRACE ) { TRACE( "SfxController#PauseBoosterSound", this ); }

                SoundManager.Instance.PauseSound(Sound.rocket);
            },
            /*SfxController.PauseBoosterSound end.*/

            /*SfxController.PlayCashSound start.*/
            PlayCashSound: function () {
if ( TRACE ) { TRACE( "SfxController#PlayCashSound", this ); }

                SoundManager.Instance.PlaySound(Sound.cash);
            },
            /*SfxController.PlayCashSound end.*/

            /*SfxController.Vibrate start.*/
            Vibrate: function () {
if ( TRACE ) { TRACE( "SfxController#Vibrate", this ); }

                //if (vibrateState == 1) MMVibrationManager.Haptic(HapticTypes.Success, true, true);
            },
            /*SfxController.Vibrate end.*/


        }
    });
    /*SfxController end.*/

    /*ShopController start.*/
    Bridge.define("ShopController", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            bodyPart: 0,
            heads: null,
            eyes: null,
            mouths: null,
            accs: null,
            bodies: null,
            headContent: null,
            eyeContent: null,
            mouthContent: null,
            accContents: null,
            bodyContent: null,
            head: null,
            eye: null,
            mouth: null,
            acc: null,
            body: null,
            body2: null,
            headHolder: null,
            boneFollower: null,
            boneFollower2: null,
            handTut: null,
            characterManager: null,
            currentHead: null,
            currentEye: null,
            currentMouth: null,
            currentAcc: null,
            currentBody: null,
            head_img: null,
            eye_img: null,
            mouth_img: null,
            acc_img: null,
            bodyAnim: null,
            bodyAnim2: null,
            eyeController: null,
            mouthController: null,
            accController: null,
            isPickHead: false,
            isPickEye: false,
            isPickMouth: false,
            isPickAcc: false,
            isPickBody: false,
            eyePos: null,
            mouthPos: null,
            idEye: 0,
            idMouth: 0,
            idAcc: 0
        },
        props: {
            IsPickBody: {
                get: function () {
if ( TRACE ) { TRACE( "ShopController#IsPickBody#get", this ); }

                    return this.isPickBody;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "ShopController#IsPickBody#set", this ); }

                    this.isPickBody = value;
                }
            },
            Bodies: {
                get: function () {
if ( TRACE ) { TRACE( "ShopController#Bodies#get", this ); }

                    return this.bodies;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "ShopController#Bodies#set", this ); }

                    this.bodies = value;
                }
            },
            CurrentHead: {
                get: function () {
if ( TRACE ) { TRACE( "ShopController#CurrentHead#get", this ); }

                    return this.currentHead;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "ShopController#CurrentHead#set", this ); }

                    this.currentHead = value;
                }
            },
            CurrentEye: {
                get: function () {
if ( TRACE ) { TRACE( "ShopController#CurrentEye#get", this ); }

                    return this.currentEye;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "ShopController#CurrentEye#set", this ); }

                    this.currentEye = value;
                }
            },
            CurrentMouth: {
                get: function () {
if ( TRACE ) { TRACE( "ShopController#CurrentMouth#get", this ); }

                    return this.currentMouth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "ShopController#CurrentMouth#set", this ); }

                    this.currentMouth = value;
                }
            },
            CurrentAcc: {
                get: function () {
if ( TRACE ) { TRACE( "ShopController#CurrentAcc#get", this ); }

                    return this.currentAcc;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "ShopController#CurrentAcc#set", this ); }

                    this.currentAcc = value;
                }
            },
            CurrentBody: {
                get: function () {
if ( TRACE ) { TRACE( "ShopController#CurrentBody#get", this ); }

                    return this.currentBody;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "ShopController#CurrentBody#set", this ); }

                    this.currentBody = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ShopController#init", this ); }

                this.eyePos = new UnityEngine.Vector3();
                this.mouthPos = new UnityEngine.Vector3();
                this.isPickHead = false;
                this.isPickEye = false;
                this.isPickMouth = false;
                this.isPickAcc = false;
                this.isPickBody = false;
                this.eyePos = new pc.Vec3( 0, 0.7, 0 );
                this.mouthPos = new pc.Vec3( 0, -1.0, 0 );
            }
        },
        methods: {
            /*ShopController.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ShopController#Awake", this ); }

                ShopController.Instance = this;
                this.GetReference();
            },
            /*ShopController.Awake end.*/

            /*ShopController.GetReference start.*/
            GetReference: function () {
if ( TRACE ) { TRACE( "ShopController#GetReference", this ); }

                //neu loi game thi get reference nay o ham InitReferences
                this.head_img = this.head.GetComponent(UnityEngine.SpriteRenderer);
                this.eye_img = this.eye.GetComponent(UnityEngine.SpriteRenderer);
                this.mouth_img = this.mouth.GetComponent(UnityEngine.SpriteRenderer);
                this.acc_img = this.acc.GetComponent(UnityEngine.SpriteRenderer);

                this.eyeController = this.eye.GetComponent(TouchController);
                this.mouthController = this.mouth.GetComponent(TouchController);
                this.accController = this.acc.GetComponent(TouchController);

                this.bodyAnim = this.body.GetComponent(Spine.Unity.SkeletonAnimation);
                this.bodyAnim2 = this.body2.GetComponent(Spine.Unity.SkeletonAnimation);
            },
            /*ShopController.GetReference end.*/

            /*ShopController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ShopController#Start", this ); }

                this.InitItems(this.heads, this.headContent, 0);
                this.InitItems(this.eyes, this.eyeContent, 2);
                this.InitItems(this.mouths, this.mouthContent, 2);
                this.InitItems(this.accs, this.accContents, 2);
                this.InitItems(this.bodies, this.bodyContent, 0);

                EventDispatcherExtension.RegisterListener(this, EventID.OnClick, Bridge.fn.bind(this, function (param) {
                    this.OnClickItem(System.Nullable.getValue(Bridge.cast(Bridge.unbox(param, System.Int32), System.Int32)));
                }));
            },
            /*ShopController.Start end.*/

            /*ShopController.CheckNextStep start.*/
            CheckNextStep: function (id) {
if ( TRACE ) { TRACE( "ShopController#CheckNextStep", this ); }

                switch (id) {
                    case BodyPart.Head: 
                        return this.isPickHead;
                    case BodyPart.Eye: 
                        return this.isPickEye;
                    case BodyPart.Mouth: 
                        return this.isPickMouth;
                    case BodyPart.Acc: 
                        return this.isPickAcc;
                    case BodyPart.Body: 
                        return this.isPickBody;
                    default: 
                        return false;
                }
            },
            /*ShopController.CheckNextStep end.*/

            /*ShopController.OnClickItem start.*/
            OnClickItem: function (id) {
if ( TRACE ) { TRACE( "ShopController#OnClickItem", this ); }

                if (!this.handTut.activeSelf) {
                    this.handTut.SetActive(true);
                }
                var currentId = UnityEngine.PlayerPrefs.GetInt(System.Enum.toString(BodyPart, this.bodyPart), 0);
                switch (this.bodyPart) {
                    case BodyPart.Head: 
                        var head = this.headContent.Find(Bridge.toString(currentId));
                        head.GetComponent(ItemDisplay).Deselect();
                        DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScaleY(this.head_img.transform, 0, 0), Bridge.fn.bind(this, function () {
                            this.head_img.sprite = this.heads[id].part;
                            DG.Tweening.ShortcutExtensions.DOScaleY(this.head_img.transform, 1.0, 0.1); //old art
                        }));
                        this.isPickHead = true;
                        this.currentHead = this.heads[id];
                        TabMenuHandler.Instance.TurnOnNextBtn();
                        break;
                    case BodyPart.Eye: 
                        var eye = this.eyeContent.Find(Bridge.toString(currentId));
                        eye.GetComponent(ItemDisplay).Deselect();
                        this.eye_img.sprite = this.eyes[id].part;
                        this.idEye = id;
                        if (this.eyes[id].specialPos) {
                            this.eye_img.transform.localPosition = this.eyes[id].realPos.$clone();
                        } else {
                            this.eye_img.transform.localPosition = this.eyePos.$clone();
                        }
                        DG.Tweening.ShortcutExtensions.DOScale$1(this.eye_img.transform, new pc.Vec3( 1.0, 0, 0 ), 0);
                        DG.Tweening.ShortcutExtensions.DOScaleY(this.eye_img.transform, 1, 0.1);
                        this.isPickEye = true;
                        this.currentEye = this.eyes[id];
                        TabMenuHandler.Instance.TurnOnNextBtn();
                        break;
                    case BodyPart.Mouth: 
                        var mouth = this.mouthContent.Find(Bridge.toString(currentId));
                        mouth.GetComponent(ItemDisplay).Deselect();
                        this.mouth_img.sprite = this.mouths[id].part;
                        this.idMouth = id;
                        this.mouth_img.transform.localPosition = this.mouthPos.$clone();
                        DG.Tweening.ShortcutExtensions.DOScale$1(this.mouth_img.transform, new pc.Vec3( 1.0, 0, 0 ), 0);
                        DG.Tweening.ShortcutExtensions.DOScaleY(this.mouth_img.transform, 1.0, 0.1);
                        this.currentMouth = this.mouths[id];
                        this.isPickMouth = true;
                        TabMenuHandler.Instance.TurnOnNextBtn();
                        break;
                    case BodyPart.Acc: 
                        var acc = this.accContents.Find(Bridge.toString(currentId));
                        acc.GetComponent(ItemDisplay).Deselect();
                        this.acc_img.sprite = this.accs[id].part;
                        this.idAcc = id;
                        if (this.accs[id].specialPos) {
                            this.acc_img.transform.localPosition = this.accs[id].realPos.$clone();
                        }
                        DG.Tweening.ShortcutExtensions.DOScale$1(this.acc_img.transform, new pc.Vec3( 1.0, 0, 0 ), 0);
                        DG.Tweening.ShortcutExtensions.DOScaleY(this.acc_img.transform, 1.0, 0.1);
                        this.isPickAcc = true;
                        this.currentAcc = this.accs[id];
                        TabMenuHandler.Instance.TurnOnNextBtn();
                        break;
                    case BodyPart.Body: 
                        var body = this.bodyContent.Find(Bridge.toString(currentId));
                        body.GetComponent(ItemDisplay).Deselect();
                        this.isPickBody = true;
                        var dataIndex = this.bodies[id].dataAsset;
                        this.currentBody = this.bodies[id];
                        if (dataIndex === 0) {
                            this.body2.SetActive(false);
                            this.body.SetActive(true);

                            this.bodyAnim.skeleton.setSkinByName((this.bodies[id].bodypartName || "") + "_hold");
                            this.bodyAnim.Skeleton.setToSetupPose();

                            this.bodyAnim.AnimationState.setAnimation(0, "Hold", true).mixDuration = 0;
                            this.boneFollower.enabled = true;
                            this.headHolder.SetParent(this.boneFollower.transform);
                            this.headHolder.localPosition = new pc.Vec3( 3.2, 1.0, 0 );
                            this.headHolder.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, -89.145 );
                        } else {
                            this.body.SetActive(false);
                            this.body2.SetActive(true);


                            this.bodyAnim2.skeleton.setSkinByName((System.Enum.toString(CatalogueTheme, this.bodies[id].catalogue) || "") + "/" + (this.bodies[id].bodypartName || ""));
                            this.bodyAnim2.Skeleton.setToSetupPose();

                            this.bodyAnim2.AnimationState.setAnimation(0, "Hold", true).mixDuration = 0;

                            this.boneFollower2.enabled = false;
                            this.boneFollower2.SetBone((this.bodies[id].bodypartName || "") + "_head");
                            this.boneFollower2.enabled = true;
                            this.headHolder.SetParent(this.boneFollower2.transform);

                            this.headHolder.localPosition = pc.Vec3.RIGHT.clone().clone().scale( 0.8 );
                            this.headHolder.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, -89.12 );
                        }
                        UIHandler.Instance.UI_Ingame.ChangeIconToDone();
                        break;
                    default: 
                        break;
                }
            },
            /*ShopController.OnClickItem end.*/

            /*ShopController.SetCurrenBodyPartController start.*/
            SetCurrenBodyPartController: function (index) {
if ( TRACE ) { TRACE( "ShopController#SetCurrenBodyPartController", this ); }

                this.eyeController.enabled = false;
                this.mouthController.enabled = false;
                this.accController.enabled = false;

                switch (index) {
                    case BodyPart.Head: 
                        this.bodyPart = BodyPart.Head;
                        break;
                    case BodyPart.Eye: 
                        this.bodyPart = BodyPart.Eye;
                        this.eyeController.enabled = true;
                        break;
                    case BodyPart.Mouth: 
                        this.bodyPart = BodyPart.Mouth;
                        this.mouthController.enabled = true;
                        break;
                    case BodyPart.Acc: 
                        this.bodyPart = BodyPart.Acc;
                        this.accController.enabled = true;
                        this.FocusHeadCharacter();
                        break;
                    case BodyPart.Body: 
                        this.bodyPart = BodyPart.Body;
                        this.ForcusEntireCharacter();
                        break;
                }

            },
            /*ShopController.SetCurrenBodyPartController end.*/

            /*ShopController.ForcusEntireCharacter start.*/
            ForcusEntireCharacter: function () {
if ( TRACE ) { TRACE( "ShopController#ForcusEntireCharacter", this ); }

                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.characterManager, new pc.Vec3( 1, 1, 1 ).clone().scale( 0.5 ), 0.3), DG.Tweening.Ease.InOutSine);
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.characterManager, 2.5, 0.3), DG.Tweening.Ease.InOutSine);
            },
            /*ShopController.ForcusEntireCharacter end.*/

            /*ShopController.FocusHeadCharacter start.*/
            FocusHeadCharacter: function () {
if ( TRACE ) { TRACE( "ShopController#FocusHeadCharacter", this ); }

                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.characterManager, new pc.Vec3( 1, 1, 1 ), 0.3), DG.Tweening.Ease.InOutSine);
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.characterManager, 0.0, 0.3), DG.Tweening.Ease.InOutSine);
            },
            /*ShopController.FocusHeadCharacter end.*/

            /*ShopController.InitItems start.*/
            InitItems: function (items, content, startIdx) {
if ( TRACE ) { TRACE( "ShopController#InitItems", this ); }

                if (startIdx === void 0) { startIdx = 0; }
                var templateObject = content.GetChild(0).GetComponent(ItemDisplay);

                for (var i = 0; i < items.length; i = (i + 1) | 0) {
                    var itemObject = UnityEngine.Object.Instantiate(ItemDisplay, templateObject, content);
                    items[i].id = i;
                    itemObject.Show(items[i], i);
                    itemObject.name = Bridge.toString(i);

                    if (items[i].priority === Priority.High || items[i].priority === Priority.SeasonReward) {
                        itemObject.SetSib(startIdx);
                    }

                    if (items[i].priority === Priority.SeasonReward) {
                        var temp = i;
                        if (items[i].bodyPart === BodyPart.Head || items[i].bodyPart === BodyPart.Body) {
                            temp = (temp - 1) | 0;
                        }

                        if (UnityEngine.PlayerPrefs.GetInt("SS" + System.Enum.toString(BodyPart, items[i].bodyPart) + temp, 0) === 0) {
                            itemObject.gameObject.SetActive(false);
                        } else {
                            itemObject.gameObject.SetActive(true);
                        }
                    }
                }

                UnityEngine.MonoBehaviour.Destroy(templateObject.gameObject);
            },
            /*ShopController.InitItems end.*/

            /*ShopController.HandleSortItemIngame start.*/
            HandleSortItemIngame: function () {
if ( TRACE ) { TRACE( "ShopController#HandleSortItemIngame", this ); }

                this.SortArr(this.heads);
                this.SortArr(this.eyes);
                this.SortArr(this.mouths);
                this.SortArr(this.accs);
                this.SortArr(this.bodies);
            },
            /*ShopController.HandleSortItemIngame end.*/

            /*ShopController.SortArr start.*/
            SortArr: function (items) {
if ( TRACE ) { TRACE( "ShopController#SortArr", this ); }

                System.Array.sort(items, function (a, b) {
                        return (Bridge.compare(System.Int32.parse(a.name), System.Int32.parse(b.name)));
                    });

            },
            /*ShopController.SortArr end.*/


        }
    });
    /*ShopController end.*/

    /*SortingLayerCharacter start.*/
    Bridge.define("SortingLayerCharacter", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            sortingGroup: null,
            baseSortingOrderLayer: 0,
            offset: 0,
            timer: 0,
            maxTimer: 0,
            isDrag: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SortingLayerCharacter#init", this ); }

                this.baseSortingOrderLayer = 1000;
                this.offset = -10;
                this.maxTimer = 0.1;
                this.isDrag = false;
            }
        },
        methods: {
            /*SortingLayerCharacter.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "SortingLayerCharacter#Awake", this ); }

                this.sortingGroup = this.GetComponent(UnityEngine.Rendering.SortingGroup);
            },
            /*SortingLayerCharacter.Awake end.*/

            /*SortingLayerCharacter.SetDragState start.*/
            SetDragState: function (state) {
if ( TRACE ) { TRACE( "SortingLayerCharacter#SetDragState", this ); }

                this.isDrag = state;
            },
            /*SortingLayerCharacter.SetDragState end.*/

            /*SortingLayerCharacter.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "SortingLayerCharacter#LateUpdate", this ); }

                if (this.isDrag) {
                    this.timer -= UnityEngine.Time.deltaTime;
                    if (this.timer <= 0) {
                        this.timer = this.maxTimer;
                        this.sortingGroup.sortingOrder = Bridge.Int.clip32(this.baseSortingOrderLayer - this.transform.position.y - this.offset);
                    }
                }
            },
            /*SortingLayerCharacter.LateUpdate end.*/


        }
    });
    /*SortingLayerCharacter end.*/

    /*Sound start.*/
    Bridge.define("Sound", {
        $kind: 6,
        statics: {
            fields: {
                bg: 0,
                next: 1,
                done: 2,
                start: 3,
                congrate: 4,
                outtro: 5,
                rollSFX: 6,
                winSFX: 7,
                startSFX: 8,
                winSFX2: 9,
                startSFX2: 10,
                musicSFX: 11,
                firework: 12,
                popup: 13,
                cashCoin: 14,
                bg2: 15,
                teddy: 16,
                heart: 17,
                rocket: 18,
                cash: 19,
                unlockItem: 20,
                unlockNewArea: 21,
                beachBg: 22,
                toiletBg: 23,
                concertBg: 24,
                makeoverPk: 25,
                losePk: 26,
                winPk: 27,
                point1: 28,
                point2: 29,
                point3: 30,
                startRandom: 31,
                endRandom: 32,
                readyPk: 33,
                heartBtn: 34
            }
        }
    });
    /*Sound end.*/

    /*SoundAudioClip start.*/
    Bridge.define("SoundAudioClip", {
        fields: {
            sound: 0,
            audioClip: null,
            volume: 0,
            pitch: 0,
            loop: false,
            source: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SoundAudioClip#init", this ); }

                this.volume = 1.0;
                this.pitch = 1.0;
            }
        }
    });
    /*SoundAudioClip end.*/

    /*SoundManager start.*/
    Bridge.define("SoundManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                SOUND: null,
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "SoundManager#init", this ); }

                    this.SOUND = "Sound";
                }
            }
        },
        fields: {
            soundAudioClips: null,
            itemClickedAudio: null,
            choose: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SoundManager#init", this ); }

                this.choose = 0;
            }
        },
        methods: {
            /*SoundManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "SoundManager#Awake", this ); }

                var $t, $t1;
                if (UnityEngine.MonoBehaviour.op_Equality(SoundManager.Instance, null)) {
                    SoundManager.Instance = this;
                    //DontDestroyOnLoad(gameObject);
                } else {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                    return;
                }
                $t = Bridge.getEnumerator(this.soundAudioClips);
                try {
                    while ($t.moveNext()) {
                        var s = $t.Current;
                        s.source = this.gameObject.AddComponent(UnityEngine.AudioSource);
                        s.source.clip = s.audioClip;
                        s.source.volume = s.volume;
                        s.source.pitch = 1;
                        s.source.loop = s.loop;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.itemClickedAudio);
                try {
                    while ($t1.moveNext()) {
                        var s1 = $t1.Current;
                        s1.source = this.gameObject.AddComponent(UnityEngine.AudioSource);
                        s1.source.clip = s1.audioClip;
                        s1.source.volume = s1.volume;
                        s1.source.pitch = 1;
                        s1.source.loop = s1.loop;
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            },
            /*SoundManager.Awake end.*/

            /*SoundManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "SoundManager#Start", this ); }

                this.PlaySound(Sound.bg);
            },
            /*SoundManager.Start end.*/

            /*SoundManager.PlaySound start.*/
            /**
             * 0: ingame, 1: lobby
             *
             * @instance
             * @public
             * @this SoundManager
             * @memberof SoundManager
             * @param   {Sound}      sound     
             * @param   {boolean}    toggle
             * @return  {void}
             */
            PlaySound: function (sound, toggle) {
if ( TRACE ) { TRACE( "SoundManager#PlaySound", this ); }

                if (toggle === void 0) { toggle = false; }
                var soundAudioClip = this.GetAudioClip(sound);
                if (soundAudioClip == null) {
                    return;
                }
                soundAudioClip.source.Play();
            },
            /*SoundManager.PlaySound end.*/

            /*SoundManager.PlaySFX start.*/
            PlaySFX: function (sound, volume, isPlayAgain) {
if ( TRACE ) { TRACE( "SoundManager#PlaySFX", this ); }

                if (isPlayAgain === void 0) { isPlayAgain = false; }
                var soundAudioClip = this.GetAudioClip(sound);
                if (soundAudioClip == null) {
                    return;
                }
                if (UnityEngine.PlayerPrefs.GetInt(SoundManager.SOUND) === 1) {
                    soundAudioClip.source.volume = volume;
                    if (!isPlayAgain) {
                        soundAudioClip.source.Play();
                    }
                }
            },
            /*SoundManager.PlaySFX end.*/

            /*SoundManager.PauseSound start.*/
            PauseSound: function (sound, toggle) {
if ( TRACE ) { TRACE( "SoundManager#PauseSound", this ); }

                if (toggle === void 0) { toggle = false; }
                var soundAudioClip = this.GetAudioClip(sound);
                if (soundAudioClip == null || UnityEngine.Component.op_Equality(soundAudioClip.source, null)) {
                    return;
                }
                soundAudioClip.source.Stop();
            },
            /*SoundManager.PauseSound end.*/

            /*SoundManager.PlayItemClickedSound start.*/
            PlayItemClickedSound: function (choose) {
if ( TRACE ) { TRACE( "SoundManager#PlayItemClickedSound", this ); }

                if (choose === void 0) { choose = -1; }
                if (choose !== -1) {
                    this.itemClickedAudio[choose].source.Play();
                } else {
                    var id = UnityEngine.Random.Range(0, this.itemClickedAudio.length);
                    this.itemClickedAudio[id].source.Play();
                }
            },
            /*SoundManager.PlayItemClickedSound end.*/

            /*SoundManager.GetAudioClip start.*/
            GetAudioClip: function (sound) {
if ( TRACE ) { TRACE( "SoundManager#GetAudioClip", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.soundAudioClips);
                try {
                    while ($t.moveNext()) {
                        var soundAudioClip = $t.Current;
                        if (soundAudioClip.sound === sound) {
                            return soundAudioClip;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                MyDebug.Log("Sound " + System.Enum.toString(Sound, sound) + " not found");
                return null;
            },
            /*SoundManager.GetAudioClip end.*/

            /*SoundManager.ChangePitch start.*/
            ChangePitch: function (value) {
if ( TRACE ) { TRACE( "SoundManager#ChangePitch", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(this.soundAudioClips);
                try {
                    while ($t.moveNext()) {
                        var s = $t.Current;
                        s.source.pitch = value;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.itemClickedAudio);
                try {
                    while ($t1.moveNext()) {
                        var s1 = $t1.Current;
                        s1.source.pitch = value;
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            },
            /*SoundManager.ChangePitch end.*/


        }
    });
    /*SoundManager end.*/

    /*Spine.BoneMatrix start.*/
    Bridge.define("Spine.BoneMatrix", {
        $kind: 4,
        statics: {
            methods: {
                /*Spine.BoneMatrix.CalculateSetupWorld:static start.*/
                /**
                 * Recursively calculates a worldspace bone matrix based on BoneData.
                 *
                 * @static
                 * @public
                 * @this Spine.BoneMatrix
                 * @memberof Spine.BoneMatrix
                 * @param   {spine.BoneData}      boneData
                 * @return  {Spine.BoneMatrix}
                 */
                CalculateSetupWorld: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#CalculateSetupWorld", this ); }

                    if (boneData == null) {
                        return Bridge.getDefaultValue(Spine.BoneMatrix);
                    }

                    // End condition: isRootBone
                    if (boneData.parent == null) {
                        return Spine.BoneMatrix.GetInheritedInternal(boneData, Bridge.getDefaultValue(Spine.BoneMatrix));
                    }

                    var result = Spine.BoneMatrix.CalculateSetupWorld(boneData.parent);
                    return Spine.BoneMatrix.GetInheritedInternal(boneData, result.$clone());
                },
                /*Spine.BoneMatrix.CalculateSetupWorld:static end.*/

                /*Spine.BoneMatrix.GetInheritedInternal:static start.*/
                GetInheritedInternal: function (boneData, parentMatrix) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#GetInheritedInternal", this ); }

                    var parent = boneData.parent;
                    if (parent == null) {
                        return new Spine.BoneMatrix.$ctor2(boneData);
                    } // isRootBone

                    var pa = parentMatrix.a, pb = parentMatrix.b, pc = parentMatrix.c, pd = parentMatrix.d;
                    var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                    result.x = pa * boneData.x + pb * boneData.y + parentMatrix.x;
                    result.y = pc * boneData.x + pd * boneData.y + parentMatrix.y;

                    switch (boneData.transformMode) {
                        case spine.BoneData.Normal: 
                            {
                                var rotationY = boneData.rotation + 90 + boneData.shearY;
                                var la = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var lb = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                                var lc = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var ld = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                                result.a = pa * la + pb * lc;
                                result.b = pa * lb + pb * ld;
                                result.c = pc * la + pd * lc;
                                result.d = pc * lb + pd * ld;
                                break;
                            }
                        case spine.BoneData.OnlyTranslation: 
                            {
                                var rotationY1 = boneData.rotation + 90 + boneData.shearY;
                                result.a = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.b = Spine.MathUtils.CosDeg(rotationY1) * boneData.scaleY;
                                result.c = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.d = Spine.MathUtils.SinDeg(rotationY1) * boneData.scaleY;
                                break;
                            }
                        case spine.BoneData.NoRotationOrReflection: 
                            {
                                var s = pa * pa + pc * pc, prx;
                                if (s > 0.0001) {
                                    s = Math.abs(pa * pd - pb * pc) / s;
                                    pb = pc * s;
                                    pd = pa * s;
                                    prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                } else {
                                    pa = 0;
                                    pc = 0;
                                    prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                                }
                                var rx = boneData.rotation + boneData.shearX - prx;
                                var ry = boneData.rotation + boneData.shearY - prx + 90;
                                var la1 = Spine.MathUtils.CosDeg(rx) * boneData.scaleX;
                                var lb1 = Spine.MathUtils.CosDeg(ry) * boneData.scaleY;
                                var lc1 = Spine.MathUtils.SinDeg(rx) * boneData.scaleX;
                                var ld1 = Spine.MathUtils.SinDeg(ry) * boneData.scaleY;
                                result.a = pa * la1 - pb * lc1;
                                result.b = pa * lb1 - pb * ld1;
                                result.c = pc * la1 + pd * lc1;
                                result.d = pc * lb1 + pd * ld1;
                                break;
                            }
                        case spine.BoneData.NoScale: 
                        case spine.BoneData.NoScaleOrReflection: 
                            {
                                var cos = Spine.MathUtils.CosDeg(boneData.rotation), sin = Spine.MathUtils.SinDeg(boneData.rotation);
                                var za = pa * cos + pb * sin;
                                var zc = pc * cos + pd * sin;
                                var s1 = Math.sqrt(za * za + zc * zc);
                                if (s1 > 1E-05) {
                                    s1 = 1 / s1;
                                }
                                za *= s1;
                                zc *= s1;
                                s1 = Math.sqrt(za * za + zc * zc);
                                var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                                var zb = Spine.MathUtils.Cos(r) * s1;
                                var zd = Spine.MathUtils.Sin(r) * s1;
                                var la2 = Spine.MathUtils.CosDeg(boneData.shearX) * boneData.scaleX;
                                var lb2 = Spine.MathUtils.CosDeg(90 + boneData.shearY) * boneData.scaleY;
                                var lc2 = Spine.MathUtils.SinDeg(boneData.shearX) * boneData.scaleX;
                                var ld2 = Spine.MathUtils.SinDeg(90 + boneData.shearY) * boneData.scaleY;
                                if (boneData.transformMode !== spine.BoneData.NoScaleOrReflection ? pa * pd - pb * pc < 0 : false) {
                                    zb = -zb;
                                    zd = -zd;
                                }
                                result.a = za * la2 + zb * lc2;
                                result.b = za * lb2 + zb * ld2;
                                result.c = zc * la2 + zd * lc2;
                                result.d = zc * lb2 + zd * ld2;
                                break;
                            }
                    }

                    return result.$clone();
                },
                /*Spine.BoneMatrix.GetInheritedInternal:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getDefaultValue", this ); }
 return new Spine.BoneMatrix(); }
            }
        },
        fields: {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            x: 0,
            y: 0
        },
        ctors: {
            /**
             * Constructor for a local bone matrix based on Setup Pose BoneData.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {spine.BoneData}    boneData
             * @return  {void}
             */
            $ctor2: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor2", this ); }

                this.$initialize();
                var rotationY = boneData.rotation + 90 + boneData.shearY;
                var rotationX = boneData.rotation + boneData.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * boneData.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * boneData.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                this.x = boneData.x;
                this.y = boneData.y;
            },
            /**
             * Constructor for a local bone matrix based on a bone instance's current pose.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            $ctor1: function (bone) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor1", this ); }

                this.$initialize();
                var rotationY = bone.rotation + 90 + bone.shearY;
                var rotationX = bone.rotation + bone.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * bone.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * bone.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * bone.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * bone.scaleY;
                this.x = bone.x;
                this.y = bone.y;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.BoneMatrix.TransformMatrix start.*/
            TransformMatrix: function (local) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#TransformMatrix", this ); }

                var $t;
                return ($t = new Spine.BoneMatrix.ctor(), $t.a = this.a * local.a + this.b * local.c, $t.b = this.a * local.b + this.b * local.d, $t.c = this.c * local.a + this.d * local.c, $t.d = this.c * local.b + this.d * local.d, $t.x = this.a * local.x + this.b * local.y + this.x, $t.y = this.c * local.x + this.d * local.y + this.y, $t);
            },
            /*Spine.BoneMatrix.TransformMatrix end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getHashCode", this ); }

                var h = Bridge.addHash([3621996792, this.a, this.b, this.c, this.d, this.x, this.y]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#equals", this ); }

                if (!Bridge.is(o, Spine.BoneMatrix)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b) && Bridge.equals(this.c, o.c) && Bridge.equals(this.d, o.d) && Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$clone", this ); }

                var s = to || new Spine.BoneMatrix();
                s.a = this.a;
                s.b = this.b;
                s.c = this.c;
                s.d = this.d;
                s.x = this.x;
                s.y = this.y;
                return s;
            }
        }
    });
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    Bridge.define("Spine.SpineSkeletonExtensions", {
        statics: {
            methods: {
                /*Spine.SpineSkeletonExtensions.IsWeighted:static start.*/
                IsWeighted: function (va) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsWeighted", this ); }

                    return va.bones != null && va.bones.length > 0;
                },
                /*Spine.SpineSkeletonExtensions.IsWeighted:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsRotation:static start.*/
                InheritsRotation: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsRotation", this ); }

                    var RotationBit = 0;
                    return (System.Int64(mode).and(System.Int64((1)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsRotation:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsScale:static start.*/
                InheritsScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsScale", this ); }

                    var ScaleBit = 1;
                    return (System.Int64(mode).and(System.Int64((2)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsScale:static end.*/


            }
        }
    });
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    /** @namespace Spine.Unity */

    /**
     * Utility component to support flipping of 2D hinge chains (chains of HingeJoint2D objects) along
     with the parent skeleton by activating the respective mirrored versions of the hinge chain.
     Note: This component is automatically attached when calling "Create Hinge Chain 2D" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.ActivateBasedOnFlipDirection
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.ActivateBasedOnFlipDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            skeletonGraphic: null,
            activeOnNormalX: null,
            activeOnFlippedX: null,
            jointsNormalX: null,
            jointsFlippedX: null,
            skeletonComponent: null,
            wasFlippedXBefore: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#init", this ); }

                this.wasFlippedXBefore = false;
            }
        },
        methods: {
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#Start", this ); }

                this.jointsNormalX = this.activeOnNormalX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.jointsFlippedX = this.activeOnFlippedX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? Bridge.cast(this.skeletonRenderer, Spine.Unity.ISkeletonComponent) : Bridge.cast(this.skeletonGraphic, Spine.Unity.ISkeletonComponent);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate", this ); }

                var isFlippedX = (this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.scaleX < 0);
                if (isFlippedX !== this.wasFlippedXBefore) {
                    this.HandleFlip(isFlippedX);
                }
                this.wasFlippedXBefore = isFlippedX;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip start.*/
            HandleFlip: function (isFlippedX) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip", this ); }

                var gameObjectToActivate = isFlippedX ? this.activeOnFlippedX : this.activeOnNormalX;
                var gameObjectToDeactivate = isFlippedX ? this.activeOnNormalX : this.activeOnFlippedX;

                gameObjectToActivate.SetActive(true);
                gameObjectToDeactivate.SetActive(false);

                this.ResetJointPositions(isFlippedX ? this.jointsFlippedX : this.jointsNormalX);
                this.ResetJointPositions(isFlippedX ? this.jointsNormalX : this.jointsFlippedX);
                this.CompensateMovementAfterFlipX(gameObjectToActivate.transform, gameObjectToDeactivate.transform);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions start.*/
            ResetJointPositions: function (joints) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions", this ); }

                for (var i = 0; i < joints.length; i = (i + 1) | 0) {
                    var joint = joints[i];
                    var parent = joint.connectedBody.transform;
                    joint.transform.position = parent.TransformPoint$1(UnityEngine.Vector3.FromVector2(joint.connectedAnchor));
                }
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX start.*/
            CompensateMovementAfterFlipX: function (toActivate, toDeactivate) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX", this ); }

                var targetLocation = toDeactivate.GetChild(0);
                var currentLocation = toActivate.GetChild(0);
                toActivate.position = toActivate.position.$clone().add( targetLocation.position.$clone().sub( currentLocation.position ) );
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX end.*/


        }
    });
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.ISpineComponent start.*/
    Bridge.define("Spine.Unity.ISpineComponent", {
        $kind: 3
    });
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    Bridge.define("Spine.Unity.AnimationTools.TimelineExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static start.*/
                /**
                 * Evaluates the resulting value of a TranslateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is provided, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateTimeline}    timeline        
                 * @param   {number}                     time            
                 * @param   {Spine.SkeletonData}         skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$1: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var x = { }, y = { };
                    timeline.getCurveValue(x, y, time);

                    if (skeletonData == null) {
                        return new pc.Vec2( x.v, y.v );
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.boneIndex];
                        return new pc.Vec2( boneData.x + x.v, boneData.y + y.v );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static start.*/
                /**
                 * Evaluates the resulting value of a pair of split translate timelines at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateXTimeline}    xTimeline       
                 * @param   {spine.TranslateYTimeline}    yTimeline       
                 * @param   {number}                      time            
                 * @param   {Spine.SkeletonData}          skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$2: function (xTimeline, yTimeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }

                    var x = 0, y = 0;
                    if (xTimeline != null && time > ($t = xTimeline.frames)[0]) {
                        x = xTimeline.getCurveValue(time);
                    }
                    if (yTimeline != null && time > ($t1 = yTimeline.frames)[0]) {
                        y = yTimeline.getCurveValue(time);
                    }

                    if (skeletonData == null) {
                        return new pc.Vec2( x, y );
                    } else {
                        var bonesItems = skeletonData.Bones.Items;
                        var boneDataX = bonesItems[xTimeline.boneIndex];
                        var boneDataY = bonesItems[yTimeline.boneIndex];
                        return new pc.Vec2( boneDataX.x + x, boneDataY.y + y );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static start.*/
                /**
                 * Evaluates the resulting value of a RotateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.RotateTimeline}    timeline        
                 * @param   {number}                  time            
                 * @param   {Spine.SkeletonData}      skeletonData
                 * @return  {number}
                 */
                Evaluate: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.frames)[0]) {
                        return 0.0;
                    }

                    var rotation = timeline.getCurveValue(time);
                    if (skeletonData == null) {
                        return rotation;
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.boneIndex];
                        return (boneData.rotation + rotation);
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static start.*/
                /**
                 * Evaluates the resulting X and Y translate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {UnityEngine.Vector2}
                 */
                EvaluateTranslateXYMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix", this ); }

                    var $t;
                    if (time < ($t = timeline.frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.getCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return new pc.Vec2( mixX.v, mixY.v );
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static start.*/
                /**
                 * Evaluates the resulting rotate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {number}
                 */
                EvaluateRotateMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix", this ); }

                    var $t;
                    if (time < ($t = timeline.frames)[0]) {
                        return 0;
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.getCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return rotate.v;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static start.*/
                /**
                 * Gets the translate timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}            a            
                 * @param   {number}                     boneIndex
                 * @return  {spine.TranslateTimeline}
                 */
                FindTranslateTimelineForBone: function (a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof spine.TranslateTimeline)) {
                                continue;
                            }

                            var translateTimeline = Bridge.as(timeline, spine.TranslateTimeline);
                            if (translateTimeline != null && translateTimeline.boneIndex === boneIndex) {
                                return translateTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static start.*/
                /**
                 * Gets the IBoneTimeline timeline of a given type for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBoneIndex.
                 The root bone is always boneIndex 0.
                 This will return null if a timeline of the given type is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Function}           T            
                 * @param   {Spine.Animation}    a            
                 * @param   {number}             boneIndex
                 * @return  {T}
                 */
                FindTimelineForBone: function (T, a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            var translateTimeline = Bridge.as(timeline, T);
                            if (Bridge.rValue(translateTimeline) != null && Bridge.rValue(translateTimeline).Spine$IBoneTimeline$BoneIndex === boneIndex) {
                                return Bridge.rValue(translateTimeline);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static start.*/
                /**
                 * Gets the transform constraint timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}                      a                           
                 * @param   {number}                               transformConstraintIndex
                 * @return  {spine.TransformConstraintTimeline}
                 */
                FindTransformConstraintTimeline: function (a, transformConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof spine.TransformConstraintTimeline)) {
                                continue;
                            }

                            var transformConstraintTimeline = Bridge.as(timeline, spine.TransformConstraintTimeline);
                            if (transformConstraintTimeline != null && transformConstraintTimeline.transformConstraintIndex === transformConstraintIndex) {
                                return transformConstraintTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static end.*/


            }
        }
    });
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials", {
        fields: {
            requiresBlendModeMaterials: false,
            applyAdditiveMaterial: false,
            additiveMaterials: null,
            multiplyMaterials: null,
            screenMaterials: null
        },
        props: {
            RequiresBlendModeMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get", this ); }

                    return this.requiresBlendModeMaterials;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set", this ); }

                    this.requiresBlendModeMaterials = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#init", this ); }

                this.requiresBlendModeMaterials = false;
                this.applyAdditiveMaterial = false;
                this.additiveMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.multiplyMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.screenMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial start.*/
            BlendModeForMaterial: function (material) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#BlendModeForMaterial", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.multiplyMaterials);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        if (Bridge.referenceEquals(pair.material, material)) {
                            return spine.BlendMode.Multiply;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.additiveMaterials);
                try {
                    while ($t1.moveNext()) {
                        var pair1 = $t1.Current;
                        if (Bridge.referenceEquals(pair1.material, material)) {
                            return spine.BlendMode.Additive;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                $t2 = Bridge.getEnumerator(this.screenMaterials);
                try {
                    while ($t2.moveNext()) {
                        var pair2 = $t2.Current;
                        if (Bridge.referenceEquals(pair2.material, material)) {
                            return spine.BlendMode.Screen;
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                return spine.BlendMode.Normal;
            },
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial end.*/

            /*Spine.Unity.BlendModeMaterials.ApplyMaterials start.*/
            ApplyMaterials: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#ApplyMaterials", this ); }

                var $t, $t1;
                if (skeletonData == null) {
                    throw new System.ArgumentNullException.$ctor1("skeletonData");
                }
                if (!this.requiresBlendModeMaterials) {
                    return;
                }

                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.blendMode === spine.BlendMode.Normal) {
                        continue;
                    }
                    if (!this.applyAdditiveMaterial && slot.blendMode === spine.BlendMode.Additive) {
                        continue;
                    }

                    var replacementMaterials = null;
                    switch (slot.blendMode) {
                        case spine.BlendMode.Multiply: 
                            replacementMaterials = this.multiplyMaterials;
                            break;
                        case spine.BlendMode.Screen: 
                            replacementMaterials = this.screenMaterials;
                            break;
                        case spine.BlendMode.Additive: 
                            replacementMaterials = this.additiveMaterials;
                            break;
                    }
                    if (replacementMaterials == null) {
                        continue;
                    }

                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var entry = $t1.Current;
                            var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasTextureRegion);
                            if (renderableAttachment != null) {
                                if (renderableAttachment.Spine$IHasTextureRegion$Region != null) {
                                    renderableAttachment.Spine$IHasTextureRegion$Region = this.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), replacementMaterials);
                                } else {
                                    if (renderableAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                        var regions = renderableAttachment.Spine$IHasTextureRegion$Sequence.regions;
                                        for (var i = 0; i < regions.length; i = (i + 1) | 0) {
                                            regions[i] = this.CloneAtlasRegionWithMaterial(Bridge.cast(regions[i], Spine.AtlasRegion), replacementMaterials);
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials end.*/

            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, replacementMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial", this ); }

                var $t;
                var newRegion = originalRegion.Clone();
                var material = null;
                $t = Bridge.getEnumerator(replacementMaterials);
                try {
                    while ($t.moveNext()) {
                        var replacement = $t.Current;
                        if (Bridge.referenceEquals(replacement.pageName, originalRegion.page.name)) {
                            material = replacement.material;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var originalPage = originalRegion.page;
                var newPage = originalPage.Clone();
                newPage.rendererObject = material;
                newRegion.page = newPage;
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.ReplacementMaterial", {
        $kind: 1002,
        fields: {
            pageName: null,
            material: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    /**
     * Can be stored by SkeletonDataAsset to automatically apply modifications to loaded SkeletonData.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonDataModifierAsset
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("Spine.Unity.SkeletonDataModifierAsset", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            cache: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init", this ); }

                this.cache = new (System.Collections.Generic.Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial start.*/
            /**
             * Creates a clone of an AtlasRegion that uses different Material settings, while retaining the original texture.
             *
             * @instance
             * @public
             * @this Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @memberof Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @param   {Spine.AtlasRegion}       originalRegion      
             * @param   {UnityEngine.Material}    materialTemplate
             * @return  {Spine.AtlasRegion}
             */
            CloneAtlasRegionWithMaterial: function (originalRegion, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial", this ); }

                var newRegion = originalRegion.Clone();
                newRegion.page = this.GetAtlasPageWithMaterial(originalRegion.page, materialTemplate);
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial start.*/
            GetAtlasPageWithMaterial: function (originalPage, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial", this ); }

                var $t;
                if (originalPage == null) {
                    throw new System.ArgumentNullException.$ctor1("originalPage");
                }

                var newPage = { v : null };
                var key = new (System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material)).$ctor1(originalPage, materialTemplate);
                this.cache.tryGetValue(key, newPage);

                if (newPage.v == null) {
                    newPage.v = originalPage.Clone();
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);
                    newPage.v.rendererObject = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    this.cache.add(key, newPage.v);
                }

                return newPage.v;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose", this ); }

                this.cache.clear();
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.BoneFollower
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.BoneFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollower
             * @type string
             */
            boneName: null,
            followXYPosition: false,
            followZPosition: false,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            maintainedAxisOrientation: 0,
            initializeOnAwake: false,
            valid: false,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#set", this ); }

                    this.skeletonRenderer = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#init", this ); }

                this.followXYPosition = true;
                this.followZPosition = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
                this.initializeOnAwake = true;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollower.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found. To set the bone by reference, use BoneFollower.bone directly.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollower
             * @memberof Spine.Unity.BoneFollower
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SetBone", this ); }

                this.bone = this.skeletonRenderer.skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollower.SetBone end.*/

            /*Spine.Unity.BoneFollower.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollower.Awake end.*/

            /*Spine.Unity.BoneFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoneFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.BoneFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollower.Initialize end.*/

            /*Spine.Unity.BoneFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.BoneFollower.OnDestroy end.*/

            /*Spine.Unity.BoneFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = this.transform;
                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        var halfRotation = Math.atan2(this.bone.c, this.bone.a) * 0.5;
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            halfRotation += 1.57079637;
                        }

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX, this.bone.worldY, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    Bridge.define("Spine.Unity.BoneFollower.AxisOrientation", {
        $kind: 1006,
        statics: {
            fields: {
                XAxis: 1,
                YAxis: 2
            }
        }
    });
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoneFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            initializeOnAwake: false,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @type string
             */
            boneName: null,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            followXYPosition: false,
            followZPosition: false,
            maintainedAxisOrientation: 0,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            valid: false
        },
        props: {
            SkeletonGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get", this ); }

                    return this.skeletonGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set", this ); }

                    this.skeletonGraphic = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#init", this ); }

                this.initializeOnAwake = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.followXYPosition = true;
                this.followZPosition = true;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollowerGraphic.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollowerGraphic
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SetBone", this ); }

                this.bone = this.skeletonGraphic.Skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollowerGraphic.SetBone end.*/

            /*Spine.Unity.BoneFollowerGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Awake end.*/

            /*Spine.Unity.BoneFollowerGraphic.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonGraphic.transform;
                //			skeletonGraphic.OnRebuild -= HandleRebuildRenderer;
                //			skeletonGraphic.OnRebuild += HandleRebuildRenderer;
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoneFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(thisTransform, null)) {
                    return;
                }

                var canvas = this.skeletonGraphic.canvas;
                if (UnityEngine.Component.op_Equality(canvas, null)) {
                    canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                }
                var scale = UnityEngine.Component.op_Inequality(canvas, null) ? canvas.referencePixelsPerUnit : 100.0;

                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX * scale : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY * scale : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        thisTransform.localRotation = Spine.Unity.SkeletonExtensions.GetQuaternion(this.bone);
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX * scale, this.bone.worldY * scale, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonRenderer: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollower.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.Start end.*/

            /*Spine.Unity.BoundingBoxFollower.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollower.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#HandleRebuild", this ); }

                //if (BoundingBoxFollower.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollower.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollower.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollower colliders. This is method checks if the BoundingBoxFollower has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                this.skeletonRenderer.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonRenderer.skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollower on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollower tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollower.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollower.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollower.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollower.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollower.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollower.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollower tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollower.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild", this ); }

                //if (BoundingBoxFollowerGraphic.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollowerGraphic.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollowerGraphic colliders. This is method checks if the BoundingBoxFollowerGraphic has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.skeletonGraphic.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonGraphic.Skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonGraphic.Skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollowerGraphic on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    var canvas = this.skeletonGraphic.canvas;
                    if (UnityEngine.Component.op_Equality(canvas, null)) {
                        canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                    }
                    var scale = UnityEngine.Component.op_Inequality(canvas, null) ? canvas.referencePixelsPerUnit : 100.0;

                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, scale, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, scale, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, scale, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollowerGraphic tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment, scale);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollowerGraphic tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollowerGraphic.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    Bridge.define("Spine.Unity.DoubleBuffered$1", function (T) { return {
        fields: {
            a: null,
            b: null,
            usingA: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#init", this ); }

                this.a = Bridge.createInstance(T);
                this.b = Bridge.createInstance(T);
            }
        },
        methods: {
            /*Spine.Unity.DoubleBuffered$1.GetCurrent start.*/
            GetCurrent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetCurrent", this ); }

                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetCurrent end.*/

            /*Spine.Unity.DoubleBuffered$1.GetNext start.*/
            GetNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetNext", this ); }

                this.usingA = !this.usingA;
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetNext end.*/


        }
    }; });
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    Bridge.define("Spine.Unity.EventDataReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#op_Implicit", this ); }

                    return asset.EventData;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            eventName: null,
            eventData: null
        },
        props: {
            EventData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#EventData#get", this ); }

                    if (this.eventData == null) {
                        this.Initialize();
                    }
                    return this.eventData;
                }
            }
        },
        methods: {
            /*Spine.Unity.EventDataReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.eventData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.EventDataReferenceAsset.QuietSkeletonData).findEvent(this.eventName);
                if (this.eventData == null) {
                    UnityEngine.Debug.LogWarningFormat("Event Data '{0}' not found in SkeletonData : {1}.", [this.eventName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.EventDataReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link }.
     *
     * @public
     * @class Spine.Unity.FollowLocationRigidbody
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowLocationRigidbody", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody#Awake", this ); }

                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody);
            },
            /*Spine.Unity.FollowLocationRigidbody.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody#FixedUpdate", this ); }

                this.ownRigidbody.rotation = this.reference.rotation.$clone();
                this.ownRigidbody.position = this.reference.position.$clone();
            },
            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link }.
     *
     * @public
     * @class Spine.Unity.FollowLocationRigidbody2D
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowLocationRigidbody2D", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            followFlippedX: false,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody2D.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody2D#Awake", this ); }

                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody2D);
            },
            /*Spine.Unity.FollowLocationRigidbody2D.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody2D#FixedUpdate", this ); }

                if (this.followFlippedX) {
                    this.ownRigidbody.rotation = ((-this.reference.rotation.getPositiveEulerAngles().z + 270.0) % 360.0) - 90.0;
                } else {
                    this.ownRigidbody.rotation = this.reference.rotation.getPositiveEulerAngles().z;
                }
                this.ownRigidbody.position = UnityEngine.Vector2.FromVector3(this.reference.position.$clone());
            },
            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note that flipping needs to be performed by 180 degree rotation at {@link },
     by setting {@link } to true, not via negative scale.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.FollowSkeletonUtilityRootRotation
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowSkeletonUtilityRootRotation", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                FLIP_ANGLE_THRESHOLD: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#init", this ); }

                    this.FLIP_ANGLE_THRESHOLD = 100.0;
                }
            }
        },
        fields: {
            reference: null,
            prevLocalEulerAngles: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#init", this ); }

                this.prevLocalEulerAngles = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#Start", this ); }

                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#FixedUpdate", this ); }

                this.transform.rotation = this.reference.rotation.$clone();

                var wasFlippedAroundY = Math.abs(this.transform.localEulerAngles.y - this.prevLocalEulerAngles.y) > Spine.Unity.FollowSkeletonUtilityRootRotation.FLIP_ANGLE_THRESHOLD;
                var wasFlippedAroundX = Math.abs(this.transform.localEulerAngles.x - this.prevLocalEulerAngles.x) > Spine.Unity.FollowSkeletonUtilityRootRotation.FLIP_ANGLE_THRESHOLD;
                if (wasFlippedAroundY) {
                    this.CompensatePositionToYRotation();
                }
                if (wasFlippedAroundX) {
                    this.CompensatePositionToXRotation();
                }

                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation start.*/
            /**
             * Compensates the position so that a child at the reference position remains in the same place,
             to counter any movement that occurred by rotation.
             *
             * @instance
             * @private
             * @this Spine.Unity.FollowSkeletonUtilityRootRotation
             * @memberof Spine.Unity.FollowSkeletonUtilityRootRotation
             * @return  {void}
             */
            CompensatePositionToYRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToYRotation", this ); }

                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.y = this.transform.position.y;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation start.*/
            /**
             * Compensates the position so that a child at the reference position remains in the same place,
             to counter any movement that occurred by rotation.
             *
             * @instance
             * @private
             * @this Spine.Unity.FollowSkeletonUtilityRootRotation
             * @memberof Spine.Unity.FollowSkeletonUtilityRootRotation
             * @return  {void}
             */
            CompensatePositionToXRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToXRotation", this ); }

                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.x = this.transform.position.x;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation end.*/


        }
    });
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    Bridge.define("Spine.Unity.ISpineComponentExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static start.*/
                IsNullOrDestroyed: function (component) {
if ( TRACE ) { TRACE( "Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed", this ); }

                    if (component == null) {
                        return true;
                    }
                    return Bridge.cast(component, UnityEngine.Object) == null;
                },
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static end.*/


            }
        }
    });
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    Bridge.define("Spine.Unity.MaterialsTextureLoader", {
        inherits: [Spine.TextureLoader],
        fields: {
            atlasAsset: null
        },
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        ctors: {
            ctor: function (atlasAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#ctor", this ); }

                this.$initialize();
                this.atlasAsset = atlasAsset;
            }
        },
        methods: {
            /*Spine.Unity.MaterialsTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Load", this ); }

                var $t;
                var name = System.IO.Path.GetFileNameWithoutExtension(path);
                var material = null;
                $t = Bridge.getEnumerator(this.atlasAsset.materials);
                try {
                    while ($t.moveNext()) {
                        var other = $t.Current;
                        if (other.mainTexture == null) {
                            UnityEngine.Debug.LogError$2("Material is missing texture: " + (other.name || ""), other);
                            return;
                        }
                        if (Bridge.referenceEquals(other.mainTexture.name, name)) {
                            material = other;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (material == null) {
                    UnityEngine.Debug.LogError$2("Material with texture name \"" + (name || "") + "\" not found for atlas asset: " + (this.atlasAsset.name || ""), this.atlasAsset);
                    return;
                }
                page.rendererObject = material;

                // Very old atlas files expected the texture's actual size to be used at runtime.
                if (page.width === 0 || page.height === 0) {
                    page.width = material.mainTexture.width;
                    page.height = material.mainTexture.height;
                }
            },
            /*Spine.Unity.MaterialsTextureLoader.Load end.*/

            /*Spine.Unity.MaterialsTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.MaterialsTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.MathUtilities start.*/
    Bridge.define("Spine.Unity.MathUtilities", {
        statics: {
            methods: {
                /*Spine.Unity.MathUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp", this ); }

                    return (value - a) / (b - a);
                },
                /*Spine.Unity.MathUtilities.InverseLerp:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$1:static start.*/
                /**
                 * Returns the linear interpolation ratio of <pre><code>a</code></pre> to <pre><code>b</code></pre> that <pre><code>value</code></pre> lies on.
                 This is the t value that fulfills <pre><code>value = lerp(a, b, t)</code></pre>.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MathUtilities
                 * @memberof Spine.Unity.MathUtilities
                 * @param   {UnityEngine.Vector2}    a        
                 * @param   {UnityEngine.Vector2}    b        
                 * @param   {UnityEngine.Vector2}    value
                 * @return  {UnityEngine.Vector2}
                 */
                InverseLerp$1: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp$1", this ); }

                    return new pc.Vec2( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$1:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$2:static start.*/
                /**
                 * Returns the linear interpolation ratio of <pre><code>a</code></pre> to <pre><code>b</code></pre> that <pre><code>value</code></pre> lies on.
                 This is the t value that fulfills <pre><code>value = lerp(a, b, t)</code></pre>.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MathUtilities
                 * @memberof Spine.Unity.MathUtilities
                 * @param   {UnityEngine.Vector3}    a        
                 * @param   {UnityEngine.Vector3}    b        
                 * @param   {UnityEngine.Vector3}    value
                 * @return  {UnityEngine.Vector3}
                 */
                InverseLerp$2: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp$2", this ); }

                    return new pc.Vec3( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y), (value.z - a.z) / (b.z - a.z) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$2:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$3:static start.*/
                /**
                 * Returns the linear interpolation ratio of <pre><code>a</code></pre> to <pre><code>b</code></pre> that <pre><code>value</code></pre> lies on.
                 This is the t value that fulfills <pre><code>value = lerp(a, b, t)</code></pre>.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MathUtilities
                 * @memberof Spine.Unity.MathUtilities
                 * @param   {UnityEngine.Vector4}    a        
                 * @param   {UnityEngine.Vector4}    b        
                 * @param   {UnityEngine.Vector4}    value
                 * @return  {UnityEngine.Vector4}
                 */
                InverseLerp$3: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp$3", this ); }

                    return new pc.Vec4( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y), (value.z - a.z) / (b.z - a.z), (value.w - a.w) / (b.w - a.w) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$3:static end.*/


            }
        }
    });
    /*Spine.Unity.MathUtilities end.*/

    /*Spine.Unity.MeshGenerator start.*/
    /**
     * Holds several methods to prepare and generate a UnityEngine mesh based on a skeleton. Contains buffers needed to perform the operation, and serializes settings for mesh generation.
     *
     * @public
     * @class Spine.Unity.MeshGenerator
     */
    Bridge.define("Spine.Unity.MeshGenerator", {
        statics: {
            fields: {
                BoundsMinDefault: 0,
                BoundsMaxDefault: 0,
                AttachmentVerts: null,
                AttachmentUVs: null,
                AttachmentColors32: null,
                AttachmentIndices: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                    this.BoundsMinDefault = Number.POSITIVE_INFINITY;
                    this.BoundsMaxDefault = Number.NEGATIVE_INFINITY;
                    this.AttachmentVerts = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                    this.AttachmentUVs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                    this.AttachmentColors32 = new (System.Collections.Generic.List$1(UnityEngine.Color32)).ctor();
                    this.AttachmentIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static start.*/
                /**
                 * A specialized variant of {@link }.
                 Generates renderer instructions using a single submesh, using only a single material and texture.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Spine.Unity.SkeletonRendererInstruction}    instructionOutput    The resulting instructions.
                 * @param   {Spine.Skeleton}                             skeleton             The skeleton to generate renderer instructions for.
                 * @param   {UnityEngine.Material}                       material             Material to be set at the renderer instruction. When null, the last attachment
                 in the draw order list is assigned as the instruction's material.
                 * @return  {void}
                 */
                GenerateSingleSubmeshInstruction: function (instructionOutput, skeleton, material) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction", this ); }

                    var $t;
                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;

                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t.startSlot = 0, $t.rawFirstVertexIndex = 0, $t.material = material, $t.forceSeparate = false, $t.endSlot = drawOrderCount, $t);

                    var rendererObject = null;
                    var skeletonHasClipping = false;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();

                        workingAttachmentsItems[i] = attachment;
                        var attachmentTriangleCount;
                        var attachmentVertexCount;

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.sequence != null) {
                                regionAttachment.sequence.apply(slot, regionAttachment);
                            }
                            rendererObject = regionAttachment.region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.sequence != null) {
                                    meshAttachment.sequence.apply(slot, meshAttachment);
                                }
                                rendererObject = meshAttachment.region;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                attachmentVertexCount = 0;
                                attachmentTriangleCount = 0;
                            }
                        }
                        current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                        current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                        totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                    }

                    if (material == null && rendererObject != null) {
                        current.material = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;

                    if (totalRawVertexCount > 0) {
                        workingSubmeshInstructions.Resize(1);
                        workingSubmeshInstructions.Items[0] = current.$clone();
                    } else {
                        workingSubmeshInstructions.Resize(0);
                    }
                },
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static start.*/
                RequiresMultipleSubmeshesByDrawOrder: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder", this ); }


                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;
                    var drawOrderItems = drawOrder.Items;

                    var lastRendererMaterial = null;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            continue;
                        }
                        var attachment = slot.getAttachment();
                        var rendererAttachment = Bridge.as(attachment, Spine.IHasTextureRegion);
                        if (rendererAttachment != null) {
                            if (rendererAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                rendererAttachment.Spine$IHasTextureRegion$Sequence.apply(slot, rendererAttachment);
                            }
                            var atlasRegion = Bridge.cast(rendererAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            var material = Bridge.cast(atlasRegion.page.rendererObject, UnityEngine.Material);
                            if (!Bridge.referenceEquals(lastRendererMaterial, material)) {
                                if (lastRendererMaterial != null) {
                                    return true;
                                }
                                lastRendererMaterial = material;
                            }
                        }
                    }
                    return false;
                },
                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static end.*/

                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static start.*/
                GenerateSkeletonRendererInstruction: function (instructionOutput, skeleton, customSlotMaterials, separatorSlots, generateMeshOverride, immutableTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction", this ); }

                    var $t;
                    if (immutableTriangles === void 0) { immutableTriangles = false; }
                    //			if (skeleton == null) throw new ArgumentNullException("skeleton");
                    //			if (instructionOutput == null) throw new ArgumentNullException("instructionOutput");

                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var skeletonHasClipping = false;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t);

                    var isCustomSlotMaterialsPopulated = customSlotMaterials != null && customSlotMaterials.Count > 0;

                    var separatorCount = separatorSlots == null ? 0 : separatorSlots.Count;
                    var hasSeparators = separatorCount > 0;

                    var clippingAttachmentSource = -1;
                    var lastPreActiveClipping = -1; // The index of the last slot that had an active ClippingAttachment.
                    var clippingEndSlot = null;
                    var submeshIndex = 0;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();
                        workingAttachmentsItems[i] = attachment;
                        var attachmentVertexCount = 0, attachmentTriangleCount = 0;

                        var region = null;
                        var noRender = false; // Using this allows empty slots as separators, and keeps separated parts more stable despite slots being reordered

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.sequence != null) {
                                regionAttachment.sequence.apply(slot, regionAttachment);
                            }
                            region = regionAttachment.region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.sequence != null) {
                                    meshAttachment.sequence.apply(slot, meshAttachment);
                                }
                                region = meshAttachment.region;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    clippingEndSlot = clippingAttachment.endSlot;
                                    clippingAttachmentSource = i;
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                noRender = true;
                            }
                        }

                        // Create a new SubmeshInstruction when material changes. (or when forced to separate by a submeshSeparator)
                        // Slot with a separator/new material will become the starting slot of the next new instruction.
                        if (hasSeparators) { //current.forceSeparate = hasSeparators && separatorSlots.Contains(slot);
                            current.forceSeparate = false;
                            for (var s = 0; s < separatorCount; s = (s + 1) | 0) {
                                if (Bridge.referenceEquals(slot, separatorSlots.getItem(s))) {
                                    current.forceSeparate = true;
                                    break;
                                }
                            }
                        }

                        if (noRender) {
                            if (current.forceSeparate && generateMeshOverride) { // && current.rawVertexCount > 0) {
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();

                                    submeshIndex = (submeshIndex + 1) | 0;
                                }

                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                        } else {
                            var material = { };
                            if (isCustomSlotMaterialsPopulated) {
                                if (!customSlotMaterials.tryGetValue(slot, material)) {
                                    material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                                }
                            } else {
                                material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                            }

                            if (current.forceSeparate || (current.rawVertexCount > 0 && !Bridge.referenceEquals(current.material, material.v))) { // Material changed. Add the previous submesh.
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                    submeshIndex = (submeshIndex + 1) | 0;
                                }
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }

                            // Update state for the next Attachment.
                            current.material = material.v;
                            current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                            current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                            current.rawFirstVertexIndex = totalRawVertexCount;
                            totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                        }

                        if (clippingEndSlot != null && Bridge.referenceEquals(slot.data, clippingEndSlot) && i !== clippingAttachmentSource) {
                            clippingEndSlot = null;
                            clippingAttachmentSource = -1;
                        }
                    }

                    if (current.rawVertexCount > 0) {
                        { // Add last or only submesh.
                            current.endSlot = drawOrderCount;
                            current.preActiveClippingSlotSource = lastPreActiveClipping;
                            current.forceSeparate = false;

                            workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                            workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                            //submeshIndex++;
                        }
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    instructionOutput.immutableTriangles = immutableTriangles;
                },
                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static start.*/
                TryReplaceMaterials: function (workingSubmeshInstructions, customMaterialOverride) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TryReplaceMaterials", this ); }

                    // Material overrides are done here so they can be applied per submesh instead of per slot
                    // but they will still be passed through the GenerateMeshOverride delegate,
                    // and will still go through the normal material match check step in STEP 3.
                    var wsii = workingSubmeshInstructions.Items;
                    for (var i = 0; i < workingSubmeshInstructions.Count; i = (i + 1) | 0) {
                        var material = wsii[i].material;
                        var overrideMaterial = { };
                        if (customMaterialOverride.tryGetValue(material, overrideMaterial)) {
                            wsii[i].material = overrideMaterial.v;
                        }
                    }
                },
                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static start.*/
                /**
                 * Step 1 of solving tangents. Ensure you have buffers of the correct size.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Vector4}    tangentBuffer         Eventual Vector4[] tangent buffer to assign to Mesh.tangents.
                 * @param   {UnityEngine.Vector2}    tempTanBuffer         Temporary Vector2 buffer for calculating directions.
                 * @param   {number}                 vertexCount           Number of vertices that require tangents (or the size of the vertex array)
                 * @param   {number}                 vertexBufferLength
                 * @return  {void}
                 */
                SolveTangents2DEnsureSize: function (tangentBuffer, tempTanBuffer, vertexCount, vertexBufferLength) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize", this ); }

                    if (tangentBuffer.v == null || tangentBuffer.v.length !== vertexBufferLength) {
                        tangentBuffer.v = System.Array.init(vertexBufferLength, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    }

                    if (tempTanBuffer.v == null || tempTanBuffer.v.length < Bridge.Int.mul(vertexCount, 2)) {
                        tempTanBuffer.v = System.Array.init(Bridge.Int.mul(vertexCount, 2), function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                    } // two arrays in one.
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static start.*/
                /**
                 * Step 2 of solving tangents. Fills (part of) a temporary tangent-solution buffer based on the vertices and uvs defined by a submesh's triangle buffer. Only needs to be called once for single-submesh meshes.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {Array.<number>}                 triangles        The mesh's current triangles buffer.
                 * @param   {number}                         triangleCount    The number of triangle indexes in the triangle array to be used.
                 * @param   {Array.<UnityEngine.Vector3>}    vertices         The mesh's current vertex position buffer.
                 * @param   {Array.<UnityEngine.Vector2>}    uvs              The mesh's current uvs buffer.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DTriangles: function (tempTanBuffer, triangles, triangleCount, vertices, uvs, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DTriangles", this ); }

                    var $t, $t1;
                    var sdir = new UnityEngine.Vector2();
                    var tdir = new UnityEngine.Vector2();
                    for (var t = 0; t < triangleCount; t = (t + 3) | 0) {
                        var i1 = triangles[((t + 0) | 0)];
                        var i2 = triangles[((t + 1) | 0)];
                        var i3 = triangles[((t + 2) | 0)];

                        var v1 = vertices[i1].$clone();
                        var v2 = vertices[i2].$clone();
                        var v3 = vertices[i3].$clone();

                        var w1 = uvs[i1].$clone();
                        var w2 = uvs[i2].$clone();
                        var w3 = uvs[i3].$clone();

                        var x1 = v2.x - v1.x;
                        var x2 = v3.x - v1.x;
                        var y1 = v2.y - v1.y;
                        var y2 = v3.y - v1.y;

                        var s1 = w2.x - w1.x;
                        var s2 = w3.x - w1.x;
                        var t1 = w2.y - w1.y;
                        var t2 = w3.y - w1.y;

                        var div = s1 * t2 - s2 * t1;
                        var r = (div === 0.0) ? 0.0 : 1.0 / div;

                        sdir.x = (t2 * x1 - t1 * x2) * r;
                        sdir.y = (t2 * y1 - t1 * y2) * r;
                        tempTanBuffer[i1] = ($t = (tempTanBuffer[i3] = sdir.$clone(), sdir.$clone()), tempTanBuffer[i2] = $t.$clone(), $t);

                        tdir.x = (s1 * x2 - s2 * x1) * r;
                        tdir.y = (s1 * y2 - s2 * y1) * r;
                        tempTanBuffer[((vertexCount + i1) | 0)] = ($t1 = (tempTanBuffer[((vertexCount + i3) | 0)] = tdir.$clone(), tdir.$clone()), tempTanBuffer[((vertexCount + i2) | 0)] = $t1.$clone(), $t1);
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static start.*/
                /**
                 * Step 3 of solving tangents. Fills a Vector4[] tangents array according to values calculated in step 2.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector4>}    tangents         A Vector4[] that will eventually be used to set Mesh.tangents
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DBuffer: function (tangents, tempTanBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DBuffer", this ); }

                    var tangent = new UnityEngine.Vector4();
                    tangent.z = 0;
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var t = tempTanBuffer[i].$clone();

                        // t.Normalize() (aggressively inlined). Even better if offloaded to GPU via vertex shader.
                        var magnitude = Math.sqrt(t.x * t.x + t.y * t.y);
                        if (magnitude > 1E-05) {
                            var reciprocalMagnitude = 1.0 / magnitude;
                            t.x *= reciprocalMagnitude;
                            t.y *= reciprocalMagnitude;
                        }

                        var t2 = tempTanBuffer[((vertexCount + i) | 0)].$clone();
                        tangent.x = t.x;
                        tangent.y = t.y;
                        //tangent.z = 0;
                        tangent.w = (t.y * t2.x > t.x * t2.y) ? 1 : -1; // 2D direction calculation. Used for binormals.
                        tangents[i] = tangent.$clone();
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static start.*/
                /**
                 * Fills mesh vertex data to render a RegionAttachment.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Mesh}          mesh                
                 * @param   {Spine.RegionAttachment}    regionAttachment
                 * @return  {void}
                 */
                FillMeshLocal$1: function (mesh, regionAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal$1", this ); }

                    if (mesh == null) {
                        return;
                    }
                    if (regionAttachment == null) {
                        return;
                    }

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    var offsets = regionAttachment.offset;
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[0], offsets[1], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[2], offsets[3], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[4], offsets[5], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[6], offsets[7], 0 ));

                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    var uvs = regionAttachment.uvs;
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[2], uvs[3] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[4], uvs[5] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[6], uvs[7] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[0], uvs[1] ));

                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( regionAttachment.color.r, regionAttachment.color.g, regionAttachment.color.b, regionAttachment.color.a )));
                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(System.Array.init([0, 2, 1, 0, 3, 2], System.Int32));

                    mesh.Clear();
                    mesh.name = regionAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal:static start.*/
                FillMeshLocal: function (mesh, meshAttachment, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal", this ); }

                    var $t;
                    if (mesh == null) {
                        return;
                    }
                    if (meshAttachment == null) {
                        return;
                    }
                    var vertexCount = (Bridge.Int.div(meshAttachment.worldVerticesLength, 2)) | 0;

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    if (Spine.SpineSkeletonExtensions.IsWeighted(meshAttachment)) {
                        var count = meshAttachment.worldVerticesLength;
                        var meshAttachmentBones = meshAttachment.bones;
                        var v = 0;

                        var vertices = meshAttachment.vertices;
                        for (var w = 0, b = 0; w < count; w = (w + 2) | 0) {
                            var wx = 0, wy = 0;
                            var n = meshAttachmentBones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                            n = (n + v) | 0;
                            for (; v < n; v = (v + 1) | 0, b = (b + 3) | 0) {
                                var bm = Spine.BoneMatrix.CalculateSetupWorld(($t = skeletonData.Bones.Items)[meshAttachmentBones[v]]);
                                var vx = vertices[b], vy = vertices[((b + 1) | 0)], weight = vertices[((b + 2) | 0)];
                                wx += (vx * bm.a + vy * bm.b + bm.x) * weight;
                                wy += (vx * bm.c + vy * bm.d + bm.y) * weight;
                            }
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( wx, wy, 0 ));
                        }
                    } else {
                        var localVerts = meshAttachment.vertices;
                        var pos = Bridge.getDefaultValue(UnityEngine.Vector3);
                        for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                            var ii = Bridge.Int.mul(i, 2);
                            pos.x = localVerts[ii];
                            pos.y = localVerts[((ii + 1) | 0)];
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(pos.$clone());
                        }
                    }

                    var uvs = meshAttachment.uvs;
                    var uv = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( meshAttachment.color.r, meshAttachment.color.g, meshAttachment.color.b, meshAttachment.color.a )));
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                        var ii1 = Bridge.Int.mul(i1, 2);
                        uv.x = uvs[ii1];
                        uv.y = uvs[((ii1 + 1) | 0)];
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(uv.$clone());

                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(meshAttachment.triangles);

                    mesh.Clear();
                    mesh.name = meshAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal:static end.*/


            }
        },
        fields: {
            settings: null,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            submeshes: null,
            meshBoundsMin: null,
            meshBoundsMax: null,
            meshBoundsThickness: 0,
            submeshIndex: 0,
            clipper: null,
            tempVerts: null,
            regionTriangles: null,
            normals: null,
            tangents: null,
            tempTanBuffer: null,
            uv2: null,
            uv3: null
        },
        props: {
            VertexCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#VertexCount#get", this ); }

                    return this.vertexBuffer.Count;
                }
            },
            /**
             * A set of mesh arrays whose values are modifiable by the user. Modify these values before they are passed to the UnityEngine mesh object in order to see the effect.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function Buffers
             * @type Spine.Unity.MeshGeneratorBuffers
             */
            Buffers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Buffers#get", this ); }

                    var $t;
                    return ($t = new Spine.Unity.MeshGeneratorBuffers(), $t.vertexCount = this.VertexCount, $t.vertexBuffer = this.vertexBuffer.Items, $t.uvBuffer = this.uvBuffer.Items, $t.colorBuffer = this.colorBuffer.Items, $t.meshGenerator = this, $t);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                this.settings = new Spine.Unity.MeshGenerator.Settings();
                this.meshBoundsMin = new UnityEngine.Vector2();
                this.meshBoundsMax = new UnityEngine.Vector2();
                this.settings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.vertexBuffer = new (Spine.ExposedList$1(UnityEngine.Vector3)).$ctor3(4);
                this.uvBuffer = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(4);
                this.colorBuffer = new (Spine.ExposedList$1(UnityEngine.Color32)).$ctor3(4);
                this.submeshes = function (_o1) {
                        _o1.Add(new (Spine.ExposedList$1(System.Int32)).$ctor3(6));
                        return _o1;
                    }(new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor());
                this.submeshIndex = 0;
                this.clipper = new Spine.SkeletonClipping();
                this.tempVerts = System.Array.init(8, 0, System.Single);
                this.regionTriangles = System.Array.init([
                    0, 
                    1, 
                    2, 
                    2, 
                    3, 
                    0
                ], System.Int32);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ctor", this ); }

                this.$initialize();
                this.submeshes.TrimExcess();
            }
        },
        methods: {
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount start.*/
            SubmeshIndexCount: function (submeshIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SubmeshIndexCount", this ); }

                var $t;
                return ($t = this.submeshes.Items)[submeshIndex].Count;
            },
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount end.*/

            /*Spine.Unity.MeshGenerator.Begin start.*/
            Begin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Begin", this ); }

                this.vertexBuffer.Clear(false);
                this.colorBuffer.Clear(false);
                this.uvBuffer.Clear(false);
                this.clipper.clipEnd();

                {
                    this.meshBoundsMin.x = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMin.y = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMax.x = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsMax.y = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsThickness = 0.0;
                }

                this.submeshIndex = 0;
                this.submeshes.Count = 1;
                //submeshes.Items[0].Clear(false);
            },
            /*Spine.Unity.MeshGenerator.Begin end.*/

            /*Spine.Unity.MeshGenerator.AddSubmesh start.*/
            AddSubmesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddSubmesh", this ); }

                var $t, $t1, $t2;
                if (updateTriangles === void 0) { updateTriangles = true; }
                var settings = this.settings.$clone();

                var newSubmeshCount = (this.submeshIndex + 1) | 0;
                if (this.submeshes.Items.length < newSubmeshCount) {
                    this.submeshes.Resize(newSubmeshCount);
                }
                this.submeshes.Count = newSubmeshCount;
                var submesh = ($t = this.submeshes.Items)[this.submeshIndex];
                if (submesh == null) {
                    ($t1 = this.submeshes.Items)[this.submeshIndex] = (submesh = new (Spine.ExposedList$1(System.Int32)).ctor());
                }
                submesh.Clear(false);

                var skeleton = instruction.skeleton;
                var drawOrderItems = skeleton.DrawOrder.Items;

                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var skeletonA = skeleton.color.a, skeletonR = skeleton.color.r, skeletonG = skeleton.color.g, skeletonB = skeleton.color.b;
                var meshBoundsMin = this.meshBoundsMin.$clone(), meshBoundsMax = this.meshBoundsMax.$clone();

                // Settings
                var zSpacing = settings.zSpacing;
                var pmaVertexColors = settings.pmaVertexColors;
                var tintBlack = settings.tintBlack;
                var useClipping = settings.useClipping && instruction.hasClipping;
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;

                if (useClipping) {
                    if (instruction.preActiveClippingSlotSource >= 0) {
                        var slot = drawOrderItems[instruction.preActiveClippingSlotSource];
                        this.clipper.clipStart(slot, Bridge.as(slot.getAttachment(), spine.ClippingAttachment));
                    }
                }

                for (var slotIndex = instruction.startSlot; slotIndex < instruction.endSlot; slotIndex = (slotIndex + 1) | 0) {
                    var slot1 = drawOrderItems[slotIndex];
                    if (!slot1.bone.isActive()) {
                        this.clipper.clipEndWithSlot( slot1 );
                        continue;
                    }
                    var attachment = slot1.getAttachment();
                    var z = zSpacing * slotIndex;

                    var workingVerts = this.tempVerts;
                    var uvs;
                    var attachmentTriangleIndices;
                    var attachmentVertexCount;
                    var attachmentIndexCount;

                    var c = Bridge.getDefaultValue(UnityEngine.Color);

                    // Identify and prepare values.
                    var region = Bridge.as(attachment, Spine.RegionAttachment);
                    if (region != null) {
                        region.computeWorldVertices(slot1, workingVerts, 0);
                        uvs = region.uvs;
                        attachmentTriangleIndices = this.regionTriangles;
                        c.r = region.color.r;
                        c.g = region.color.g;
                        c.b = region.color.b;
                        c.a = region.color.a;
                        attachmentVertexCount = 4;
                        attachmentIndexCount = 6;
                    } else {
                        var mesh = Bridge.as(attachment, Spine.MeshAttachment);
                        if (mesh != null) {
                            var meshVerticesLength = mesh.worldVerticesLength;
                            if (workingVerts.length < meshVerticesLength) {
                                workingVerts = System.Array.init(meshVerticesLength, 0, System.Single);
                                this.tempVerts = workingVerts;
                            }
                            mesh.computeWorldVertices( slot1, 0, meshVerticesLength, workingVerts, 0, 2 || 2 ); //meshAttachment.ComputeWorldVertices(slot, tempVerts);
                            uvs = mesh.uvs;
                            attachmentTriangleIndices = mesh.triangles;
                            c.r = mesh.color.r;
                            c.g = mesh.color.g;
                            c.b = mesh.color.b;
                            c.a = mesh.color.a;
                            attachmentVertexCount = meshVerticesLength >> 1; // meshVertexCount / 2;
                            attachmentIndexCount = mesh.triangles.length;
                        } else {
                            if (useClipping) {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    this.clipper.clipStart(slot1, clippingAttachment);
                                    continue;
                                }
                            }

                            // If not any renderable attachment.
                            this.clipper.clipEndWithSlot( slot1 );
                            continue;
                        }
                    }

                    var tintBlackAlpha = 1.0;
                    if (pmaVertexColors) {
                        var colorA = skeletonA * slot1.color.a * c.a;
                        color.a = Bridge.Int.clipu8(colorA * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * color.a);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * color.a);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * color.a);
                        if (slot1.data.blendMode === spine.BlendMode.Additive) {
                            if (canvasGroupTintBlack) {
                                tintBlackAlpha = 0;
                            } else {
                                color.a = 0;
                            }
                        } else if (canvasGroupTintBlack) { // other blend modes
                            tintBlackAlpha = colorA;
                        }
                    } else {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.color.a * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * 255);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * 255);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * 255);
                    }

                    if (useClipping && this.clipper.isClipping()) {
                        this.clipper.ClipTriangles(workingVerts, attachmentVertexCount << 1, attachmentTriangleIndices, attachmentIndexCount, uvs);
                        workingVerts = this.clipper.ClippedVertices.Items;
                        attachmentVertexCount = this.clipper.ClippedVertices.Count >> 1;
                        attachmentTriangleIndices = this.clipper.ClippedTriangles.Items;
                        attachmentIndexCount = this.clipper.ClippedTriangles.Count;
                        uvs = this.clipper.ClippedUVs.Items;
                    }

                    // Actually add slot/attachment data into buffers.
                    if (attachmentVertexCount !== 0 && attachmentIndexCount !== 0) {
                        if (tintBlack) {
                            var r2 = slot1.darkColor.r || 0;
                            var g2 = slot1.darkColor.g || 0;
                            var b2 = slot1.darkColor.b || 0;
                            if (pmaVertexColors) {
                                var alpha = skeletonA * slot1.color.a * c.a;
                                r2 *= alpha;
                                g2 *= alpha;
                                b2 *= alpha;
                            }
                            this.AddAttachmentTintBlack(r2, g2, b2, tintBlackAlpha, attachmentVertexCount);
                        }

                        //AddAttachment(workingVerts, uvs, color, attachmentTriangleIndices, attachmentVertexCount, attachmentIndexCount, ref meshBoundsMin, ref meshBoundsMax, z);
                        var ovc = this.vertexBuffer.Count;
                        // Add data to vertex buffers
                        {
                            var newVertexCount = (ovc + attachmentVertexCount) | 0;
                            var oldArraySize = this.vertexBuffer.Items.length;
                            if (newVertexCount > oldArraySize) {
                                var newArraySize = Bridge.Int.clip32(oldArraySize * 1.3);
                                if (newArraySize < newVertexCount) {
                                    newArraySize = newVertexCount;
                                }
                                System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                                }, UnityEngine.Vector3);
                                System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Color32);
                                }, UnityEngine.Color32);
                            }
                            this.vertexBuffer.Count = ($t2 = (this.colorBuffer.Count = newVertexCount, newVertexCount), this.uvBuffer.Count = $t2, $t2);
                        }

                        var vbi = this.vertexBuffer.Items;
                        var ubi = this.uvBuffer.Items;
                        var cbi = this.colorBuffer.Items;
                        if (ovc === 0) {
                            for (var i = 0; i < attachmentVertexCount; i = (i + 1) | 0) {
                                var vi = (ovc + i) | 0;
                                var i2 = i << 1; // i * 2
                                var x = workingVerts[i2];
                                var y = workingVerts[((i2 + 1) | 0)];

                                vbi[vi].x = x;
                                vbi[vi].y = y;
                                vbi[vi].z = z;
                                ubi[vi].x = uvs[i2];
                                ubi[vi].y = uvs[((i2 + 1) | 0)];
                                cbi[vi] = color.$clone();

                                // Calculate bounds.
                                if (x < meshBoundsMin.x) {
                                    meshBoundsMin.x = x;
                                }
                                if (x > meshBoundsMax.x) {
                                    meshBoundsMax.x = x;
                                }
                                if (y < meshBoundsMin.y) {
                                    meshBoundsMin.y = y;
                                }
                                if (y > meshBoundsMax.y) {
                                    meshBoundsMax.y = y;
                                }
                            }
                        } else {
                            for (var i1 = 0; i1 < attachmentVertexCount; i1 = (i1 + 1) | 0) {
                                var vi1 = (ovc + i1) | 0;
                                var i21 = i1 << 1; // i * 2
                                var x1 = workingVerts[i21];
                                var y1 = workingVerts[((i21 + 1) | 0)];

                                vbi[vi1].x = x1;
                                vbi[vi1].y = y1;
                                vbi[vi1].z = z;
                                ubi[vi1].x = uvs[i21];
                                ubi[vi1].y = uvs[((i21 + 1) | 0)];
                                cbi[vi1] = color.$clone();

                                // Calculate bounds.
                                if (x1 < meshBoundsMin.x) {
                                    meshBoundsMin.x = x1;
                                } else {
                                    if (x1 > meshBoundsMax.x) {
                                        meshBoundsMax.x = x1;
                                    }
                                }
                                if (y1 < meshBoundsMin.y) {
                                    meshBoundsMin.y = y1;
                                } else {
                                    if (y1 > meshBoundsMax.y) {
                                        meshBoundsMax.y = y1;
                                    }
                                }
                            }
                        }


                        // Add data to triangle buffer
                        if (updateTriangles) {
                            var oldTriangleCount = submesh.Count;
                            { //submesh.Resize(oldTriangleCount + attachmentIndexCount);
                                var newTriangleCount = (oldTriangleCount + attachmentIndexCount) | 0;
                                if (newTriangleCount > submesh.Items.length) {
                                    System.Array.resize(Bridge.ref(submesh, "Items"), newTriangleCount, 0, System.Int32);
                                }
                                submesh.Count = newTriangleCount;
                            }
                            var submeshItems = submesh.Items;
                            for (var i2 = 0; i2 < attachmentIndexCount; i2 = (i2 + 1) | 0) {
                                submeshItems[((oldTriangleCount + i2) | 0)] = (attachmentTriangleIndices[i2] + ovc) | 0;
                            }
                        }
                    }

                    this.clipper.clipEndWithSlot( slot1 );
                }
                this.clipper.clipEnd();

                this.meshBoundsMin = meshBoundsMin.$clone();
                this.meshBoundsMax = meshBoundsMax.$clone();
                this.meshBoundsThickness = instruction.endSlot * zSpacing;

                // Trim or zero submesh triangles.
                var currentSubmeshItems = submesh.Items;
                for (var i3 = submesh.Count, n = currentSubmeshItems.length; i3 < n; i3 = (i3 + 1) | 0) {
                    currentSubmeshItems[i3] = 0;
                }

                this.submeshIndex = (this.submeshIndex + 1) | 0; // Next AddSubmesh will use a new submeshIndex value.
            },
            /*Spine.Unity.MeshGenerator.AddSubmesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMesh start.*/
            BuildMesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMesh", this ); }

                var wsii = instruction.submeshInstructions.Items;
                for (var i = 0, n = instruction.submeshInstructions.Count; i < n; i = (i + 1) | 0) {
                    this.AddSubmesh(wsii[i].$clone(), updateTriangles);
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays start.*/
            BuildMeshWithArrays: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMeshWithArrays", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var settings = this.settings.$clone();
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;
                var totalVertexCount = instruction.rawVertexCount;

                // Add data to vertex buffers
                {
                    if (totalVertexCount > this.vertexBuffer.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                        System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Color32);
                        }, UnityEngine.Color32);
                    }
                    this.vertexBuffer.Count = ($t = (this.colorBuffer.Count = totalVertexCount, totalVertexCount), this.uvBuffer.Count = $t, $t);
                }

                // Populate Verts
                var color = Bridge.getDefaultValue(UnityEngine.Color32);

                var vertexIndex = 0;
                var tempVerts = this.tempVerts;
                var bmin = this.meshBoundsMin.$clone();
                var bmax = this.meshBoundsMax.$clone();

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var lastSlotIndex = 0;

                // drawOrder[endSlot] is excluded
                for (var si = 0, n = instruction.submeshInstructions.Count; si < n; si = (si + 1) | 0) {
                    var submesh = ($t1 = instruction.submeshInstructions.Items)[si].$clone();
                    var skeleton = submesh.skeleton;
                    var drawOrderItems = skeleton.DrawOrder.Items;
                    var a = skeleton.color.a, r = skeleton.color.r, g = skeleton.color.g, b = skeleton.color.b;

                    var endSlot = submesh.endSlot;
                    var startSlot = submesh.startSlot;
                    lastSlotIndex = endSlot;

                    if (settings.tintBlack) {
                        var rg = new UnityEngine.Vector2(), b2 = new UnityEngine.Vector2();
                        var vi = vertexIndex;
                        b2.y = 1.0;

                        {
                            if (this.uv2 == null) {
                                this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                                this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                            }
                            if (totalVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                            }
                            this.uv2.Count = (this.uv3.Count = totalVertexCount, totalVertexCount);
                        }

                        var uv2i = this.uv2.Items;
                        var uv3i = this.uv3.Items;

                        for (var slotIndex = startSlot; slotIndex < endSlot; slotIndex = (slotIndex + 1) | 0) {
                            var slot = drawOrderItems[slotIndex];
                            if (!slot.bone.isActive()) {
                                continue;
                            }
                            var attachment = slot.getAttachment();

                            rg.x = slot.darkColor.r || 0; //r
                            rg.y = slot.darkColor.g || 0; //g
                            b2.x = slot.darkColor.b || 0; //b
                            b2.y = 1.0;

                            var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                            if (regionAttachment != null) {
                                if (settings.pmaVertexColors) {
                                    var alpha = a * slot.color.a * regionAttachment.color.a;
                                    rg.x *= alpha;
                                    rg.y *= alpha;
                                    b2.x *= alpha;
                                    b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha;
                                }
                                uv2i[vi] = rg.$clone();
                                uv2i[((vi + 1) | 0)] = rg.$clone();
                                uv2i[((vi + 2) | 0)] = rg.$clone();
                                uv2i[((vi + 3) | 0)] = rg.$clone();
                                uv3i[vi] = b2.$clone();
                                uv3i[((vi + 1) | 0)] = b2.$clone();
                                uv3i[((vi + 2) | 0)] = b2.$clone();
                                uv3i[((vi + 3) | 0)] = b2.$clone();
                                vi = (vi + 4) | 0;
                            } else { //} if (settings.renderMeshes) {
                                var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                                if (meshAttachment != null) {
                                    if (settings.pmaVertexColors) {
                                        var alpha1 = a * slot.color.a * meshAttachment.color.a;
                                        rg.x *= alpha1;
                                        rg.y *= alpha1;
                                        b2.x *= alpha1;
                                        b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha1;
                                    }
                                    var verticesArrayLength = meshAttachment.worldVerticesLength;
                                    for (var iii = 0; iii < verticesArrayLength; iii = (iii + 2) | 0) {
                                        uv2i[vi] = rg.$clone();
                                        uv3i[vi] = b2.$clone();
                                        vi = (vi + 1) | 0;
                                    }
                                }
                            }
                        }
                    }

                    for (var slotIndex1 = startSlot; slotIndex1 < endSlot; slotIndex1 = (slotIndex1 + 1) | 0) {
                        var slot1 = drawOrderItems[slotIndex1];
                        if (!slot1.bone.isActive()) {
                            continue;
                        }
                        var attachment1 = slot1.getAttachment();
                        var z = slotIndex1 * settings.zSpacing;

                        var regionAttachment1 = Bridge.as(attachment1, Spine.RegionAttachment);
                        if (regionAttachment1 != null) {
                            regionAttachment1.computeWorldVertices(slot1, tempVerts, 0);

                            var x1 = tempVerts[0], y1 = tempVerts[1];
                            var x2 = tempVerts[2], y2 = tempVerts[3];
                            var x3 = tempVerts[4], y3 = tempVerts[5];
                            var x4 = tempVerts[6], y4 = tempVerts[7];
                            vbi[vertexIndex].x = x1;
                            vbi[vertexIndex].y = y1;
                            vbi[vertexIndex].z = z;
                            vbi[((vertexIndex + 1) | 0)].x = x4;
                            vbi[((vertexIndex + 1) | 0)].y = y4;
                            vbi[((vertexIndex + 1) | 0)].z = z;
                            vbi[((vertexIndex + 2) | 0)].x = x2;
                            vbi[((vertexIndex + 2) | 0)].y = y2;
                            vbi[((vertexIndex + 2) | 0)].z = z;
                            vbi[((vertexIndex + 3) | 0)].x = x3;
                            vbi[((vertexIndex + 3) | 0)].y = y3;
                            vbi[((vertexIndex + 3) | 0)].z = z;

                            if (settings.pmaVertexColors) {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * color.a);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * color.a);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * color.a);
                                if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                    color.a = 0;
                                }
                            } else {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * 255);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * 255);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * 255);
                            }

                            cbi[vertexIndex] = color.$clone();
                            cbi[((vertexIndex + 1) | 0)] = color.$clone();
                            cbi[((vertexIndex + 2) | 0)] = color.$clone();
                            cbi[((vertexIndex + 3) | 0)] = color.$clone();

                            var regionUVs = regionAttachment1.uvs;
                            ubi[vertexIndex].x = regionUVs[0];
                            ubi[vertexIndex].y = regionUVs[1];
                            ubi[((vertexIndex + 1) | 0)].x = regionUVs[6];
                            ubi[((vertexIndex + 1) | 0)].y = regionUVs[7];
                            ubi[((vertexIndex + 2) | 0)].x = regionUVs[2];
                            ubi[((vertexIndex + 2) | 0)].y = regionUVs[3];
                            ubi[((vertexIndex + 3) | 0)].x = regionUVs[4];
                            ubi[((vertexIndex + 3) | 0)].y = regionUVs[5];

                            if (x1 < bmin.x) {
                                bmin.x = x1;
                            } // Potential first attachment bounds initialization. Initial min should not block initial max. Same for Y below.
                            if (x1 > bmax.x) {
                                bmax.x = x1;
                            }
                            if (x2 < bmin.x) {
                                bmin.x = x2;
                            } else {
                                if (x2 > bmax.x) {
                                    bmax.x = x2;
                                }
                            }
                            if (x3 < bmin.x) {
                                bmin.x = x3;
                            } else {
                                if (x3 > bmax.x) {
                                    bmax.x = x3;
                                }
                            }
                            if (x4 < bmin.x) {
                                bmin.x = x4;
                            } else {
                                if (x4 > bmax.x) {
                                    bmax.x = x4;
                                }
                            }

                            if (y1 < bmin.y) {
                                bmin.y = y1;
                            }
                            if (y1 > bmax.y) {
                                bmax.y = y1;
                            }
                            if (y2 < bmin.y) {
                                bmin.y = y2;
                            } else {
                                if (y2 > bmax.y) {
                                    bmax.y = y2;
                                }
                            }
                            if (y3 < bmin.y) {
                                bmin.y = y3;
                            } else {
                                if (y3 > bmax.y) {
                                    bmax.y = y3;
                                }
                            }
                            if (y4 < bmin.y) {
                                bmin.y = y4;
                            } else {
                                if (y4 > bmax.y) {
                                    bmax.y = y4;
                                }
                            }

                            vertexIndex = (vertexIndex + 4) | 0;
                        } else { //if (settings.renderMeshes) {
                            var meshAttachment1 = Bridge.as(attachment1, Spine.MeshAttachment);
                            if (meshAttachment1 != null) {
                                var verticesArrayLength1 = meshAttachment1.worldVerticesLength;
                                if (tempVerts.length < verticesArrayLength1) {
                                    this.tempVerts = (tempVerts = System.Array.init(verticesArrayLength1, 0, System.Single));
                                }
                                meshAttachment1.computeWorldVertices( slot1, 0, meshAttachment1.worldVerticesLength, tempVerts, 0, 2 );

                                if (settings.pmaVertexColors) {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * color.a);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * color.a);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * color.a);
                                    if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                        color.a = 0;
                                    }
                                } else {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * 255);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * 255);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * 255);
                                }

                                var attachmentUVs = meshAttachment1.uvs;

                                // Potential first attachment bounds initialization. See conditions in RegionAttachment logic.
                                if (vertexIndex === 0) {
                                    // Initial min should not block initial max.
                                    // vi == vertexIndex does not always mean the bounds are fresh. It could be a submesh. Do not nuke old values by omitting the check.
                                    // Should know that this is the first attachment in the submesh. slotIndex == startSlot could be an empty slot.
                                    var fx = tempVerts[0], fy = tempVerts[1];
                                    if (fx < bmin.x) {
                                        bmin.x = fx;
                                    }
                                    if (fx > bmax.x) {
                                        bmax.x = fx;
                                    }
                                    if (fy < bmin.y) {
                                        bmin.y = fy;
                                    }
                                    if (fy > bmax.y) {
                                        bmax.y = fy;
                                    }
                                }

                                for (var iii1 = 0; iii1 < verticesArrayLength1; iii1 = (iii1 + 2) | 0) {
                                    var x = tempVerts[iii1], y = tempVerts[((iii1 + 1) | 0)];
                                    vbi[vertexIndex].x = x;
                                    vbi[vertexIndex].y = y;
                                    vbi[vertexIndex].z = z;
                                    cbi[vertexIndex] = color.$clone();
                                    ubi[vertexIndex].x = attachmentUVs[iii1];
                                    ubi[vertexIndex].y = attachmentUVs[((iii1 + 1) | 0)];

                                    if (x < bmin.x) {
                                        bmin.x = x;
                                    } else {
                                        if (x > bmax.x) {
                                            bmax.x = x;
                                        }
                                    }

                                    if (y < bmin.y) {
                                        bmin.y = y;
                                    } else {
                                        if (y > bmax.y) {
                                            bmax.y = y;
                                        }
                                    }

                                    vertexIndex = (vertexIndex + 1) | 0;
                                }
                            }
                        }
                    }
                }

                this.meshBoundsMin = bmin.$clone();
                this.meshBoundsMax = bmax.$clone();
                this.meshBoundsThickness = lastSlotIndex * settings.zSpacing;

                var submeshInstructionCount = instruction.submeshInstructions.Count;
                this.submeshes.Count = submeshInstructionCount;

                // Add triangles
                if (updateTriangles) {
                    // Match submesh buffers count with submeshInstruction count.
                    if (this.submeshes.Items.length < submeshInstructionCount) {
                        this.submeshes.Resize(submeshInstructionCount);
                        for (var i = 0, n1 = submeshInstructionCount; i < n1; i = (i + 1) | 0) {
                            var submeshBuffer = ($t2 = this.submeshes.Items)[i];
                            if (submeshBuffer == null) {
                                ($t3 = this.submeshes.Items)[i] = new (Spine.ExposedList$1(System.Int32)).ctor();
                            } else {
                                submeshBuffer.Clear(false);
                            }
                        }
                    }

                    var submeshInstructionsItems = instruction.submeshInstructions.Items; // This relies on the resize above.

                    // Fill the buffers.
                    var attachmentFirstVertex = 0;
                    for (var smbi = 0; smbi < submeshInstructionCount; smbi = (smbi + 1) | 0) {
                        var submeshInstruction = submeshInstructionsItems[smbi].$clone();
                        var currentSubmeshBuffer = ($t4 = this.submeshes.Items)[smbi];
                        { //submesh.Resize(submesh.rawTriangleCount);
                            var newTriangleCount = submeshInstruction.rawTriangleCount;
                            if (newTriangleCount > currentSubmeshBuffer.Items.length) {
                                System.Array.resize(Bridge.ref(currentSubmeshBuffer, "Items"), newTriangleCount, 0, System.Int32);
                            } else {
                                if (newTriangleCount < currentSubmeshBuffer.Items.length) {
                                    // Zero the extra.
                                    var sbi = currentSubmeshBuffer.Items;
                                    for (var ei = newTriangleCount, nn = sbi.length; ei < nn; ei = (ei + 1) | 0) {
                                        sbi[ei] = 0;
                                    }
                                }
                            }
                            currentSubmeshBuffer.Count = newTriangleCount;
                        }

                        var tris = currentSubmeshBuffer.Items;
                        var triangleIndex = 0;
                        var skeleton1 = submeshInstruction.skeleton;
                        var drawOrderItems1 = skeleton1.DrawOrder.Items;
                        for (var slotIndex2 = submeshInstruction.startSlot, endSlot1 = submeshInstruction.endSlot; slotIndex2 < endSlot1; slotIndex2 = (slotIndex2 + 1) | 0) {
                            var slot2 = drawOrderItems1[slotIndex2];
                            if (!slot2.bone.isActive()) {
                                continue;
                            }

                            var attachment2 = drawOrderItems1[slotIndex2].getAttachment();
                            if (Bridge.is(attachment2, Spine.RegionAttachment)) {
                                tris[triangleIndex] = attachmentFirstVertex;
                                tris[((triangleIndex + 1) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 2) | 0)] = (attachmentFirstVertex + 1) | 0;
                                tris[((triangleIndex + 3) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 4) | 0)] = (attachmentFirstVertex + 3) | 0;
                                tris[((triangleIndex + 5) | 0)] = (attachmentFirstVertex + 1) | 0;
                                triangleIndex = (triangleIndex + 6) | 0;
                                attachmentFirstVertex = (attachmentFirstVertex + 4) | 0;
                                continue;
                            }
                            var meshAttachment2 = Bridge.as(attachment2, Spine.MeshAttachment);
                            if (meshAttachment2 != null) {
                                var attachmentTriangles = meshAttachment2.triangles;
                                for (var ii = 0, nn1 = attachmentTriangles.length; ii < nn1; ii = (ii + 1) | 0, triangleIndex = (triangleIndex + 1) | 0) {
                                    tris[triangleIndex] = (attachmentFirstVertex + attachmentTriangles[ii]) | 0;
                                }
                                attachmentFirstVertex = (attachmentFirstVertex + (meshAttachment2.worldVerticesLength >> 1)) | 0; // length/2;
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays end.*/

            /*Spine.Unity.MeshGenerator.ScaleVertexData start.*/
            ScaleVertexData: function (scale) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ScaleVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                for (var i = 0, n = this.vertexBuffer.Count; i < n; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().clone().scale( scale ); // vbi[i].x *= scale; vbi[i].y *= scale;
                }

                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleVertexData end.*/

            /*Spine.Unity.MeshGenerator.GetMeshBounds start.*/
            GetMeshBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GetMeshBounds", this ); }

                var $t;
                if ((Math.abs(this.meshBoundsMin.x) === Number.POSITIVE_INFINITY)) { // meshBoundsMin.x == BoundsMinDefault // == doesn't work on float Infinity constants.
                    return new pc.BoundingBox.ctor();
                } else {
                    //mesh.bounds = ArraysMeshGenerator.ToBounds(meshBoundsMin, meshBoundsMax);
                    var halfWidth = (this.meshBoundsMax.x - this.meshBoundsMin.x) * 0.5;
                    var halfHeight = (this.meshBoundsMax.y - this.meshBoundsMin.y) * 0.5;
                    return ($t = new pc.BoundingBox.ctor(), $t.center = new pc.Vec3( this.meshBoundsMin.x + halfWidth, this.meshBoundsMin.y + halfHeight, 0 ), $t.halfExtents = new pc.Vec3( halfWidth, halfHeight, this.meshBoundsThickness * 0.5 ), $t);
                }
            },
            /*Spine.Unity.MeshGenerator.GetMeshBounds end.*/

            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack start.*/
            AddAttachmentTintBlack: function (r2, g2, b2, a, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddAttachmentTintBlack", this ); }

                var rg = new pc.Vec2( r2, g2 );
                var bo = new pc.Vec2( b2, a );

                var ovc = this.vertexBuffer.Count;
                var newVertexCount = (ovc + vertexCount) | 0;
                {
                    if (this.uv2 == null) {
                        this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                        this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                    }
                    if (newVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.uv2, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.uv3, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                    }
                    this.uv2.Count = (this.uv3.Count = newVertexCount, newVertexCount);
                }

                var uv2i = this.uv2.Items;
                var uv3i = this.uv3.Items;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    uv2i[((ovc + i) | 0)] = rg.$clone();
                    uv3i[((ovc + i) | 0)] = bo.$clone();
                }
            },
            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack end.*/

            /*Spine.Unity.MeshGenerator.FillVertexData start.*/
            FillVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var vbiLength = vbi.length;

                // Zero the extra.
                {
                    var listCount = this.vertexBuffer.Count;
                    var vector3zero = pc.Vec3.ZERO.clone();
                    for (var i = listCount; i < vbiLength; i = (i + 1) | 0) {
                        vbi[i] = vector3zero.$clone();
                    }
                }

                // Set the vertex buffer.
                {
                    mesh.vertices = vbi;
                    mesh.uv = ubi;
                    mesh.colors32 = cbi;
                    mesh.bounds = this.GetMeshBounds();
                }

                {
                    if (this.settings.addNormals) {
                        var oldLength = 0;

                        if (this.normals == null) {
                            this.normals = System.Array.init(vbiLength, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            oldLength = this.normals.length;
                        }

                        if (oldLength !== vbiLength) {
                            System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                            var localNormals = this.normals;
                            for (var i1 = oldLength; i1 < vbiLength; i1 = (i1 + 1) | 0) {
                                localNormals[i1] = new pc.Vec3( 0, 0, -1 );
                            }
                        }
                        mesh.normals = this.normals;
                    }

                    if (this.settings.tintBlack) {
                        if (this.uv2 != null) {
                            // Sometimes, the vertex buffer becomes smaller. We need to trim the size of the tint black buffers to match.
                            if (vbiLength !== this.uv2.Items.length) {
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                this.uv2.Count = (this.uv3.Count = vbiLength, vbiLength);
                            }
                            mesh.uv2 = this.uv2.Items;
                            mesh.uv3 = this.uv3.Items;
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.FillVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillLateVertexData start.*/
            FillLateVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillLateVertexData", this ); }

                if (this.settings.calculateTangents) {
                    var vertexCount = this.vertexBuffer.Count;
                    var sbi = this.submeshes.Items;
                    var submeshCount = this.submeshes.Count;
                    var vbi = this.vertexBuffer.Items;
                    var ubi = this.uvBuffer.Items;

                    Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(Bridge.ref(this, "tangents"), Bridge.ref(this, "tempTanBuffer"), vertexCount, vbi.length);
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var submesh = sbi[i].Items;
                        var triangleCount = sbi[i].Count;
                        Spine.Unity.MeshGenerator.SolveTangents2DTriangles(this.tempTanBuffer, submesh, triangleCount, vbi, ubi, vertexCount);
                    }
                    Spine.Unity.MeshGenerator.SolveTangents2DBuffer(this.tangents, this.tempTanBuffer, vertexCount);
                    mesh.tangents = this.tangents;
                }
            },
            /*Spine.Unity.MeshGenerator.FillLateVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillTriangles start.*/
            FillTriangles: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillTriangles", this ); }

                var submeshCount = this.submeshes.Count;
                var submeshesItems = this.submeshes.Items;
                mesh.subMeshCount = submeshCount;

                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    mesh.SetTriangles$4(submeshesItems[i].Items, 0, submeshesItems[i].Count, i, false);
                }
            },
            /*Spine.Unity.MeshGenerator.FillTriangles end.*/

            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity start.*/
            EnsureVertexCapacity: function (minimumVertexCount, inlcudeTintBlack, includeTangents, includeNormals) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#EnsureVertexCapacity", this ); }

                if (inlcudeTintBlack === void 0) { inlcudeTintBlack = false; }
                if (includeTangents === void 0) { includeTangents = false; }
                if (includeNormals === void 0) { includeNormals = false; }
                if (minimumVertexCount > this.vertexBuffer.Items.length) {
                    System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                    System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Color32);
                    }, UnityEngine.Color32);

                    if (inlcudeTintBlack) {
                        if (this.uv2 == null) {
                            this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                            this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                        }
                        this.uv2.Resize(minimumVertexCount);
                        this.uv3.Resize(minimumVertexCount);
                    }

                    if (includeNormals) {
                        if (this.normals == null) {
                            this.normals = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            System.Array.resize(Bridge.ref(this, "normals"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                        }

                    }

                    if (includeTangents) {
                        if (this.tangents == null) {
                            this.tangents = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector4();
                            }, UnityEngine.Vector4);
                        } else {
                            System.Array.resize(Bridge.ref(this, "tangents"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector4);
                            }, UnityEngine.Vector4);
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity end.*/

            /*Spine.Unity.MeshGenerator.TrimExcess start.*/
            /**
             * Trims internal buffers to reduce the resulting mesh data stream size.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshGenerator
             * @memberof Spine.Unity.MeshGenerator
             * @return  {void}
             */
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TrimExcess", this ); }

                this.vertexBuffer.TrimExcess();
                this.uvBuffer.TrimExcess();
                this.colorBuffer.TrimExcess();

                if (this.uv2 != null) {
                    this.uv2.TrimExcess();
                }
                if (this.uv3 != null) {
                    this.uv3.TrimExcess();
                }

                var vbiLength = this.vertexBuffer.Items.length;
                if (this.normals != null) {
                    System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                }
                if (this.tangents != null) {
                    System.Array.resize(Bridge.ref(this, "tangents"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector4);
                    }, UnityEngine.Vector4);
                }
            },
            /*Spine.Unity.MeshGenerator.TrimExcess end.*/


        }
    });
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    Bridge.define("Spine.Unity.MeshGenerator.Settings", {
        $kind: 1004,
        statics: {
            props: {
                Default: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#Default#get", this ); }

                        var $t;
                        return ($t = new Spine.Unity.MeshGenerator.Settings(), $t.pmaVertexColors = true, $t.zSpacing = 0.0, $t.useClipping = true, $t.tintBlack = false, $t.calculateTangents = false, $t.addNormals = false, $t.immutableTriangles = false, $t);
                    }
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getDefaultValue", this ); }
 return new Spine.Unity.MeshGenerator.Settings(); }
            }
        },
        fields: {
            useClipping: false,
            zSpacing: 0,
            pmaVertexColors: false,
            tintBlack: false,
            canvasGroupTintBlack: false,
            calculateTangents: false,
            addNormals: false,
            immutableTriangles: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getHashCode", this ); }

                var h = Bridge.addHash([3889943484, this.useClipping, this.zSpacing, this.pmaVertexColors, this.tintBlack, this.canvasGroupTintBlack, this.calculateTangents, this.addNormals, this.immutableTriangles]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGenerator.Settings)) {
                    return false;
                }
                return Bridge.equals(this.useClipping, o.useClipping) && Bridge.equals(this.zSpacing, o.zSpacing) && Bridge.equals(this.pmaVertexColors, o.pmaVertexColors) && Bridge.equals(this.tintBlack, o.tintBlack) && Bridge.equals(this.canvasGroupTintBlack, o.canvasGroupTintBlack) && Bridge.equals(this.calculateTangents, o.calculateTangents) && Bridge.equals(this.addNormals, o.addNormals) && Bridge.equals(this.immutableTriangles, o.immutableTriangles);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#$clone", this ); }

                var s = to || new Spine.Unity.MeshGenerator.Settings();
                s.useClipping = this.useClipping;
                s.zSpacing = this.zSpacing;
                s.pmaVertexColors = this.pmaVertexColors;
                s.tintBlack = this.tintBlack;
                s.canvasGroupTintBlack = this.canvasGroupTintBlack;
                s.calculateTangents = this.calculateTangents;
                s.addNormals = this.addNormals;
                s.immutableTriangles = this.immutableTriangles;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    Bridge.define("Spine.Unity.MeshGeneratorBuffers", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getDefaultValue", this ); }
 return new Spine.Unity.MeshGeneratorBuffers(); }
            }
        },
        fields: {
            /**
             * The vertex count that will actually be used for the mesh. The Lengths of the buffer arrays may be larger than this number.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type number
             */
            vertexCount: 0,
            /**
             * Vertex positions. To be used for UnityEngine.Mesh.vertices.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector3>
             */
            vertexBuffer: null,
            /**
             * Vertex UVs. To be used for UnityEngine.Mesh.uvs.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector2>
             */
            uvBuffer: null,
            /**
             * Vertex colors. To be used for UnityEngine.Mesh.colors32.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Color32>
             */
            colorBuffer: null,
            /**
             * The Spine rendering component's MeshGenerator.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Spine.Unity.MeshGenerator
             */
            meshGenerator: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getHashCode", this ); }

                var h = Bridge.addHash([8979862494, this.vertexCount, this.vertexBuffer, this.uvBuffer, this.colorBuffer, this.meshGenerator]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGeneratorBuffers)) {
                    return false;
                }
                return Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertexBuffer, o.vertexBuffer) && Bridge.equals(this.uvBuffer, o.uvBuffer) && Bridge.equals(this.colorBuffer, o.colorBuffer) && Bridge.equals(this.meshGenerator, o.meshGenerator);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#$clone", this ); }

                var s = to || new Spine.Unity.MeshGeneratorBuffers();
                s.vertexCount = this.vertexCount;
                s.vertexBuffer = this.vertexBuffer;
                s.uvBuffer = this.uvBuffer;
                s.colorBuffer = this.colorBuffer;
                s.meshGenerator = this.meshGenerator;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    /**
     * A double-buffered Mesh, and a shared material array, bundled for use by Spine components that need to push a Mesh and materials to a Unity MeshRenderer and MeshFilter.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers", {
        inherits: [System.IDisposable],
        fields: {
            doubleBufferedMesh: null,
            submeshMaterials: null,
            sharedMaterials: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#init", this ); }

                this.submeshMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Initialize", this ); }

                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.submeshMaterials.Clear();
                } else {
                    this.doubleBufferedMesh = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Initialize end.*/

            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray start.*/
            /**
             * Returns a sharedMaterials array for use on a MeshRenderer.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {Array.<UnityEngine.Material>}
             */
            GetUpdatedSharedMaterialsArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray", this ); }

                if (this.submeshMaterials.Count === this.sharedMaterials.length) {
                    this.submeshMaterials.CopyTo(this.sharedMaterials);
                } else {
                    this.sharedMaterials = this.submeshMaterials.ToArray();
                }

                return this.sharedMaterials;
            },
            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray end.*/

            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate start.*/
            /**
             * Returns true if the materials were modified since the buffers were last updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {boolean}
             */
            MaterialsChangedInLastUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate", this ); }

                var newSubmeshMaterials = this.submeshMaterials.Count;
                var sharedMaterials = this.sharedMaterials;
                if (newSubmeshMaterials !== sharedMaterials.length) {
                    return true;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                for (var i = 0; i < newSubmeshMaterials; i = (i + 1) | 0) {
                    if (!Bridge.referenceEquals(submeshMaterialsItems[i], sharedMaterials[i])) {
                        return true;
                    }
                } //if (submeshMaterialsItems[i].GetInstanceID() != sharedMaterials[i].GetInstanceID()) return true;

                return false;
            },
            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate end.*/

            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials start.*/
            /**
             * Updates the internal shared materials array with the given instruction list.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @param   {Spine.ExposedList$1}    instructions
             * @return  {void}
             */
            UpdateSharedMaterials: function (instructions) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials", this ); }

                var newSize = instructions.Count;
                { //submeshMaterials.Resize(instructions.Count);
                    if (newSize > this.submeshMaterials.Items.length) {
                        System.Array.resize(Bridge.ref(this.submeshMaterials, "Items"), newSize, null, UnityEngine.Material);
                    }
                    this.submeshMaterials.Count = newSize;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < newSize; i = (i + 1) | 0) {
                    submeshMaterialsItems[i] = instructionsItems[i].material;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials end.*/

            /*Spine.Unity.MeshRendererBuffers.GetNextMesh start.*/
            GetNextMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetNextMesh", this ); }

                return this.doubleBufferedMesh.GetNext();
            },
            /*Spine.Unity.MeshRendererBuffers.GetNextMesh end.*/

            /*Spine.Unity.MeshRendererBuffers.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Clear", this ); }

                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
                this.submeshMaterials.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Dispose", this ); }

                if (this.doubleBufferedMesh == null) {
                    return;
                }
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    /**
     * This is a Mesh that also stores the instructions SkeletonRenderer generated for it.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers.SmartMesh
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers.SmartMesh", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            mesh: null,
            instructionUsed: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#init", this ); }

                this.mesh = Spine.Unity.SpineMesh.NewSkeletonMesh();
                this.instructionUsed = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Clear", this ); }

                this.mesh.Clear();
                this.instructionUsed.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose", this ); }

                if (this.mesh != null) {
                    UnityEngine.Object.Destroy(this.mesh);
                }
                this.mesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    Bridge.define("Spine.Unity.NoOpTextureLoader", {
        inherits: [Spine.TextureLoader],
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        methods: {
            /*Spine.Unity.NoOpTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Load", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Load end.*/

            /*Spine.Unity.NoOpTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    Bridge.define("Spine.Unity.RegionlessAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        statics: {
            fields: {
                emptyRegion: null
            },
            props: {
                EmptyRegion: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get", this ); }

                        var $t, $t1, $t2;
                        if (Spine.Unity.RegionlessAttachmentLoader.emptyRegion == null) {
                            Spine.Unity.RegionlessAttachmentLoader.emptyRegion = ($t = new Spine.AtlasRegion(), $t.name = "Empty AtlasRegion", $t.page = ($t1 = new Spine.AtlasPage(), $t1.name = "Empty AtlasPage", $t1.rendererObject = ($t2 = new UnityEngine.Material.$ctor2(UnityEngine.Shader.Find("Spine/Special/HiddenPass")), $t2.name = "NoRender Material", $t2), $t1), $t);
                        }
                        return Spine.Unity.RegionlessAttachmentLoader.emptyRegion;
                    }
                }
            }
        },
        alias: [
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        methods: {
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.RegionAttachment(name), $t.region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.MeshAttachment(name), $t.region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new spine.BoundingBoxAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment", this ); }

                return new spine.PathAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment", this ); }

                return new spine.PointAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment", this ); }

                return new spine.ClippingAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment end.*/


        }
    });
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SettingsTriState start.*/
    /**
     * TriState enum which can be used to replace and extend a bool variable by
     a third <pre><code>UseGlobalSettings</code></pre> state. Automatically maps serialized
     bool values to corresponding <pre><code>Disable</code></pre> and <pre><code>Enable</code></pre> states.
     *
     * @public
     * @class Spine.Unity.SettingsTriState
     */
    Bridge.define("Spine.Unity.SettingsTriState", {
        $kind: 6,
        statics: {
            fields: {
                Disable: 0,
                Enable: 1,
                UseGlobalSetting: 2
            }
        }
    });
    /*Spine.Unity.SettingsTriState end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}            skeletonDataFile    
                 * @param   {Spine.Unity.AtlasAssetBase}       atlasAsset          
                 * @param   {boolean}                          initialize          
                 * @param   {number}                           scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance: function (skeletonDataFile, atlasAsset, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1(skeletonDataFile, System.Array.init([atlasAsset], Spine.Unity.AtlasAssetBase), initialize, scale);
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}                 skeletonDataFile    
                 * @param   {Array.<Spine.Unity.AtlasAssetBase>}    atlasAssets         
                 * @param   {boolean}                               initialize          
                 * @param   {number}                                scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance$1: function (skeletonDataFile, atlasAssets, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    var skeletonDataAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SkeletonDataAsset);
                    skeletonDataAsset.Clear();
                    skeletonDataAsset.skeletonJSON = skeletonDataFile;
                    skeletonDataAsset.atlasAssets = atlasAssets;
                    skeletonDataAsset.scale = scale;

                    if (initialize) {
                        skeletonDataAsset.GetSkeletonData(true);
                    }

                    return skeletonDataAsset;
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static start.*/
                ReadSkeletonData: function (bytes, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData", this ); }

                    var $t;
                    var input = new System.IO.MemoryStream.$ctor1(bytes);
                    try {
                        var binary = ($t = new Spine.SkeletonBinary(attachmentLoader), $t.scale = scale, $t);
                        return binary.ReadSkeletonData(input);
                    }
                    finally {
                        if (Bridge.hasValue(input)) {
                            input.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static start.*/
                ReadSkeletonData$1: function (text, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1", this ); }

                    var $t;
                    var input = new System.IO.StringReader(text);
                    var json = ($t = new Spine.SkeletonJson(attachmentLoader), $t.scale = scale, $t);
                    return json.ReadSkeletonData(input);
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static end.*/


            }
        },
        fields: {
            atlasAssets: null,
            scale: 0,
            skeletonJSON: null,
            isUpgradingBlendModeMaterials: false,
            blendModeMaterials: null,
            skeletonDataModifiers: null,
            fromAnimation: null,
            toAnimation: null,
            duration: null,
            defaultMix: 0,
            controller: null,
            skeletonData: null,
            stateData: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#IsLoaded#get", this ); }

                    return this.skeletonData != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#init", this ); }

                this.atlasAssets = System.Array.init(0, null, Spine.Unity.AtlasAssetBase);
                this.scale = 0.01;
                this.isUpgradingBlendModeMaterials = false;
                this.blendModeMaterials = new Spine.Unity.BlendModeMaterials();
                this.skeletonDataModifiers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataModifierAsset)).ctor();
                this.fromAnimation = System.Array.init(0, null, System.String);
                this.toAnimation = System.Array.init(0, null, System.String);
                this.duration = System.Array.init(0, 0, System.Single);
            }
        },
        methods: {
            /*Spine.Unity.SkeletonDataAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SkeletonDataAsset.Reset end.*/

            /*Spine.Unity.SkeletonDataAsset.Clear start.*/
            /**
             * Clears the loaded SkeletonData and AnimationStateData. Use this to force a reload for the next time GetSkeletonData is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Clear", this ); }

                this.skeletonData = null;
                this.stateData = null;
            },
            /*Spine.Unity.SkeletonDataAsset.Clear end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData start.*/
            GetAnimationStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAnimationStateData", this ); }

                if (this.stateData != null) {
                    return this.stateData;
                }
                this.GetSkeletonData(false);
                return this.stateData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData start.*/
            /**
             * Loads, caches and returns the SkeletonData from the skeleton data file. Returns the cached SkeletonData after the first time it is called. Pass false to prevent direct errors from being logged.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @param   {boolean}               quiet
             * @return  {Spine.SkeletonData}
             */
            GetSkeletonData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetSkeletonData", this ); }

                var $t;
                if (this.skeletonJSON == null) {
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Skeleton JSON file not set for SkeletonData asset: " + (this.name || ""), this);
                    }
                    this.Clear();
                    return null;
                }

                // Disabled to support attachmentless/skinless SkeletonData.
                //			if (atlasAssets == null) {
                //				atlasAssets = new AtlasAsset[0];
                //				if (!quiet)
                //					Debug.LogError("Atlas not set for SkeletonData asset: " + name, this);
                //				Clear();
                //				return null;
                //			}
                //			#if !SPINE_TK2D
                //			if (atlasAssets.Length == 0) {
                //				Clear();
                //				return null;
                //			}
                //			#else
                //			if (atlasAssets.Length == 0 && spriteCollection == null) {
                //				Clear();
                //				return null;
                //			}
                //			#endif

                if (this.skeletonData != null) {
                    return this.skeletonData;
                }

                var attachmentLoader;
                var skeletonDataScale;
                var atlasArray = this.GetAtlasArray();

                attachmentLoader = (atlasArray.length === 0) ? Bridge.cast(new Spine.Unity.RegionlessAttachmentLoader(), Spine.AttachmentLoader) : Bridge.cast(new Spine.AtlasAttachmentLoader(atlasArray), Spine.AttachmentLoader);
                skeletonDataScale = this.scale;

                var hasBinaryExtension = System.String.contains(this.skeletonJSON.name.toLowerCase(),".skel");
                var loadedSkeletonData = null;

                try {
                    if (hasBinaryExtension) {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData(this.skeletonJSON.bytes, attachmentLoader, skeletonDataScale);
                    } else {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1(this.skeletonJSON.text, attachmentLoader, skeletonDataScale);
                    }
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Error reading skeleton JSON file for SkeletonData asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this.skeletonJSON);
                    }
                }

                if (loadedSkeletonData == null) {
                    return null;
                }

                if (this.skeletonDataModifiers != null) {
                    $t = Bridge.getEnumerator(this.skeletonDataModifiers);
                    try {
                        while ($t.moveNext()) {
                            var modifier = $t.Current;
                            if (modifier != null && !(this.isUpgradingBlendModeMaterials && Bridge.is(modifier, Spine.Unity.BlendModeMaterialsAsset))) {
                                modifier.Apply(loadedSkeletonData);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (!this.isUpgradingBlendModeMaterials) {
                    this.blendModeMaterials.ApplyMaterials(loadedSkeletonData);
                }

                this.InitializeWithData(loadedSkeletonData);

                return this.skeletonData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData end.*/

            /*Spine.Unity.SkeletonDataAsset.InitializeWithData start.*/
            InitializeWithData: function (sd) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#InitializeWithData", this ); }

                this.skeletonData = sd;
                this.stateData = new spine.AnimationStateData( this.skeletonData );
                this.FillStateData();
            },
            /*Spine.Unity.SkeletonDataAsset.InitializeWithData end.*/

            /*Spine.Unity.SkeletonDataAsset.FillStateData start.*/
            FillStateData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#FillStateData", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.stateData != null) {
                    this.stateData.defaultMix = this.defaultMix;

                    for (var i = 0, n = this.fromAnimation.length; i < n; i = (i + 1) | 0) {
                        var fromAnimationName = this.fromAnimation[i];
                        var toAnimationName = this.toAnimation[i];
                        if (fromAnimationName.length === 0 || toAnimationName.length === 0) {
                            continue;
                        }
                        this.stateData.setMix(fromAnimationName, toAnimationName, this.duration[i]);
                    }
                }
            },
            /*Spine.Unity.SkeletonDataAsset.FillStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray start.*/
            GetAtlasArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAtlasArray", this ); }

                var returnList = new (System.Collections.Generic.List$1(Spine.Atlas)).$ctor2(this.atlasAssets.length);
                for (var i = 0; i < this.atlasAssets.length; i = (i + 1) | 0) {
                    var aa = this.atlasAssets[i];
                    if (aa == null) {
                        continue;
                    }
                    var a = aa.GetAtlas();
                    if (a == null) {
                        continue;
                    }
                    returnList.add(a);
                }
                return returnList.ToArray();
            },
            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray end.*/


        }
    });
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility");
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", {
        $kind: 1002,
        fields: {
            actualVersion: null,
            compatibleVersions: null,
            explicitProblemDescription: null
        },
        methods: {
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString start.*/
            DescriptionString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString", this ); }

                var $t, $t1, $t2;
                if (!System.String.isNullOrEmpty(this.explicitProblemDescription)) {
                    return this.explicitProblemDescription;
                }

                var compatibleVersionString = "";
                var optionalOr = null;
                $t = Bridge.getEnumerator(this.compatibleVersions);
                try {
                    while ($t.moveNext()) {
                        var version = $t.Current;
                        compatibleVersionString = (compatibleVersionString || "") + ((System.String.format("{0}{1}.{2}", optionalOr, Bridge.box(version[0], System.Int32), Bridge.box(version[1], System.Int32))) || "");
                        optionalOr = " or ";
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return System.String.format("Skeleton data could not be loaded. Data version: {0}. Required version: {1}.\nPlease re-export skeleton data with Spine {1} or change runtime to version {2}.{3}.", this.actualVersion.rawVersion, compatibleVersionString, Bridge.box(($t1 = this.actualVersion.version)[0], System.Int32), Bridge.box(($t2 = this.actualVersion.version)[1], System.Int32));
            },
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString end.*/


        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.SourceType", {
        $kind: 1006,
        statics: {
            fields: {
                Json: 0,
                Binary: 1
            }
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.VersionInfo", {
        $kind: 1002,
        fields: {
            rawVersion: null,
            version: null,
            sourceType: 0
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    Bridge.define("Spine.Unity.SkeletonExtensions", {
        statics: {
            fields: {
                ByteToFloat: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#init", this ); }

                    this.ByteToFloat = 0.003921569;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static start.*/
                GetColor$2: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$2", this ); }

                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$1:static start.*/
                GetColor$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$1", this ); }

                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor:static start.*/
                GetColor: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor", this ); }

                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$3:static start.*/
                GetColor$3: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$3", this ); }

                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static start.*/
                GetColorTintBlack: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColorTintBlack", this ); }

                    return new pc.Color( s.darkColor.r || 0, s.darkColor.g || 0, s.darkColor.b || 0, 1.0 );
                },
                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$4:static start.*/
                SetColor$4: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$4", this ); }

                    skeleton.color.a = color.a;
                    skeleton.color.r = color.r;
                    skeleton.color.g = color.g;
                    skeleton.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$5:static start.*/
                SetColor$5: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$5", this ); }

                    skeleton.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$5:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$6:static start.*/
                SetColor$6: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$6", this ); }

                    slot.color.a = color.a;
                    slot.color.r = color.r;
                    slot.color.g = color.g;
                    slot.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$6:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$7:static start.*/
                SetColor$7: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$7", this ); }

                    slot.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$7:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$2:static start.*/
                SetColor$2: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$2", this ); }

                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$3:static start.*/
                SetColor$3: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$3", this ); }

                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor:static start.*/
                SetColor: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor", this ); }

                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$1:static start.*/
                SetColor$1: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$1", this ); }

                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static start.*/
                /**
                 * Sets the Skeleton's local scale using a UnityEngine.Vector2. If only individual components need to be set, set Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton    
                 * @param   {UnityEngine.Vector2}    scale
                 * @return  {void}
                 */
                SetLocalScale: function (skeleton, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalScale", this ); }

                    skeleton.scaleX = scale.x;
                    skeleton.scaleY = scale.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static start.*/
                /**
                 * Gets the internal bone matrix as a Unity bonespace-to-skeletonspace transformation matrix.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone
                 * @return  {UnityEngine.Matrix4x4}
                 */
                GetMatrix4x4: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMatrix4x4", this ); }

                    var $t;
                    return ($t = new pc.Mat4.ctor(), $t.e00 = bone.a, $t.e01 = bone.b, $t.e03 = bone.worldX, $t.e10 = bone.c, $t.e11 = bone.d, $t.e13 = bone.worldY, $t.e33 = 1, $t);
                },
                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector2
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector2}    position
                 * @return  {void}
                 */
                SetLocalPosition: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition", this ); }

                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector3. The z component is ignored.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector3}    position
                 * @return  {void}
                 */
                SetLocalPosition$1: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition$1", this ); }

                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static start.*/
                /**
                 * Gets the bone's local X and Y as a Vector2.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalPosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalPosition", this ); }

                    return new pc.Vec2( bone.x, bone.y );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static start.*/
                /**
                 * Gets the position of the bone in Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition", this ); }

                    return new pc.Vec2( bone.worldX, bone.worldY );
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static start.*/
                /**
                 * Gets a local offset from the bone and converts it into Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone         
                 * @param   {UnityEngine.Vector2}    boneLocal
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition$1: function (bone, boneLocal) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.LocalToWorld(boneLocal.x, boneLocal.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static start.*/
                /**
                 * Gets the bone's Unity World position using its Spine GameObject Transform. UpdateWorldTransform needs to have been called for this to return the correct, updated value.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition: function (bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX, bone.worldY, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static start.*/
                GetWorldPosition$1: function (bone, spineGameObjectTransform, positionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$1", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX * positionScale, bone.worldY * positionScale, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Slot}               slot                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$3: function (attachment, slot, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$3", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(slot.bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$2: function (attachment, bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$2", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static start.*/
                /**
                 * Gets a skeleton space UnityEngine.Quaternion representation of bone.WorldRotationX.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetQuaternion", this ); }

                    var halfRotation = Math.atan2(bone.c, bone.a) * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static start.*/
                /**
                 * Gets a bone-local space UnityEngine.Quaternion representation of bone.rotation.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetLocalQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalQuaternion", this ); }

                    var halfRotation = bone.rotation * UnityEngine.Mathf.Deg2Rad * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static start.*/
                /**
                 * Returns the Skeleton's local scale as a UnityEngine.Vector2. If only individual components are needed, use Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalScale: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalScale", this ); }

                    return new pc.Vec2( skeleton.scaleX, skeleton.scaleY );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static start.*/
                /**
                 * Calculates a 2x2 Transformation Matrix that can convert a skeleton-space position to a bone-local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}       bone    
                 * @param   {System.Single}    ia      
                 * @param   {System.Single}    ib      
                 * @param   {System.Single}    ic      
                 * @param   {System.Single}    id
                 * @return  {void}
                 */
                GetWorldToLocalMatrix: function (bone, ia, ib, ic, id) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix", this ); }

                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    var invDet = 1 / (a * d - b * c);
                    ia.v = invDet * d;
                    ib.v = invDet * -b;
                    ic.v = invDet * -c;
                    id.v = invDet * a;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static end.*/

                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static start.*/
                /**
                 * UnityEngine.Vector2 override of Bone.WorldToLocal. This converts a skeleton-space position into a bone local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone             
                 * @param   {UnityEngine.Vector2}    worldPosition
                 * @return  {UnityEngine.Vector2}
                 */
                WorldToLocal: function (bone, worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#WorldToLocal", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.WorldToLocal(worldPosition.x, worldPosition.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static start.*/
                /**
                 * Sets the skeleton-space position of a bone.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone                     
                 * @param   {UnityEngine.Vector2}    skeletonSpacePosition
                 * @return  {UnityEngine.Vector2}                             The local position in its parent bone space, or in skeleton space if it is the root bone.
                 */
                SetPositionSkeletonSpace: function (bone, skeletonSpacePosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace", this ); }

                    if (bone.parent == null) { // root bone
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, skeletonSpacePosition.$clone());
                        return skeletonSpacePosition.$clone();
                    } else {
                        var parent = bone.parent;
                        var parentLocal = Spine.Unity.SkeletonExtensions.WorldToLocal(parent, skeletonSpacePosition.$clone());
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, parentLocal.$clone());
                        return parentLocal.$clone();
                    }
                },
                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMaterial:static start.*/
                GetMaterial: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMaterial", this ); }

                    var rendererObject = null;
                    var renderableAttachment = Bridge.as(a, Spine.IHasTextureRegion);
                    if (renderableAttachment != null) {
                        rendererObject = renderableAttachment.Spine$IHasTextureRegion$Region;
                    }

                    if (rendererObject == null) {
                        return null;
                    }

                    return Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                },
                /*Spine.Unity.SkeletonExtensions.GetMaterial:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static start.*/
                /**
                 * Fills a Vector2 buffer with local vertices.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         va        The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetLocalVertices: function (va, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalVertices", this ); }

                    var floatsCount = va.worldVerticesLength;
                    var bufferTargetSize = floatsCount >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", va.name, Bridge.box(floatsCount, System.Int32)), "buffer");
                    }

                    if (va.bones == null && slot.Deform.Count === 0) {
                        var localVerts = va.vertices;
                        for (var i = 0; i < bufferTargetSize; i = (i + 1) | 0) {
                            var j = Bridge.Int.mul(i, 2);
                            buffer[i] = new pc.Vec2( localVerts[j], localVerts[((j + 1) | 0)] );
                        }
                    } else {
                        var floats = System.Array.init(floatsCount, 0, System.Single);
                        va.computeWorldVertices( slot, 0, va.worldVerticesLength, floats, 0, 2 );

                        var sb = slot.bone;
                        var ia = { }, ib = { }, ic = { }, id = { }, bwx = sb.worldX, bwy = sb.worldY;
                        Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(sb, ia, ib, ic, id);

                        for (var i1 = 0; i1 < bufferTargetSize; i1 = (i1 + 1) | 0) {
                            var j1 = Bridge.Int.mul(i1, 2);
                            var x = floats[j1] - bwx, y = floats[((j1 + 1) | 0)] - bwy;
                            buffer[i1] = new pc.Vec2( x * ia.v + y * ib.v, x * ic.v + y * id.v );
                        }
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static start.*/
                /**
                 * Calculates world vertices and fills a Vector2 buffer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         a         The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetWorldVertices: function (a, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldVertices", this ); }

                    var worldVertsLength = a.worldVerticesLength;
                    var bufferTargetSize = worldVertsLength >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", a.name, Bridge.box(worldVertsLength, System.Int32)), "buffer");
                    }

                    var floats = System.Array.init(worldVertsLength, 0, System.Single);
                    a.computeWorldVertices( slot, 0, a.worldVerticesLength, floats, 0, 2 );

                    for (var i = 0, n = worldVertsLength >> 1; i < n; i = (i + 1) | 0) {
                        var j = Bridge.Int.mul(i, 2);
                        buffer[i] = new pc.Vec2( floats[j], floats[((j + 1) | 0)] );
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static end.*/


            }
        }
    });
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic.LayoutMode", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                WidthControlsHeight: 1,
                HeightControlsWidth: 2,
                FitInParent: 3,
                EnvelopeParent: 4
            }
        }
    });
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            customMaterialOverrides: null,
            customTextureOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#init", this ); }

                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)).ctor();
                this.customTextureOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomMaterialOverride.setItem(atlasMaterialOverride.originalTexture, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonGraphic.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalTexture, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomMaterialOverride.remove(atlasMaterialOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides start.*/
            SetCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    if (atlasTextureOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomTextureOverride.setItem(atlasTextureOverride.originalTexture, atlasTextureOverride.replacementTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides start.*/
            RemoveCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    var currentTexture = { };

                    if (!this.skeletonGraphic.CustomTextureOverride.tryGetValue(atlasTextureOverride.originalTexture, currentTexture)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentTexture.v, atlasTextureOverride.replacementTexture)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomTextureOverride.remove(atlasTextureOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.skeletonGraphic.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideEnabled, this.originalTexture, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementTexture: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasTextureOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementTexture, other.replacementTexture);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode", this ); }

                var h = Bridge.addHash([8976735721, this.overrideEnabled, this.originalTexture, this.replacementTexture]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementTexture = this.replacementTexture;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasTextureOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator", {
        $kind: 1002,
        statics: {
            fields: {
                WeightEpsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                    this.WeightEpsilon = 0.0001;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static start.*/
                AnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime", this ); }

                    var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.ToSpineAnimationTime(normalizedTime, clipLength, loop, reversed);
                    if (loop) {
                        return time;
                    }
                    var EndSnapEpsilon = 0.0333333351; // Workaround for end-duration keys not being applied.
                    return (clipLength - time < EndSnapEpsilon) ? clipLength : time; // return a time snapped to clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static end.*/

                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static start.*/
                ToSpineAnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime", this ); }

                    if (reversed) {
                        normalizedTime = (1 - normalizedTime);
                    }
                    if (normalizedTime < 0.0) {
                        normalizedTime = loop ? (normalizedTime % 1.0) + 1.0 : 0.0;
                    }
                    return normalizedTime * clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static end.*/


            }
        },
        fields: {
            autoReset: false,
            useCustomMixMode: false,
            layerMixModes: null,
            layerBlendModes: null,
            animationTable: null,
            clipNameHashCodeTable: null,
            previousAnimations: null,
            layerClipInfos: null,
            animator: null
        },
        events: {
            _OnClipApplied: null
        },
        props: {
            Animator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get", this ); }

                    return this.animator;
                }
            },
            MecanimLayerCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return 0;
                    }
                    return this.animator.layerCount;
                }
            },
            MecanimLayerNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return System.Array.init(0, null, System.String);
                    }
                    var layerNames = System.Array.init(this.animator.layerCount, null, System.String);
                    for (var i = 0; i < this.animator.layerCount; i = (i + 1) | 0) {
                    }
                    return layerNames;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                this.autoReset = true;
                this.useCustomMixMode = true;
                this.layerMixModes = System.Array.init(0, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                this.layerBlendModes = System.Array.init(0, 0, spine.MixBlend);
                this.animationTable = new (System.Collections.Generic.Dictionary$2(System.Int32,Spine.Animation)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer.Instance);
                this.clipNameHashCodeTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Int32)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer.Instance);
                this.previousAnimations = new (System.Collections.Generic.List$1(Spine.Animation)).ctor();
                this.layerClipInfos = System.Array.init(0, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
            }
        },
        methods: {
            addOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied", this ); }

                this.add_OnClipApplied(value);
            },
            removeOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied", this ); }

                this.remove_OnClipApplied(value);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize start.*/
            Initialize: function (animator, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize", this ); }

                var $t;
                this.animator = animator;

                this.previousAnimations.clear();

                this.animationTable.clear();
                var data = skeletonDataAsset.GetSkeletonData(true);
                $t = Bridge.getEnumerator(data.Animations);
                try {
                    while ($t.moveNext()) {
                        var a = $t.Current;
                        this.animationTable.add(Bridge.getHashCode(a.name), a);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.clipNameHashCodeTable.clear();
                this.ClearClipInfosForLayers();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation start.*/
            ApplyAnimation: function (skeleton, info, stateInfo, layerIndex, layerWeight, layerBlendMode, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var weight = info.weight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation start.*/
            ApplyInterruptionAnimation: function (skeleton, interpolateWeightTo1, info, stateInfo, layerIndex, layerWeight, layerBlendMode, interruptingClipTimeAddition, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }

                var clipWeight = interpolateWeightTo1 ? (info.weight + 1.0) * 0.5 : info.weight;
                var weight = clipWeight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime + interruptingClipTimeAddition, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback start.*/
            OnClipAppliedCallback: function (clip, stateInfo, layerIndex, time, isLooping, weight) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback", this ); }


                var speedFactor = stateInfo.speedMultiplier * stateInfo.speed;
                var lastTime = time - (UnityEngine.Time.deltaTime * speedFactor);
                var clipDuration = clip.duration;
                if (isLooping && clipDuration !== 0) {
                    time %= clipDuration;
                    lastTime %= clipDuration;
                }
                this._OnClipApplied(clip, layerIndex, weight, time, lastTime, speedFactor < 0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply start.*/
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply", this ); }


                if (this.layerMixModes.length < this.animator.layerCount) {
                    var oldSize = this.layerMixModes.length;
                    System.Array.resize(Bridge.ref(this, "layerMixModes"), this.animator.layerCount, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                    for (var layer = oldSize; layer < this.animator.layerCount; layer = (layer + 1) | 0) {
                        var isAdditiveLayer = false;
                        if (layer < this.layerBlendModes.length) {
                            isAdditiveLayer = this.layerBlendModes[layer] === spine.MixBlend.add;
                        }
                        this.layerMixModes[layer] = isAdditiveLayer ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                    }
                }

                this.InitClipInfosForLayers();
                for (var layer1 = 0, n = this.animator.layerCount; layer1 < n; layer1 = (layer1 + 1) | 0) {
                    this.GetStateUpdatesFromAnimator(layer1);
                }

                // Clear Previous
                if (this.autoReset) {
                    var previousAnimations = this.previousAnimations;
                    for (var i = 0, n1 = previousAnimations.Count; i < n1; i = (i + 1) | 0) {
                        previousAnimations.getItem(i).apply(skeleton, 0, 0, false, null, 0, spine.MixBlend.setup, spine.MixDirection.mixOut);
                    } // SetKeyedItemsToSetupPose

                    previousAnimations.clear();
                    for (var layer2 = 0, n2 = this.animator.layerCount; layer2 < n2; layer2 = (layer2 + 1) | 0) {
                        var layerWeight = (layer2 === 0) ? 1 : this.animator.GetLayerWeight(layer2); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.
                        if (layerWeight <= 0) {
                            continue;
                        }

                        var nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer2);

                        var hasNext = nextStateInfo.fullPathHash !== 0;

                        var clipInfoCount = { }, nextClipInfoCount = { }, interruptingClipInfoCount = { };
                        var clipInfo = { }, nextClipInfo = { }, interruptingClipInfo = { };
                        var isInterruptionActive = { }, shallInterpolateWeightTo1 = { };
                        this.GetAnimatorClipInfos(layer2, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1);

                        for (var c = 0; c < clipInfoCount.v; c = (c + 1) | 0) {
                            var info = System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone();
                            var weight = info.weight * layerWeight;
                            if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                continue;
                            }
                            var clip = this.GetAnimation(info.clip);
                            if (clip != null) {
                                previousAnimations.add(clip);
                            }
                        }

                        if (hasNext) {
                            for (var c1 = 0; c1 < nextClipInfoCount.v; c1 = (c1 + 1) | 0) {
                                var info1 = System.Array.getItem(nextClipInfo.v, c1, UnityEngine.AnimatorClipInfo).$clone();
                                var weight1 = info1.weight * layerWeight;
                                if (weight1 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip1 = this.GetAnimation(info1.clip);
                                if (clip1 != null) {
                                    previousAnimations.add(clip1);
                                }
                            }
                        }

                        if (isInterruptionActive.v) {
                            for (var c2 = 0; c2 < interruptingClipInfoCount.v; c2 = (c2 + 1) | 0) {
                                var info2 = System.Array.getItem(interruptingClipInfo.v, c2, UnityEngine.AnimatorClipInfo).$clone();
                                var clipWeight = shallInterpolateWeightTo1.v ? (info2.weight + 1.0) * 0.5 : info2.weight;
                                var weight2 = clipWeight * layerWeight;
                                if (weight2 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip2 = this.GetAnimation(info2.clip);
                                if (clip2 != null) {
                                    previousAnimations.add(clip2);
                                }
                            }
                        }
                    }
                }

                // Apply
                for (var layer3 = 0, n3 = this.animator.layerCount; layer3 < n3; layer3 = (layer3 + 1) | 0) {
                    var layerWeight1 = (layer3 === 0) ? 1 : this.animator.GetLayerWeight(layer3); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.

                    var isInterruptionActive1 = { };
                    var stateInfo = { };
                    var nextStateInfo1 = { };
                    var interruptingStateInfo = { };
                    var interruptingClipTimeAddition = { };
                    this.GetAnimatorStateInfos(layer3, isInterruptionActive1, stateInfo, nextStateInfo1, interruptingStateInfo, interruptingClipTimeAddition);

                    var hasNext1 = nextStateInfo1.v.fullPathHash !== 0;

                    var clipInfoCount1 = { }, nextClipInfoCount1 = { }, interruptingClipInfoCount1 = { };
                    var clipInfo1 = { }, nextClipInfo1 = { }, interruptingClipInfo1 = { };
                    var interpolateWeightTo1 = { };
                    this.GetAnimatorClipInfos(layer3, isInterruptionActive1, clipInfoCount1, nextClipInfoCount1, interruptingClipInfoCount1, clipInfo1, nextClipInfo1, interruptingClipInfo1, interpolateWeightTo1);

                    var layerBlendMode = (layer3 < this.layerBlendModes.length) ? this.layerBlendModes[layer3] : spine.MixBlend.replace;
                    var mode = this.GetMixMode(layer3, layerBlendMode);
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix) {
                        // Always use Mix instead of Applying the first non-zero weighted clip.
                        for (var c3 = 0; c3 < clipInfoCount1.v; c3 = (c3 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c3, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }
                        if (hasNext1) {
                            for (var c4 = 0; c4 < nextClipInfoCount1.v; c4 = (c4 + 1) | 0) {
                                this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c4, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode);
                            }
                        }
                        if (isInterruptionActive1.v) {
                            for (var c5 = 0; c5 < interruptingClipInfoCount1.v; c5 = (c5 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c5, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    } else { // case MixNext || Hard
                        // Apply first non-zero weighted clip
                        var c6 = 0;
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            if (!this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode, true)) {
                                continue;
                            }
                            c6 = (c6 + 1) | 0;
                            break;
                        }
                        // Mix the rest
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }

                        c6 = 0;
                        if (hasNext1) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode, true)) {
                                        continue;
                                    }
                                    c6 = (c6 + 1) | 0;
                                    break;
                                }
                            }
                            // Mix the rest
                            for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode)) {
                                    continue;
                                }
                            }
                        }

                        c6 = 0;
                        if (isInterruptionActive1.v) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v, true)) {

                                        c6 = (c6 + 1) | 0;
                                        break;
                                    }
                                }
                            }
                            // Mix the rest
                            for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime start.*/
            GetActiveAnimationAndTime: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime", this ); }

                if (layer >= this.layerClipInfos.length) {
                    return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(null, 0);
                }

                var layerInfos = this.layerClipInfos[layer];
                var isInterruptionActive = layerInfos.isInterruptionActive;
                var clip = null;
                var animation = null;
                var stateInfo;
                if (isInterruptionActive && layerInfos.interruptingClipInfoCount > 0) {
                    clip = layerInfos.interruptingClipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.interruptingStateInfo;
                } else {
                    clip = layerInfos.clipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.stateInfo;
                }
                animation = this.GetAnimation(clip);
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, clip.length, clip.isLooping, stateInfo.speed < 0);
                return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(animation, time);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers start.*/
            InitClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers", this ); }

                if (this.layerClipInfos.length < this.animator.layerCount) {
                    System.Array.resize(Bridge.ref(this, "layerClipInfos"), this.animator.layerCount, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
                    for (var layer = 0, n = this.animator.layerCount; layer < n; layer = (layer + 1) | 0) {
                        if (this.layerClipInfos[layer] == null) {
                            this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers start.*/
            ClearClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers", this ); }

                for (var layer = 0, n = this.layerClipInfos.length; layer < n; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                    } else {
                        this.layerClipInfos[layer].isInterruptionActive = false;
                        this.layerClipInfos[layer].isLastFrameOfInterruption = false;
                        this.layerClipInfos[layer].clipInfos.clear();
                        this.layerClipInfos[layer].nextClipInfos.clear();
                        this.layerClipInfos[layer].interruptingClipInfos.clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode start.*/
            GetMixMode: function (layer, layerBlendMode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode", this ); }

                if (this.useCustomMixMode) {
                    var mode = this.layerMixModes[layer];
                    // Note: at additive blending it makes no sense to use constant weight 1 at a fadeout anim add1 as
                    // with override layers, so we use AlwaysMix instead to use the proper weights.
                    // AlwaysMix leads to the expected result = lower_layer + lerp(add1, add2, transition_weight).
                    if (layerBlendMode === spine.MixBlend.add && mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext) {
                        mode = Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
                        this.layerMixModes[layer] = mode;
                    }
                    return mode;
                } else {
                    return layerBlendMode === spine.MixBlend.add ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator start.*/
            GetStateUpdatesFromAnimator: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator", this ); }


                var layerInfos = this.layerClipInfos[layer];
                var clipInfoCount = this.animator.GetCurrentAnimatorClipInfoCount(layer);
                var nextClipInfoCount = this.animator.GetNextAnimatorClipInfoCount(layer);

                var clipInfos = layerInfos.clipInfos;
                var nextClipInfos = layerInfos.nextClipInfos;
                var interruptingClipInfos = layerInfos.interruptingClipInfos;

                layerInfos.isInterruptionActive = (clipInfoCount === 0 && clipInfos.Count !== 0 && nextClipInfoCount === 0 && nextClipInfos.Count !== 0);

                // Note: during interruption, GetCurrentAnimatorClipInfoCount and GetNextAnimatorClipInfoCount
                // are returning 0 in calls above. Therefore we keep previous clipInfos and nextClipInfos
                // until the interruption is over.
                if (layerInfos.isInterruptionActive) {

                    // Note: The last frame of a transition interruption
                    // will have fullPathHash set to 0, therefore we have to use previous
                    // frame's infos about interruption clips and correct some values
                    // accordingly (normalizedTime and weight).
                    var interruptingStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                    layerInfos.isLastFrameOfInterruption = interruptingStateInfo.fullPathHash === 0;
                    if (!layerInfos.isLastFrameOfInterruption) {
                        this.animator.GetNextAnimatorClipInfo(layer, interruptingClipInfos);
                        layerInfos.interruptingClipInfoCount = interruptingClipInfos.Count;
                        var oldTime = layerInfos.interruptingStateInfo.normalizedTime;
                        var newTime = interruptingStateInfo.normalizedTime;
                        layerInfos.interruptingClipTimeAddition = newTime - oldTime;
                        layerInfos.interruptingStateInfo = interruptingStateInfo;
                    }
                } else {
                    layerInfos.clipInfoCount = clipInfoCount;
                    layerInfos.nextClipInfoCount = nextClipInfoCount;
                    layerInfos.interruptingClipInfoCount = 0;
                    layerInfos.isLastFrameOfInterruption = false;

                    if (clipInfos.Capacity < clipInfoCount) {
                        clipInfos.Capacity = clipInfoCount;
                    }
                    if (nextClipInfos.Capacity < nextClipInfoCount) {
                        nextClipInfos.Capacity = nextClipInfoCount;
                    }

                    this.animator.GetCurrentAnimatorClipInfo(layer, clipInfos);
                    this.animator.GetNextAnimatorClipInfo(layer, nextClipInfos);

                    layerInfos.stateInfo = this.animator.GetCurrentAnimatorStateInfo(layer);
                    layerInfos.nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos start.*/
            GetAnimatorClipInfos: function (layer, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                clipInfoCount.v = layerInfos.clipInfoCount;
                nextClipInfoCount.v = layerInfos.nextClipInfoCount;
                interruptingClipInfoCount.v = layerInfos.interruptingClipInfoCount;

                clipInfo.v = layerInfos.clipInfos;
                nextClipInfo.v = layerInfos.nextClipInfos;
                interruptingClipInfo.v = isInterruptionActive.v ? layerInfos.interruptingClipInfos : null;
                shallInterpolateWeightTo1.v = layerInfos.isLastFrameOfInterruption;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos start.*/
            GetAnimatorStateInfos: function (layer, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                stateInfo.v = layerInfos.stateInfo;
                nextStateInfo.v = layerInfos.nextStateInfo;
                interruptingStateInfo.v = layerInfos.interruptingStateInfo;
                interruptingClipTimeAddition.v = layerInfos.isLastFrameOfInterruption ? layerInfos.interruptingClipTimeAddition : 0;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation start.*/
            GetAnimation: function (clip) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation", this ); }

                var clipNameHashCode = { };
                if (!this.clipNameHashCodeTable.tryGetValue(clip, clipNameHashCode)) {
                    clipNameHashCode.v = Bridge.getHashCode(clip.name);
                    this.clipNameHashCodeTable.add(clip, clipNameHashCode.v);
                }
                var animation = { };
                this.animationTable.tryGetValue(clipNameHashCode.v, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(UnityEngine.AnimationClip)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2", this ); }

                return x.GetInstanceID() === y.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2", this ); }

                return o.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(AnimationClip, AnimationClip)": "equals2",
            "GetHashCode(AnimationClip)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", {
        $kind: 1002,
        fields: {
            isInterruptionActive: false,
            isLastFrameOfInterruption: false,
            clipInfoCount: 0,
            nextClipInfoCount: 0,
            interruptingClipInfoCount: 0,
            clipInfos: null,
            nextClipInfos: null,
            interruptingClipInfos: null,
            stateInfo: null,
            nextStateInfo: null,
            interruptingStateInfo: null,
            interruptingClipTimeAddition: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init", this ); }

                this.isInterruptionActive = false;
                this.isLastFrameOfInterruption = false;
                this.clipInfoCount = 0;
                this.nextClipInfoCount = 0;
                this.interruptingClipInfoCount = 0;
                this.clipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.nextClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipTimeAddition = 0;
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Int32)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2", this ); }

                return x === y;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2", this ); }

                return o;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(int, int)": "equals2",
            "GetHashCode(int)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", {
        $kind: 1006,
        statics: {
            fields: {
                AlwaysMix: 0,
                MixNext: 1,
                Hard: 2
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate
     * @param   {Spine.Unity.SkeletonRootMotionBase}    component      
     * @param   {UnityEngine.Vector2}                   translation    
     * @param   {number}                                rotation
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRootMotionBase start.*/
    /**
     * Base class for skeleton root motion components.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonRootMotionBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonRootMotionBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotionBoneName: null,
            transformPositionX: false,
            transformPositionY: false,
            transformRotation: false,
            rootMotionScaleX: 0,
            rootMotionScaleY: 0,
            rootMotionScaleRotation: 0,
            /**
             * Skeleton space X translation per skeleton space Y translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateXPerY: 0,
            /**
             * Skeleton space Y translation per skeleton space X translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateYPerX: 0,
            rigidBody2D: null,
            applyRigidbody2DGravity: false,
            rigidBody: null,
            /**
             * When true, root-motion is not applied to the Transform or Rigidbody.
             Otherwise the delegate callbacks are issued additionally.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default true
             * @type boolean
             */
            disableOnOverride: false,
            skeletonComponent: null,
            rootMotionBone: null,
            rootMotionBoneIndex: 0,
            transformConstraintIndices: null,
            transformConstraintLastPos: null,
            transformConstraintLastRotation: null,
            topLevelBones: null,
            initialOffset: null,
            accumulatedUntilFixedUpdate: false,
            tempSkeletonDisplacement: null,
            rigidbodyDisplacement: null,
            previousRigidbodyRootMotion: null,
            additionalRigidbody2DMovement: null,
            rigidbodyLocalRotation: null,
            rigidbody2DRotation: 0,
            initialOffsetRotation: 0,
            tempSkeletonRotation: 0
        },
        events: {
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removeProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            ProcessRootMotionOverride: null,
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addPhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removePhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            PhysicsUpdateRootMotionOverride: null
        },
        props: {
            RootMotionBone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get", this ); }

                    return this.rootMotionBone;
                }
            },
            UsesRigidbody: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.rigidBody, null) || UnityEngine.Component.op_Inequality(this.rigidBody2D, null);
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector2.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             This can be necessary when multiple scripts call <pre><code>Rigidbody2D.MovePosition</code></pre>,
             where the last call overwrites the effect of preceding ones.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion2D
             * @type UnityEngine.Vector2
             */
            PreviousRigidbodyRootMotion2D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get", this ); }

                    return new pc.Vec2( this.previousRigidbodyRootMotion.x, this.previousRigidbodyRootMotion.y );
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector3.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion3D
             * @type UnityEngine.Vector3
             */
            PreviousRigidbodyRootMotion3D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get", this ); }

                    return this.previousRigidbodyRootMotion.$clone();
                }
            },
            /**
             * Additional translation to add to <pre><code>Rigidbody2D.MovePosition</code></pre>
             called in FixedUpdate. This can be necessary when multiple scripts call
             <pre><code>MovePosition</code></pre>, where the last call overwrites the effect of preceding ones.
             Has no effect if <pre><code>rigidBody2D</code></pre> is null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function AdditionalRigidbody2DMovement
             * @type UnityEngine.Vector2
             */
            AdditionalRigidbody2DMovement: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get", this ); }

                    return this.additionalRigidbody2DMovement.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set", this ); }

                    this.additionalRigidbody2DMovement = value.$clone();
                }
            },
            SkeletonAnimationUsesFixedUpdate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get", this ); }

                    var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                    if (skeletonAnimation != null) {
                        return skeletonAnimation.Spine$Unity$ISkeletonAnimation$UpdateTiming === Spine.Unity.UpdateTiming.InFixedUpdate;
                    }
                    return false;
                }
            },
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get", this ); }

                    return 1.0;
                }
            },
            TargetSkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            TargetSkeletonAnimationComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get", this ); }

                    return Bridge.as(this.TargetSkeletonComponent, Spine.Unity.ISkeletonAnimation);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#init", this ); }

                this.initialOffset = new UnityEngine.Vector2();
                this.tempSkeletonDisplacement = new UnityEngine.Vector2();
                this.rigidbodyDisplacement = new UnityEngine.Vector3();
                this.previousRigidbodyRootMotion = new UnityEngine.Vector3();
                this.additionalRigidbody2DMovement = new UnityEngine.Vector2();
                this.rigidbodyLocalRotation = new UnityEngine.Quaternion();
                this.rootMotionBoneName = "root";
                this.transformPositionX = true;
                this.transformPositionY = true;
                this.transformRotation = false;
                this.rootMotionScaleX = 1;
                this.rootMotionScaleY = 1;
                this.rootMotionScaleRotation = 1;
                this.rootMotionTranslateXPerY = 0;
                this.rootMotionTranslateYPerX = 0;
                this.applyRigidbody2DGravity = false;
                this.disableOnOverride = true;
                this.transformConstraintIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                this.transformConstraintLastPos = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                this.transformConstraintLastRotation = new (System.Collections.Generic.List$1(System.Single)).ctor();
                this.topLevelBones = new (System.Collections.Generic.List$1(Spine.Bone)).ctor();
                this.initialOffset = pc.Vec2.ZERO.clone();
                this.accumulatedUntilFixedUpdate = false;
                this.previousRigidbodyRootMotion = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.additionalRigidbody2DMovement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotionBase.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Reset", this ); }

                this.FindRigidbodyComponent();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Reset end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Start", this ); }

                this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                this.GatherTopLevelBones();
                this.SetRootMotionBone(this.rootMotionBoneName);
                if (this.rootMotionBone != null) {
                    this.initialOffset = new pc.Vec2( this.rootMotionBone.x, this.rootMotionBone.y );
                    this.initialOffsetRotation = this.rootMotionBone.rotation;
                }

                var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                if (skeletonAnimation != null) {
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.Start end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FixedUpdate", this ); }

                // Root motion is only applied when component is enabled.
                if (!this.isActiveAndEnabled) {
                    return;
                }
                // When SkeletonAnimation component uses UpdateTiming.InFixedUpdate,
                // we directly call PhysicsUpdate in HandleUpdateLocal instead of here.
                if (!this.SkeletonAnimationUsesFixedUpdate) {
                    this.PhysicsUpdate(false);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate start.*/
            PhysicsUpdate: function (skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate", this ); }

                var callbackDisplacement = this.tempSkeletonDisplacement.$clone();
                var callbackRotation = this.tempSkeletonRotation;

                var isApplyAtRigidbodyAllowed = Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null) || !this.disableOnOverride;
                if (isApplyAtRigidbodyAllowed) {
                    if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                        var gravityAndVelocityMovement = pc.Vec2.ZERO.clone();
                        if (this.applyRigidbody2DGravity) {
                            var deltaTime = UnityEngine.Time.fixedDeltaTime;
                            var deltaTimeSquared = (deltaTime * deltaTime);

                            this.rigidBody2D.velocity = this.rigidBody2D.velocity.$clone().add( UnityEngine.Physics2D.gravity.$clone().scale( this.rigidBody2D.gravityScale ).scale( deltaTime ) );
                            gravityAndVelocityMovement = UnityEngine.Physics2D.gravity.$clone().scale( 0.5 * this.rigidBody2D.gravityScale ).scale( deltaTimeSquared ).add( this.rigidBody2D.velocity.$clone().scale( deltaTime ) );
                        }

                        var rigidbodyDisplacement2D = new pc.Vec2( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y );
                        this.rigidBody2D.MovePosition(gravityAndVelocityMovement.$clone().add( new pc.Vec2( this.transform.position.x, this.transform.position.y ) ).add( rigidbodyDisplacement2D ).add( this.additionalRigidbody2DMovement ));
                        this.rigidBody2D.MoveRotation(this.rigidbody2DRotation + this.rigidBody2D.rotation);
                    } else if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                        this.rigidBody.MovePosition(this.transform.position.$clone().add( new pc.Vec3( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y, this.rigidbodyDisplacement.z ) ));
                        this.rigidBody.MoveRotation(this.rigidBody.rotation.clone().mul( this.rigidbodyLocalRotation ));
                    }
                }

                this.previousRigidbodyRootMotion = this.rigidbodyDisplacement.$clone();
                if (this.accumulatedUntilFixedUpdate) {
                    var parentBoneScale = { v : new UnityEngine.Vector2() };
                    this.GetScaleAffectingRootMotion$1(parentBoneScale);
                    this.ClearEffectiveBoneOffsets(parentBoneScale.v.$clone());
                    this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.updateWorldTransform();
                }
                this.ClearRigidbodyTempMovement();

                if (!Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null)) {
                    this.PhysicsUpdateRootMotionOverride(this, callbackDisplacement.$clone(), callbackRotation);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#OnDisable", this ); }

                this.ClearRigidbodyTempMovement();
            },
            /*Spine.Unity.SkeletonRootMotionBase.OnDisable end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent start.*/
            FindRigidbodyComponent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent", this ); }

                this.rigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                    this.rigidBody = this.GetComponent(UnityEngine.Rigidbody);
                }

                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D) && !UnityEngine.Object.op_Implicit(this.rigidBody)) {
                    this.rigidBody2D = this.GetComponentInParent(UnityEngine.Rigidbody2D);
                    if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                        this.rigidBody = this.GetComponentInParent(UnityEngine.Rigidbody);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent end.*/

            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta", this ); }

                return 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone start.*/
            SetRootMotionBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var bone = skeleton.findBone(name);
                if (bone != null) {
                    this.rootMotionBoneIndex = bone.data.index;
                    this.rootMotionBone = bone;
                    this.FindTransformConstraintsAffectingBone();
                } else {
                    UnityEngine.Debug.Log$1("Bone named \"" + (name || "") + "\" could not be found.");
                    this.rootMotionBoneIndex = 0;
                    this.rootMotionBone = skeleton.getRootBone();
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance start.*/
            AdjustRootMotionToDistance: function (distanceToTarget, trackIndex, adjustX, adjustY, minX, maxX, minY, maxY, allowXTranslation, allowYTranslation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance", this ); }

                if (trackIndex === void 0) { trackIndex = 0; }
                if (adjustX === void 0) { adjustX = true; }
                if (adjustY === void 0) { adjustY = true; }
                if (minX === void 0) { minX = 0.0; }
                if (maxX === void 0) { maxX = 3.40282347E+38; }
                if (minY === void 0) { minY = 0.0; }
                if (maxY === void 0) { maxY = 3.40282347E+38; }
                if (allowXTranslation === void 0) { allowXTranslation = false; }
                if (allowYTranslation === void 0) { allowYTranslation = false; }

                var distanceToTargetSkeletonSpace = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(distanceToTarget)));
                var scaleAffectingRootMotion = this.GetScaleAffectingRootMotion();
                if (this.UsesRigidbody) {
                    distanceToTargetSkeletonSpace = distanceToTargetSkeletonSpace.$clone().sub( this.tempSkeletonDisplacement.$clone() );
                }

                var remainingRootMotionSkeletonSpace = this.GetRemainingRootMotion(trackIndex);
                remainingRootMotionSkeletonSpace.mul( scaleAffectingRootMotion );
                if (remainingRootMotionSkeletonSpace.x === 0) {
                    remainingRootMotionSkeletonSpace.x = 0.0001;
                }
                if (remainingRootMotionSkeletonSpace.y === 0) {
                    remainingRootMotionSkeletonSpace.y = 0.0001;
                }

                if (adjustX) {
                    this.rootMotionScaleX = Math.min(maxX, Math.max(minX, distanceToTargetSkeletonSpace.x / remainingRootMotionSkeletonSpace.x));
                }
                if (adjustY) {
                    this.rootMotionScaleY = Math.min(maxY, Math.max(minY, distanceToTargetSkeletonSpace.y / remainingRootMotionSkeletonSpace.y));
                }

                if (allowXTranslation) {
                    this.rootMotionTranslateXPerY = (distanceToTargetSkeletonSpace.x - remainingRootMotionSkeletonSpace.x * this.rootMotionScaleX) / remainingRootMotionSkeletonSpace.y;
                }
                if (allowYTranslation) {
                    this.rootMotionTranslateYPerX = (distanceToTargetSkeletonSpace.y - remainingRootMotionSkeletonSpace.y * this.rootMotionScaleY) / remainingRootMotionSkeletonSpace.x;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion start.*/
            GetAnimationRootMotion: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion", this ); }

                return this.GetAnimationRootMotion$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 start.*/
            GetAnimationRootMotion$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1", this ); }

                var $t, $t1;

                if (startTime === endTime) {
                    return pc.Vec2.ZERO.clone();
                }

                var translateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endPos = { v : pc.Vec2.ZERO.clone() };
                var startPos = { v : pc.Vec2.ZERO.clone() };
                if (translateTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, startTime);
                } else if (xTimeline != null || yTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, endTime, false, endPos);
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, startTime, true, startPos);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endPos.v.$clone().sub( startPos.v );

                // Looped additions
                if (startTime > endTime) {
                    var loopPos = { v : pc.Vec2.ZERO.clone() };
                    var zeroPos = { v : pc.Vec2.ZERO.clone() };
                    if (translateTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, 0);
                    } else if (xTimeline != null || yTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, animation.duration, false, loopPos);
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta = currentDelta.$clone().add( loopPos.v.$clone().sub( zeroPos.v ) );
                }
                this.UpdateLastConstraintPos(transformConstraintsItems);
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation start.*/
            GetAnimationRootMotionRotation: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation", this ); }

                return this.GetAnimationRootMotionRotation$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 start.*/
            GetAnimationRootMotionRotation$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1", this ); }

                var $t, $t1;

                if (startTime === endTime) {
                    return 0;
                }

                var rotateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.RotateTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endRotation = { v : 0 };
                var startRotation = { v : 0 };
                if (rotateTimeline != null) {
                    endRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, endTime);
                    startRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, endTime, false, endRotation);
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, startTime, true, startRotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endRotation.v - startRotation.v;

                // Looped additions
                if (startTime > endTime) {
                    var loopRotation = { v : 0 };
                    var zeroPos = { v : 0 };
                    if (rotateTimeline != null) {
                        loopRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, animation.duration, false, loopRotation);
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta += loopRotation.v - zeroPos.v;
                }
                this.UpdateLastConstraintRotation(transformConstraintsItems);
                return currentDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos start.*/
            ApplyConstraintToPos: function (animation, constraint, constraintIndex, time, useLastConstraintPos, pos) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var invMixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var constraintPos = new UnityEngine.Vector2();
                if (useLastConstraintPos) {
                    constraintPos = this.transformConstraintLastPos.getItem(this.GetConstraintLastPosIndex(constraintIndex)).$clone();
                } else {
                    var targetBone = constraint.target;
                    constraintPos = new pc.Vec2( targetBone.x, targetBone.y );
                }
                pos.v = new pc.Vec2( pos.v.x * invMixXY.x + constraintPos.x * mixXY.x, pos.v.y * invMixXY.y + constraintPos.y * mixXY.y );
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation start.*/
            ApplyConstraintToRotation: function (animation, constraint, constraintIndex, time, useLastConstraintRotation, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var invMixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var constraintRotation;
                if (useLastConstraintRotation) {
                    constraintRotation = this.transformConstraintLastRotation.getItem(this.GetConstraintLastPosIndex(constraintIndex));
                } else {
                    var targetBone = constraint.target;
                    constraintRotation = targetBone.rotation;
                }
                rotation.v = rotation.v * invMixRotate + constraintRotation * mixRotate;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos start.*/
            UpdateLastConstraintPos: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.target;
                        this.transformConstraintLastPos.setItem(this.GetConstraintLastPosIndex(constraintIndex), new pc.Vec2( targetBone.x, targetBone.y ));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation start.*/
            UpdateLastConstraintRotation: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.target;
                        this.transformConstraintLastRotation.setItem(this.GetConstraintLastPosIndex(constraintIndex), targetBone.rotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo start.*/
            GetAnimationRootMotionInfo: function (animation, currentTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo", this ); }

                var rootMotion = new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                var duration = animation.duration;
                var mid = duration * 0.5;
                rootMotion.timeIsPastMid = currentTime > mid;
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, duration);
                    return rootMotion.$clone();
                }
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);
                if (xTimeline != null || yTimeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, duration);
                    return rootMotion.$clone();
                }
                return rootMotion.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex start.*/
            GetConstraintLastPosIndex: function (constraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                var targetConstraint = constraints.Items[constraintIndex];
                return this.transformConstraintIndices.FindIndex$2(function (addedIndex) {
                    return addedIndex === constraintIndex;
                });
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone start.*/
            FindTransformConstraintsAffectingBone: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                var constraintsItems = constraints.Items;
                for (var i = 0, n = constraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = constraintsItems[i];
                    if (constraint.Bones.Contains(this.rootMotionBone)) {
                        this.transformConstraintIndices.add(i);
                        var targetBone = constraint.target;
                        var constraintPos = new pc.Vec2( targetBone.x, targetBone.y );
                        this.transformConstraintLastPos.add(constraintPos.$clone());
                        this.transformConstraintLastRotation.add(targetBone.rotation);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta start.*/
            GetTimelineMovementDelta: function (startTime, endTime, xTimeline, yTimeline, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta", this ); }


                var currentDelta = new UnityEngine.Vector2();
                if (startTime > endTime) {
                    currentDelta = (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) )).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0) )) );
                } else {
                    if (startTime !== endTime) {
                        currentDelta = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) );
                    } else {
                        currentDelta = pc.Vec2.ZERO.clone();
                    }
                }
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones start.*/
            GatherTopLevelBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones", this ); }

                var $t;
                this.topLevelBones.clear();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(skeleton.bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        if (bone.parent == null) {
                            this.topLevelBones.add(bone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones end.*/

            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal start.*/
            HandleUpdateLocal: function (animatedSkeletonComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                var boneLocalDelta = this.CalculateAnimationsMovementDelta();
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                var totalScale = { v : new UnityEngine.Vector2() };
                var skeletonTranslationDelta = this.GetSkeletonSpaceMovementDelta(boneLocalDelta.$clone(), parentBoneScale, totalScale);
                var skeletonRotationDelta = 0;
                if (this.transformRotation) {
                    var boneLocalDeltaRotation = this.CalculateAnimationsRotationDelta();
                    boneLocalDeltaRotation *= this.rootMotionScaleRotation;
                    skeletonRotationDelta = this.GetSkeletonSpaceRotationDelta(boneLocalDeltaRotation, totalScale.v.$clone());
                }

                var usesFixedUpdate = this.SkeletonAnimationUsesFixedUpdate;
                this.ApplyRootMotion(skeletonTranslationDelta.$clone(), skeletonRotationDelta, parentBoneScale.v.$clone(), usesFixedUpdate);

                if (usesFixedUpdate) {
                    this.PhysicsUpdate(usesFixedUpdate);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion start.*/
            ApplyRootMotion: function (skeletonTranslationDelta, skeletonRotationDelta, parentBoneScale, skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion", this ); }


                // Accumulated displacement is applied on the next Physics update in FixedUpdate.
                // Until the next Physics update, tempSkeletonDisplacement and tempSkeletonRotation
                // are offsetting bone locations to prevent stutter which would otherwise occur if
                // we don't move every Update.
                var usesRigidbody = this.UsesRigidbody;
                var applyToTransform = !usesRigidbody && (Bridge.staticEquals(this.ProcessRootMotionOverride, null) || !this.disableOnOverride);
                this.accumulatedUntilFixedUpdate = !applyToTransform && !skeletonAnimationUsesFixedUpdate;

                if (!Bridge.staticEquals(this.ProcessRootMotionOverride, null)) {
                    this.ProcessRootMotionOverride(this, skeletonTranslationDelta.$clone(), skeletonRotationDelta);
                }

                // Apply root motion to Transform or update values applied to RigidBody later (must happen in FixedUpdate).
                if (usesRigidbody) {
                    this.rigidbodyDisplacement = this.rigidbodyDisplacement.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                            var addedWorldRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, skeletonRotationDelta );
                            this.rigidbodyLocalRotation = this.rigidbodyLocalRotation.clone().mul( addedWorldRotation );
                        } else if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                            var lossyScale = this.transform.lossyScale.$clone();
                            var rotationSign = lossyScale.x * lossyScale.y > 0 ? 1 : -1;
                            this.rigidbody2DRotation += rotationSign * skeletonRotationDelta;
                        }
                    }
                } else if (applyToTransform) {
                    this.transform.position = this.transform.position.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        var lossyScale1 = this.transform.lossyScale.$clone();
                        var rotationSign1 = lossyScale1.x * lossyScale1.y > 0 ? 1 : -1;
                        this.transform.Rotate(0, 0, rotationSign1 * skeletonRotationDelta);
                    }
                }

                this.tempSkeletonDisplacement = this.tempSkeletonDisplacement.$clone().add( skeletonTranslationDelta.$clone() );
                this.tempSkeletonRotation += skeletonRotationDelta;
                if (this.accumulatedUntilFixedUpdate) {
                    this.SetEffectiveBoneOffsetsTo(this.tempSkeletonDisplacement.$clone(), this.tempSkeletonRotation, parentBoneScale.$clone());
                } else {
                    this.ClearEffectiveBoneOffsets(parentBoneScale.$clone());
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints start.*/
            ApplyTransformConstraints: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints", this ); }

                var $t;
                this.rootMotionBone.ax = this.rootMotionBone.x;
                this.rootMotionBone.ay = this.rootMotionBone.y;
                this.rootMotionBone.arotation = this.rootMotionBone.rotation;
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        // apply the constraint and sets Bone.ax, Bone.ay and Bone.arotation values.
                        constraint.update();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion start.*/
            GetScaleAffectingRootMotion: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion", this ); }

                var parentBoneScale = { v : new UnityEngine.Vector2() };
                return this.GetScaleAffectingRootMotion$1(parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 start.*/
            GetScaleAffectingRootMotion$1: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var totalScale = pc.Vec2.ONE.clone();
                totalScale.x *= skeleton.scaleX;
                totalScale.y *= skeleton.scaleY;

                parentBoneScale.v = pc.Vec2.ONE.clone();
                var scaleBone = this.rootMotionBone;
                while (((scaleBone = scaleBone.parent)) != null) {
                    parentBoneScale.v.x *= scaleBone.scaleX;
                    parentBoneScale.v.y *= scaleBone.scaleY;
                }
                totalScale = new pc.Vec2( totalScale.x * parentBoneScale.v.x, totalScale.y * parentBoneScale.v.y );
                totalScale = totalScale.$clone().scale( this.AdditionalScale );
                return totalScale.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta start.*/
            GetSkeletonSpaceMovementDelta: function (boneLocalDelta, parentBoneScale, totalScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta", this ); }

                var skeletonDelta = boneLocalDelta.$clone();
                totalScale.v = this.GetScaleAffectingRootMotion$1(parentBoneScale);
                skeletonDelta.mul( totalScale.v );

                var rootMotionTranslation = new pc.Vec2( this.rootMotionTranslateXPerY * skeletonDelta.y, this.rootMotionTranslateYPerX * skeletonDelta.x );

                skeletonDelta.x *= this.rootMotionScaleX;
                skeletonDelta.y *= this.rootMotionScaleY;
                skeletonDelta.x += rootMotionTranslation.x;
                skeletonDelta.y += rootMotionTranslation.y;

                if (!this.transformPositionX) {
                    skeletonDelta.x = 0.0;
                }
                if (!this.transformPositionY) {
                    skeletonDelta.y = 0.0;
                }
                return skeletonDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta start.*/
            GetSkeletonSpaceRotationDelta: function (boneLocalDelta, totalScaleAffectingRootMotion) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta", this ); }

                var rotationSign = totalScaleAffectingRootMotion.x * totalScaleAffectingRootMotion.y > 0 ? 1 : -1;
                return rotationSign * boneLocalDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo start.*/
            SetEffectiveBoneOffsetsTo: function (displacementSkeletonSpace, rotationSkeletonSpace, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo", this ); }

                var $t;

                this.ApplyTransformConstraints();

                // Move top level bones in opposite direction of the root motion bone
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(this.topLevelBones);
                try {
                    while ($t.moveNext()) {
                        var topLevelBone = $t.Current;
                        if (Bridge.referenceEquals(topLevelBone, this.rootMotionBone)) {
                            if (this.transformPositionX) {
                                topLevelBone.x = displacementSkeletonSpace.x / skeleton.scaleX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = displacementSkeletonSpace.y / skeleton.scaleY;
                            }
                            if (this.transformRotation) {
                                var rotationSign = skeleton.scaleX * skeleton.scaleY > 0 ? 1 : -1;
                                topLevelBone.rotation = rotationSign * rotationSkeletonSpace;
                            }
                        } else {
                            var useAppliedTransform = this.transformConstraintIndices.Count > 0;
                            var rootMotionBoneX = useAppliedTransform ? this.rootMotionBone.ax : this.rootMotionBone.x;
                            var rootMotionBoneY = useAppliedTransform ? this.rootMotionBone.ay : this.rootMotionBone.y;

                            var offsetX = (this.initialOffset.x - rootMotionBoneX) * parentBoneScale.x;
                            var offsetY = (this.initialOffset.y - rootMotionBoneY) * parentBoneScale.y;

                            if (this.transformPositionX) {
                                topLevelBone.x = (displacementSkeletonSpace.x / skeleton.scaleX) + offsetX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = (displacementSkeletonSpace.y / skeleton.scaleY) + offsetY;
                            }

                            if (this.transformRotation) {
                                var rootMotionBoneRotation = useAppliedTransform ? this.rootMotionBone.arotation : this.rootMotionBone.rotation;

                                var parentBoneRotationSign = (parentBoneScale.x * parentBoneScale.y > 0 ? 1 : -1);
                                var offsetRotation = (this.initialOffsetRotation - rootMotionBoneRotation) * parentBoneRotationSign;

                                var skeletonRotationSign = skeleton.scaleX * skeleton.scaleY > 0 ? 1 : -1;
                                topLevelBone.rotation = (rotationSkeletonSpace * skeletonRotationSign) + offsetRotation;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets start.*/
            ClearEffectiveBoneOffsets: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets", this ); }

                this.SetEffectiveBoneOffsetsTo(pc.Vec2.ZERO.clone(), 0, parentBoneScale.$clone());
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement start.*/
            ClearRigidbodyTempMovement: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement", this ); }

                this.rigidbodyDisplacement = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
                this.rigidbody2DRotation = 0;
                this.tempSkeletonRotation = 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement end.*/


        },
        overloads: {
            "GetAnimationRootMotion(float, float, Animation)": "GetAnimationRootMotion$1",
            "GetAnimationRootMotionRotation(float, float, Animation)": "GetAnimationRootMotionRotation$1",
            "GetScaleAffectingRootMotion(Vector2)": "GetScaleAffectingRootMotion$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate
     * @param   {Spine.Unity.SkeletonPartsRenderer}    skeletonPartsRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonPartsRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonPartsRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static start.*/
                NewPartsRendererGameObject: function (parent, name, sortingOrder) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject", this ); }

                    if (sortingOrder === void 0) { sortingOrder = 0; }
                    var go = new UnityEngine.GameObject.$ctor4(name, [UnityEngine.MeshFilter, UnityEngine.MeshRenderer]);
                    go.transform.SetParent(parent, false);
                    var returnComponent = go.AddComponent(Spine.Unity.SkeletonPartsRenderer);
                    returnComponent.MeshRenderer.sortingOrder = sortingOrder;

                    return returnComponent;
                },
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static end.*/


            }
        },
        fields: {
            meshGenerator: null,
            meshRenderer: null,
            meshFilter: null,
            buffers: null,
            currentInstructions: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get", this ); }

                    this.LazyIntialize();
                    return this.meshGenerator;
                }
            },
            MeshRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get", this ); }

                    this.LazyIntialize();
                    return this.meshRenderer;
                }
            },
            MeshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshFilter#get", this ); }

                    this.LazyIntialize();
                    return this.meshFilter;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#init", this ); }

                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize start.*/
            LazyIntialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#LazyIntialize", this ); }

                if (this.buffers == null) {
                    this.buffers = new Spine.Unity.MeshRendererBuffers();
                    this.buffers.Initialize();

                    if (this.meshGenerator != null) {
                        return;
                    }
                    this.meshGenerator = new Spine.Unity.MeshGenerator();
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.currentInstructions.Clear();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize end.*/

            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh start.*/
            ClearMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#ClearMesh", this ); }

                this.LazyIntialize();
                this.meshFilter.sharedMesh = null;
            },
            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh end.*/

            /*Spine.Unity.SkeletonPartsRenderer.RenderParts start.*/
            RenderParts: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#RenderParts", this ); }

                this.LazyIntialize();

                // STEP 1: Create instruction
                var smartMesh = this.buffers.GetNextMesh();
                this.currentInstructions.SetWithSubset(instructions, startSubmesh, endSubmesh);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                // STEP 2: Generate mesh buffers.
                var currentInstructionsSubmeshesItems = this.currentInstructions.submeshInstructions.Items;
                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping) {
                    for (var i = 0; i < this.currentInstructions.submeshInstructions.Count; i = (i + 1) | 0) {
                        this.meshGenerator.AddSubmesh(currentInstructionsSubmeshesItems[i].$clone(), updateTriangles);
                    }
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                this.buffers.UpdateSharedMaterials(this.currentInstructions.submeshInstructions);

                // STEP 3: modify mesh.
                var mesh = smartMesh.mesh;

                if (this.meshGenerator.VertexCount <= 0) { // Clear an empty mesh
                    updateTriangles = false;
                    mesh.Clear();
                } else {
                    this.meshGenerator.FillVertexData(mesh);
                    if (updateTriangles) {
                        this.meshGenerator.FillTriangles(mesh);
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    } else if (this.buffers.MaterialsChangedInLastUpdate()) {
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    }
                    this.meshGenerator.FillLateVertexData(mesh);
                }

                this.meshFilter.sharedMesh = mesh;
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.RenderParts end.*/

            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock start.*/
            SetPropertyBlock: function (block) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock", this ); }

                this.LazyIntialize();
                this.meshRenderer.SetPropertyBlock(block);
            },
            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock end.*/


        }
    });
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    /**
     * This enum controls the mode under which the sprite will interact with the masking system.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
     */
    Bridge.define("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", {
        $kind: 1002,
        fields: {
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsMaskDisabled: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsInsideMask: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsOutsideMask: null
        },
        props: {
            AnyMaterialCreated: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get", this ); }

                    return this.materialsMaskDisabled.length > 0 || this.materialsInsideMask.length > 0 || this.materialsOutsideMask.length > 0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init", this ); }

                this.materialsMaskDisabled = System.Array.init(0, null, UnityEngine.Material);
                this.materialsInsideMask = System.Array.init(0, null, UnityEngine.Material);
                this.materialsOutsideMask = System.Array.init(0, null, UnityEngine.Material);
            }
        }
    });
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            customSlotMaterials: null,
            customMaterialOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#init", this ); }

                this.customSlotMaterials = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)).ctor();
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials start.*/
            SetCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (slotMaterialOverride.overrideDisabled || System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject != null) {
                        this.skeletonRenderer.CustomSlotMaterials.setItem(slotObject, slotMaterialOverride.material);
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials start.*/
            RemoveCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject == null) {
                        continue;
                    }
                    var currentMaterial = { };
                    if (!this.skeletonRenderer.CustomSlotMaterials.tryGetValue(slotObject, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, slotMaterialOverride.material)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomSlotMaterials.remove(slotObject);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideDisabled) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.setItem(atlasMaterialOverride.originalMaterial, atlasMaterialOverride.replacementMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonRenderer.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalMaterial, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.remove(atlasMaterialOverride.originalMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.skeletonRenderer.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            originalMaterial: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.originalMaterial, other.originalMaterial) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideDisabled, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            slotName: null,
            material: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$SlotMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.slotName, other.slotName) && Bridge.referenceEquals(this.material, other.material);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([9094239955, this.overrideDisabled, this.slotName, this.material]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.slotName = this.slotName;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "Equals(SlotMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    /**
     * Instructions used by a SkeletonRenderer to render a mesh.
     *
     * @public
     * @class Spine.Unity.SkeletonRendererInstruction
     */
    Bridge.define("Spine.Unity.SkeletonRendererInstruction", {
        statics: {
            methods: {
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static start.*/
                GeometryNotEqual: function (a, b) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual", this ); }


                    if (a.hasActiveClipping || b.hasActiveClipping) {
                        return true;
                    } // Triangles are unpredictable when clipping is active.

                    // Everything below assumes the raw vertex and triangle counts were used. (ie, no clipping was done)
                    if (a.rawVertexCount !== b.rawVertexCount) {
                        return true;
                    }

                    if (a.immutableTriangles !== b.immutableTriangles) {
                        return true;
                    }

                    var attachmentCountB = b.attachments.Count;
                    if (a.attachments.Count !== attachmentCountB) {
                        return true;
                    } // Bounds check for the looped storedAttachments count below.

                    // Submesh count changed
                    var submeshCountA = a.submeshInstructions.Count;
                    var submeshCountB = b.submeshInstructions.Count;
                    if (submeshCountA !== submeshCountB) {
                        return true;
                    }

                    // Submesh Instruction mismatch
                    var submeshInstructionsItemsA = a.submeshInstructions.Items;
                    var submeshInstructionsItemsB = b.submeshInstructions.Items;

                    var attachmentsA = a.attachments.Items;
                    var attachmentsB = b.attachments.Items;
                    for (var i = 0; i < attachmentCountB; i = (i + 1) | 0) {
                        if (!Bridge.referenceEquals(attachmentsA[i], attachmentsB[i])) {
                            return true;
                        }
                    }

                    for (var i1 = 0; i1 < submeshCountB; i1 = (i1 + 1) | 0) {
                        var submeshA = submeshInstructionsItemsA[i1].$clone();
                        var submeshB = submeshInstructionsItemsB[i1].$clone();

                        if (!(submeshA.rawVertexCount === submeshB.rawVertexCount && submeshA.startSlot === submeshB.startSlot && submeshA.endSlot === submeshB.endSlot && submeshA.rawTriangleCount === submeshB.rawTriangleCount && submeshA.rawFirstVertexIndex === submeshB.rawFirstVertexIndex)) {
                            return true;
                        }
                    }

                    return false;
                },
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static end.*/


            }
        },
        fields: {
            submeshInstructions: null,
            immutableTriangles: false,
            hasActiveClipping: false,
            rawVertexCount: 0,
            attachments: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#init", this ); }

                this.submeshInstructions = new (Spine.ExposedList$1(Spine.Unity.SubmeshInstruction)).ctor();
                this.rawVertexCount = -1;
                this.attachments = new (Spine.ExposedList$1(spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererInstruction.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Clear", this ); }

                this.attachments.Clear(false);
                this.rawVertexCount = -1;
                this.hasActiveClipping = false;
                this.submeshInstructions.Clear(false);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Clear end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Dispose", this ); }

                this.attachments.Clear(true);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Dispose end.*/

            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset start.*/
            SetWithSubset: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#SetWithSubset", this ); }

                var runningVertexCount = 0;

                var submeshes = this.submeshInstructions;
                submeshes.Clear(false);
                var submeshCount = (endSubmesh - startSubmesh) | 0;
                submeshes.Resize(submeshCount);
                var submeshesItems = submeshes.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var instruction = instructionsItems[((startSubmesh + i) | 0)].$clone();
                    submeshesItems[i] = instruction.$clone();
                    this.hasActiveClipping = !!(this.hasActiveClipping | instruction.hasClipping);
                    submeshesItems[i].rawFirstVertexIndex = runningVertexCount; // Ensure current instructions have correct cached values.
                    runningVertexCount = (runningVertexCount + instruction.rawVertexCount) | 0; // vertexCount will also be used for the rest of this method.
                }
                this.rawVertexCount = runningVertexCount;

                // assumption: instructions are contiguous. start and end are valid within instructions.

                var startSlot = instructionsItems[startSubmesh].startSlot;
                var endSlot = instructionsItems[((endSubmesh - 1) | 0)].endSlot;
                this.attachments.Clear(false);
                var attachmentCount = (endSlot - startSlot) | 0;
                this.attachments.Resize(attachmentCount);
                var attachmentsItems = this.attachments.Items;

                var drawOrderItems = instructionsItems[0].skeleton.DrawOrder.Items;
                for (var i1 = 0; i1 < attachmentCount; i1 = (i1 + 1) | 0) {
                    var slot = drawOrderItems[((startSlot + i1) | 0)];
                    if (!slot.bone.isActive()) {
                        continue;
                    }
                    attachmentsItems[i1] = slot.getAttachment();
                }

            },
            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Set start.*/
            Set: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Set", this ); }

                this.immutableTriangles = other.immutableTriangles;

                this.hasActiveClipping = other.hasActiveClipping;
                this.rawVertexCount = other.rawVertexCount;
                this.attachments.Clear(false);
                this.attachments.EnsureCapacity(other.attachments.Capacity);
                this.attachments.Count = other.attachments.Count;
                other.attachments.CopyTo(this.attachments.Items);

                this.submeshInstructions.Clear(false);
                this.submeshInstructions.EnsureCapacity(other.submeshInstructions.Capacity);
                this.submeshInstructions.Count = other.submeshInstructions.Count;
                other.submeshInstructions.CopyTo(this.submeshInstructions.Items);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Set end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererInstruction end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonRenderer}    skeletonRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderSeparator start.*/
    Bridge.define("Spine.Unity.SkeletonRenderSeparator", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultSortingOrderIncrement: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                    this.DefaultSortingOrderIncrement = 5;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static start.*/
                /**
                 * Adds a SkeletonRenderSeparator and child SkeletonPartsRenderer GameObjects to a given SkeletonRenderer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderSeparator
                 * @memberof Spine.Unity.SkeletonRenderSeparator
                 * @param   {Spine.Unity.SkeletonRenderer}           skeletonRenderer            The target SkeletonRenderer or SkeletonAnimation.
                 * @param   {number}                                 sortingLayerID              Sorting layer to be used for the parts renderers.
                 * @param   {number}                                 extraPartsRenderers         Number of additional SkeletonPartsRenderers on top of the ones determined by counting the number of separator slots.
                 * @param   {number}                                 sortingOrderIncrement       The integer to increment the sorting order per SkeletonPartsRenderer to separate them.
                 * @param   {number}                                 baseSortingOrder            The sorting order value of the first SkeletonPartsRenderer.
                 * @param   {boolean}                                addMinimumPartsRenderers    If set to <pre><code>true</code></pre>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.
                 * @return  {Spine.Unity.SkeletonRenderSeparator}                                The to skeleton renderer.
                 */
                AddToSkeletonRenderer: function (skeletonRenderer, sortingLayerID, extraPartsRenderers, sortingOrderIncrement, baseSortingOrder, addMinimumPartsRenderers) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer", this ); }

                    if (sortingLayerID === void 0) { sortingLayerID = 0; }
                    if (extraPartsRenderers === void 0) { extraPartsRenderers = 0; }
                    if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                    if (baseSortingOrder === void 0) { baseSortingOrder = 0; }
                    if (addMinimumPartsRenderers === void 0) { addMinimumPartsRenderers = true; }
                    if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                        UnityEngine.Debug.Log$1("Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.");
                        return null;
                    }

                    var srs = skeletonRenderer.gameObject.AddComponent(Spine.Unity.SkeletonRenderSeparator);
                    srs.skeletonRenderer = skeletonRenderer;

                    skeletonRenderer.Initialize(false);
                    var count = extraPartsRenderers;
                    if (addMinimumPartsRenderers) {
                        count = (((extraPartsRenderers + skeletonRenderer.separatorSlots.Count) | 0) + 1) | 0;
                    }

                    var skeletonRendererTransform = skeletonRenderer.transform;
                    var componentRenderers = srs.partsRenderers;

                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(skeletonRendererTransform, Bridge.toString(i));
                        var mr = spr.MeshRenderer;
                        mr.sortingLayerID = sortingLayerID;
                        mr.sortingOrder = (baseSortingOrder + (Bridge.Int.mul(i, sortingOrderIncrement))) | 0;
                        componentRenderers.add(spr);
                    }

                    srs.OnEnable();


                    return srs;
                },
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static end.*/


            }
        },
        fields: {
            skeletonRenderer: null,
            mainMeshRenderer: null,
            copyPropertyBlock: false,
            copyMeshRendererFlags: false,
            partsRenderers: null,
            copiedBlock: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                        this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    }

                    this.skeletonRenderer = value;
                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        this.enabled = false;
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                this.copyPropertyBlock = true;
                this.copyMeshRendererFlags = true;
                this.partsRenderers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonPartsRenderer)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer start.*/
            /**
             * Add a child SkeletonPartsRenderer GameObject to this SkeletonRenderSeparator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @param   {number}                               sortingOrderIncrement    
             * @param   {string}                               name
             * @return  {Spine.Unity.SkeletonPartsRenderer}
             */
            AddPartsRenderer: function (sortingOrderIncrement, name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer", this ); }

                if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                if (name === void 0) { name = null; }
                var sortingLayerID = 0;
                var sortingOrder = 0;
                if (this.partsRenderers.Count > 0) {
                    var previous = this.partsRenderers.getItem(((this.partsRenderers.Count - 1) | 0));
                    var previousMeshRenderer = previous.MeshRenderer;
                    sortingLayerID = previousMeshRenderer.sortingLayerID;
                    sortingOrder = (previousMeshRenderer.sortingOrder + sortingOrderIncrement) | 0;
                }

                if (System.String.isNullOrEmpty(name)) {
                    name = Bridge.toString(this.partsRenderers.Count);
                }

                var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(this.skeletonRenderer.transform, name);
                this.partsRenderers.add(spr);

                var mr = spr.MeshRenderer;
                mr.sortingLayerID = sortingLayerID;
                mr.sortingOrder = sortingOrder;

                return spr;
            },
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                if (this.copiedBlock == null) {
                    this.copiedBlock = new UnityEngine.MaterialPropertyBlock();
                }
                this.mainMeshRenderer = this.skeletonRenderer.GetComponent(UnityEngine.MeshRenderer);

                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.addGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                if (this.copyMeshRendererFlags) {
                    var lightProbeUsage = this.mainMeshRenderer.lightProbeUsage;
                    var receiveShadows = this.mainMeshRenderer.receiveShadows;
                    var reflectionProbeUsage = this.mainMeshRenderer.reflectionProbeUsage;
                    var shadowCastingMode = this.mainMeshRenderer.shadowCastingMode;

                    for (var i = 0; i < this.partsRenderers.Count; i = (i + 1) | 0) {
                        var currentRenderer = this.partsRenderers.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                            continue;
                        } // skip null items.

                        var mr = currentRenderer.MeshRenderer;
                        mr.lightProbeUsage = lightProbeUsage;
                        mr.receiveShadows = receiveShadows;
                        mr.reflectionProbeUsage = reflectionProbeUsage;
                        mr.shadowCastingMode = shadowCastingMode;
                    }
                }

                if (this.skeletonRenderer.updateWhenInvisible !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.skeletonRenderer.LateUpdateMesh();
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnEnable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.LateUpdateMesh();
                this.ClearPartsRendererMeshes();
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.HandleRender start.*/
            HandleRender: function (instruction) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#HandleRender", this ); }

                var $t;
                var rendererCount = this.partsRenderers.Count;
                if (rendererCount <= 0) {
                    return;
                }

                if (this.copyPropertyBlock) {
                    this.mainMeshRenderer.GetPropertyBlock(this.copiedBlock);
                }

                var settings = ($t = new Spine.Unity.MeshGenerator.Settings(), $t.addNormals = this.skeletonRenderer.addNormals, $t.calculateTangents = this.skeletonRenderer.calculateTangents, $t.immutableTriangles = false, $t.pmaVertexColors = this.skeletonRenderer.pmaVertexColors, $t.tintBlack = this.skeletonRenderer.tintBlack, $t.useClipping = true, $t.zSpacing = this.skeletonRenderer.zSpacing, $t);

                var submeshInstructions = instruction.submeshInstructions;
                var submeshInstructionsItems = submeshInstructions.Items;
                var lastSubmeshInstruction = (submeshInstructions.Count - 1) | 0;

                var rendererIndex = 0;
                var currentRenderer = this.partsRenderers.getItem(rendererIndex);
                for (var si = 0, start = 0; si <= lastSubmeshInstruction; si = (si + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                        continue;
                    }
                    if (submeshInstructionsItems[si].forceSeparate || si === lastSubmeshInstruction) {
                        // Apply properties
                        var meshGenerator = currentRenderer.MeshGenerator;
                        meshGenerator.settings = settings.$clone();

                        if (this.copyPropertyBlock) {
                            currentRenderer.SetPropertyBlock(this.copiedBlock);
                        }

                        // Render
                        currentRenderer.RenderParts(instruction.submeshInstructions, start, ((si + 1) | 0));

                        start = (si + 1) | 0;
                        rendererIndex = (rendererIndex + 1) | 0;
                        if (rendererIndex < rendererCount) {
                            currentRenderer = this.partsRenderers.getItem(rendererIndex);
                        } else {
                            // Not enough renderers. Skip the rest of the instructions.
                            break;
                        }
                    }
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this.skeletonRenderer);
                }

                // Clear extra renderers if they exist.
                for (; rendererIndex < rendererCount; rendererIndex = (rendererIndex + 1) | 0) {
                    currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    if (UnityEngine.MonoBehaviour.op_Inequality(currentRenderer, null)) {
                        this.partsRenderers.getItem(rendererIndex).ClearMesh();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.HandleRender end.*/

            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes start.*/
            ClearPartsRendererMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(partsRenderer, null)) {
                            partsRenderer.ClearMesh();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes end.*/


        }
    });
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo(); }
            }
        },
        fields: {
            start: null,
            current: null,
            mid: null,
            end: null,
            timeIsPastMid: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init", this ); }

                this.start = new UnityEngine.Vector2();
                this.current = new UnityEngine.Vector2();
                this.mid = new UnityEngine.Vector2();
                this.end = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode", this ); }

                var h = Bridge.addHash([5573033076, this.start, this.current, this.mid, this.end, this.timeIsPastMid]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SkeletonRootMotionBase.RootMotionInfo)) {
                    return false;
                }
                return Bridge.equals(this.start, o.start) && Bridge.equals(this.current, o.current) && Bridge.equals(this.mid, o.mid) && Bridge.equals(this.end, o.end) && Bridge.equals(this.timeIsPastMid, o.timeIsPastMid);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                s.start = this.start.$clone();
                s.current = this.current.$clone();
                s.mid = this.mid.$clone();
                s.end = this.end.$clone();
                s.timeIsPastMid = this.timeIsPastMid;
                return s;
            }
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    /**
     * A minimal MaskableGraphic subclass for rendering multiple submeshes
     at a {@link }.
     *
     * @public
     * @class Spine.Unity.SkeletonSubmeshGraphic
     * @augments UnityEngine.UI.MaskableGraphic
     */
    Bridge.define("Spine.Unity.SkeletonSubmeshGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        methods: {
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty start.*/
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty start.*/
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh start.*/
            OnPopulateMesh: function (vh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh", this ); }

                vh.Clear();
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh end.*/


        }
    });
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    Bridge.define("Spine.Unity.SkeletonUtility", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static start.*/
                AddBoundingBoxGameObject: function (skeleton, skinName, slotName, attachmentName, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var skin = System.String.isNullOrEmpty(skinName) ? skeleton.data.defaultSkin : skeleton.data.findSkin(skinName);
                    if (skin == null) {
                        UnityEngine.Debug.LogError$2("Skin " + (skinName || "") + " not found!");
                        return null;
                    }

                    var slot = skeleton.findSlot(slotName);
                    var attachment = slot != null ? skin.getAttachment(slot.data.index, attachmentName) : null;
                    if (attachment == null) {
                        UnityEngine.Debug.LogFormat("Attachment in slot '{0}' named '{1}' not found in skin '{2}'.", [slotName, attachmentName, skin.name]);
                        return null;
                    }

                    var box = Bridge.as(attachment, spine.BoundingBoxAttachment);
                    if (box != null) {
                        return Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1(box.name, box, slot, parent, isTrigger);
                    } else {
                        UnityEngine.Debug.LogFormat("Attachment '{0}' was not a Bounding Box.", [attachmentName]);
                        return null;
                    }
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static start.*/
                AddBoundingBoxGameObject$1: function (name, box, slot, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var go = new UnityEngine.GameObject.$ctor2("[BoundingBox]" + ((System.String.isNullOrEmpty(name) ? box.name : name) || ""));
                    var got = go.transform;
                    got.parent = parent;
                    got.localPosition = pc.Vec3.ZERO.clone();
                    got.localRotation = pc.Quat.IDENTITY.clone();
                    got.localScale = new pc.Vec3( 1, 1, 1 );
                    return Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(box, slot, go, isTrigger);
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static start.*/
                AddBoundingBoxAsComponent: function (box, slot, gameObject, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    if (box == null) {
                        return null;
                    }
                    var collider = gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                    collider.isTrigger = isTrigger;
                    Spine.Unity.SkeletonUtility.SetColliderPointsLocal(collider, slot, box);
                    return collider;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static end.*/

                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static start.*/
                SetColliderPointsLocal: function (collider, slot, box, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SetColliderPointsLocal", this ); }

                    if (scale === void 0) { scale = 1.0; }
                    if (box == null) {
                        return;
                    }
                    if (Spine.SpineSkeletonExtensions.IsWeighted(box)) {
                        UnityEngine.Debug.LogWarning$1("UnityEngine.PolygonCollider2D does not support weighted or animated points. Collider points will not be animated and may have incorrect orientation. If you want to use it as a collider, please remove weights and animations from the bounding box in Spine editor.");
                    }
                    var verts = Spine.Unity.SkeletonExtensions.GetLocalVertices(box, slot, null);
                    if (scale !== 1.0) {
                        for (var i = 0, n = verts.length; i < n; i = (i + 1) | 0) {
                            verts[i] = verts[i].$clone().scale( scale );
                        }
                    }
                    collider.SetPath$1(0, verts);
                },
                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static end.*/

                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static start.*/
                GetBoundingBoxBounds: function (boundingBox, depth) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoundingBoxBounds", this ); }

                    if (depth === void 0) { depth = 0.0; }
                    var floats = boundingBox.vertices;
                    var floatCount = floats.length;

                    var bounds = new pc.BoundingBox.ctor();

                    bounds.center = new pc.Vec3( floats[0], floats[1], 0 );
                    for (var i = 2; i < floatCount; i = (i + 2) | 0) {
                        bounds.expandToPoint( new pc.Vec3( floats[i], floats[((i + 1) | 0)], 0 ) );
                    }

                    var size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                    size.z = depth;
                    bounds.halfExtents = size.$clone().$clone().scale( 0.5 );

                    return bounds;
                },
                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static start.*/
                AddBoneRigidbody2D: function (gameObject, isKinematic, gravityScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoneRigidbody2D", this ); }

                    if (isKinematic === void 0) { isKinematic = true; }
                    if (gravityScale === void 0) { gravityScale = 0.0; }
                    var rb = gameObject.GetComponent(UnityEngine.Rigidbody2D);
                    if (UnityEngine.Component.op_Equality(rb, null)) {
                        rb = gameObject.AddComponent(UnityEngine.Rigidbody2D);
                        rb.isKinematic = isKinematic;
                        rb.gravityScale = gravityScale;
                    }
                    return rb;
                },
                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static end.*/


            }
        },
        fields: {
            boneRoot: null,
            /**
             * If true, {@link } and {@link } are followed
             by 180 degree rotation. If false, negative Transform scale is used.
             Note that using negative scale is consistent with previous behaviour (hence the default),
             however causes serious problems with rigidbodies and physics. Therefore, it is recommended to
             enable this parameter where possible. When creating hinge chains for a chain of skeleton bones
             via {@link }, it is mandatory to have <pre><code>flipBy180DegreeRotation</code></pre> enabled.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtility
             * @default false
             * @type boolean
             */
            flipBy180DegreeRotation: false,
            skeletonRenderer: null,
            skeletonGraphic: null,
            canvas: null,
            skeletonAnimation: null,
            skeletonComponent: null,
            boneComponents: null,
            constraintComponents: null,
            positionScale: 0,
            hasOverrideBones: false,
            hasConstraints: false,
            needToReprocessBones: false
        },
        events: {
            OnReset: null
        },
        props: {
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Skeleton#get", this ); }

                    if (this.SkeletonComponent == null) {
                        return null;
                    }
                    return this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#IsValid#get", this ); }

                    return (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid) || (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid);
                }
            },
            PositionScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#PositionScale#get", this ); }

                    return this.positionScale;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#init", this ); }

                this.flipBy180DegreeRotation = false;
                this.boneComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityBone)).ctor();
                this.constraintComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityConstraint)).ctor();
                this.positionScale = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtility.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Update", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton != null && UnityEngine.Component.op_Inequality(this.boneRoot, null)) {

                    if (this.flipBy180DegreeRotation) {
                        this.boneRoot.localScale = new pc.Vec3( Math.abs(skeleton.scaleX), Math.abs(skeleton.scaleY), 1.0 );
                        this.boneRoot.eulerAngles = new pc.Vec3( skeleton.scaleY > 0 ? 0 : 180, skeleton.scaleX > 0 ? 0 : 180, 0 );
                    } else {
                        this.boneRoot.localScale = new pc.Vec3( skeleton.scaleX, skeleton.scaleY, 1.0 );
                    }
                }

                if (UnityEngine.Component.op_Inequality(this.canvas, null)) {
                    this.positionScale = this.canvas.referencePixelsPerUnit;
                }
            },
            /*Spine.Unity.SkeletonUtility.Update end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeEvents start.*/
            ResubscribeEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeEvents", this ); }

                this.OnDisable();
                this.OnEnable();
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeEvents end.*/

            /*Spine.Unity.SkeletonUtility.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (this.skeletonAnimation == null) {
                    this.skeletonAnimation = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonAnimation) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonAnimation) : this.GetComponent(Spine.Unity.ISkeletonAnimation);
                }
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.canvas = this.skeletonGraphic.canvas;
                    if (UnityEngine.Component.op_Equality(this.canvas, null)) {
                        this.canvas = this.skeletonGraphic.GetComponentInParent(UnityEngine.Canvas);
                    }
                    if (UnityEngine.Component.op_Equality(this.canvas, null)) {
                        this.positionScale = 100.0;
                    }
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                }

                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.OnEnable end.*/

            /*Spine.Unity.SkeletonUtility.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Start", this ); }

                //recollect because order of operations failure when switching between game mode and edit mode...
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.Start end.*/

            /*Spine.Unity.SkeletonUtility.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                }
            },
            /*Spine.Unity.SkeletonUtility.OnDisable end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 start.*/
            HandleRendererReset$1: function (r) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset$1", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset start.*/
            HandleRendererReset: function (g) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset end.*/

            /*Spine.Unity.SkeletonUtility.RegisterBone start.*/
            RegisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterBone", this ); }

                if (this.boneComponents.contains(bone)) {
                    return;
                } else {
                    this.boneComponents.add(bone);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterBone end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterBone start.*/
            UnregisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterBone", this ); }

                this.boneComponents.remove(bone);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterBone end.*/

            /*Spine.Unity.SkeletonUtility.RegisterConstraint start.*/
            RegisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterConstraint", this ); }

                if (this.constraintComponents.contains(constraint)) {
                    return;
                } else {
                    this.constraintComponents.add(constraint);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterConstraint start.*/
            UnregisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterConstraint", this ); }

                this.constraintComponents.remove(constraint);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.CollectBones start.*/
            CollectBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#CollectBones", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    var constraintTargets = new (System.Collections.Generic.List$1(System.Object)).ctor();
                    var ikConstraints = skeleton.IkConstraints;
                    for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                        constraintTargets.add(ikConstraints.Items[i].target);
                    }

                    var transformConstraints = skeleton.TransformConstraints;
                    for (var i1 = 0, n1 = transformConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                        constraintTargets.add(transformConstraints.Items[i1].target);
                    }

                    var boneComponents = this.boneComponents;
                    for (var i2 = 0, n2 = boneComponents.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                        var b = boneComponents.getItem(i2);
                        if (b.bone == null) {
                            b.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                            if (b.bone == null) {
                                continue;
                            }
                        }
                        this.hasOverrideBones = !!(this.hasOverrideBones | (b.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override));
                        this.hasConstraints = !!(this.hasConstraints | constraintTargets.contains(b.bone));
                    }

                    this.hasConstraints = !!(this.hasConstraints | this.constraintComponents.Count > 0);

                    if (this.skeletonAnimation != null) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));

                        if (this.hasOverrideBones || this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        }

                        if (this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                        }
                    }

                    this.needToReprocessBones = false;
                } else {
                    this.boneComponents.clear();
                    this.constraintComponents.clear();
                }
            },
            /*Spine.Unity.SkeletonUtility.CollectBones end.*/

            /*Spine.Unity.SkeletonUtility.UpdateLocal start.*/
            UpdateLocal: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateLocal", this ); }

                if (this.needToReprocessBones) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).transformLerpComplete = false;
                }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtility.UpdateLocal end.*/

            /*Spine.Unity.SkeletonUtility.UpdateWorld start.*/
            UpdateWorld: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateWorld", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.World);
                for (var i = 0, n = this.constraintComponents.Count; i < n; i = (i + 1) | 0) {
                    this.constraintComponents.getItem(i).DoUpdate();
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateWorld end.*/

            /*Spine.Unity.SkeletonUtility.UpdateComplete start.*/
            UpdateComplete: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateComplete", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete);
            },
            /*Spine.Unity.SkeletonUtility.UpdateComplete end.*/

            /*Spine.Unity.SkeletonUtility.UpdateAllBones start.*/
            UpdateAllBones: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateAllBones", this ); }

                if (UnityEngine.Component.op_Equality(this.boneRoot, null)) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).DoUpdate(phase);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateAllBones end.*/

            /*Spine.Unity.SkeletonUtility.GetBoneRoot start.*/
            GetBoneRoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoneRoot", this ); }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    return this.boneRoot;
                }

                var boneRootObject = new UnityEngine.GameObject.$ctor2("SkeletonUtility-SkeletonRoot");
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    boneRootObject.AddComponent(UnityEngine.RectTransform);
                }

                this.boneRoot = boneRootObject.transform;
                this.boneRoot.SetParent(this.transform);
                this.boneRoot.localPosition = pc.Vec3.ZERO.clone();
                this.boneRoot.localRotation = pc.Quat.IDENTITY.clone();
                this.boneRoot.localScale = new pc.Vec3( 1, 1, 1 );

                return this.boneRoot;
            },
            /*Spine.Unity.SkeletonUtility.GetBoneRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnRoot start.*/
            SpawnRoot: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnRoot", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;

                var go = this.SpawnBone(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnHierarchy start.*/
            SpawnHierarchy: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnHierarchy", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBoneRecursively(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnHierarchy end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively start.*/
            SpawnBoneRecursively: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBoneRecursively", this ); }

                var go = this.SpawnBone(bone, parent, mode, pos, rot, sca);

                var childrenBones = bone.Children;
                for (var i = 0, n = childrenBones.Count; i < n; i = (i + 1) | 0) {
                    var child = childrenBones.Items[i];
                    this.SpawnBoneRecursively(child, go.transform, mode, pos, rot, sca);
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBone start.*/
            SpawnBone: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBone", this ); }

                var go = new UnityEngine.GameObject.$ctor2(bone.data.name);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    go.AddComponent(UnityEngine.RectTransform);
                }

                var goTransform = go.transform;
                goTransform.SetParent(parent);

                var b = go.AddComponent(Spine.Unity.SkeletonUtilityBone);
                b.hierarchy = this;
                b.position = pos;
                b.rotation = rot;
                b.scale = sca;
                b.mode = mode;
                b.zPosition = true;
                b.Reset();
                b.bone = bone;
                b.boneName = bone.data.name;
                b.valid = true;

                if (mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (rot) {
                        goTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.bone.arotation );
                    }
                    if (pos) {
                        goTransform.localPosition = new pc.Vec3( b.bone.x * this.positionScale, b.bone.y * this.positionScale, 0 );
                    }
                    goTransform.localScale = new pc.Vec3( b.bone.scaleX, b.bone.scaleY, 0 );
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBone end.*/


        },
        overloads: {
            "HandleRendererReset(SkeletonRenderer)": "HandleRendererReset$1"
        }
    });
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonUtilityBone
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonUtilityBone", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static start.*/
                BoneTransformModeIncompatible: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible", this ); }

                    return !Spine.SpineSkeletonExtensions.InheritsScale(bone.data.transformMode);
                },
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static end.*/


            }
        },
        fields: {
            /**
             * If a bone isn't set, boneName is used to find the bone.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtilityBone
             * @type string
             */
            boneName: null,
            parentReference: null,
            mode: 0,
            position: false,
            rotation: false,
            scale: false,
            zPosition: false,
            overrideAlpha: 0,
            hierarchy: null,
            bone: null,
            transformLerpComplete: false,
            valid: false,
            cachedTransform: null,
            skeletonTransform: null,
            incompatibleTransformMode: false
        },
        props: {
            IncompatibleTransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get", this ); }

                    return this.incompatibleTransformMode;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#init", this ); }

                this.zPosition = true;
                this.overrideAlpha = 1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityBone.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#Reset", this ); }

                this.bone = null;
                this.cachedTransform = this.transform;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null) && this.hierarchy.IsValid;
                if (!this.valid) {
                    return;
                }
                this.skeletonTransform = this.hierarchy.transform;
                this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtilityBone.Reset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    return;
                }

                this.hierarchy.RegisterBone(this);
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
            },
            /*Spine.Unity.SkeletonUtilityBone.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset start.*/
            HandleOnReset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#HandleOnReset", this ); }

                this.Reset();
            },
            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null)) {
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.UnregisterBone(this);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnDisable end.*/

            /*Spine.Unity.SkeletonUtilityBone.DoUpdate start.*/
            DoUpdate: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#DoUpdate", this ); }

                var $t;
                if (!this.valid) {
                    this.Reset();
                    return;
                }

                var skeleton = this.hierarchy.Skeleton;

                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = skeleton.findBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogError$2("Bone not found: " + (this.boneName || ""), this);
                        return;
                    }
                }
                if (!this.bone.isActive()) {
                    return;
                }

                var positionScale = this.hierarchy.PositionScale;

                var thisTransform = this.cachedTransform;
                var skeletonFlipRotation = ($t = skeleton.scaleX * skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Follow) {
                    switch (phase) {
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.x * positionScale, this.bone.y * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.rotation );
                                } else {
                                    var euler = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler.x, euler.y, euler.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.World: 
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.ax * positionScale, this.bone.ay * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.arotation );
                                } else {
                                    var euler1 = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler1.x, euler1.y, euler1.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.ascaleX, this.bone.ascaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                    }

                } else if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (this.transformLerpComplete) {
                        return;
                    }

                    if (UnityEngine.Component.op_Equality(this.parentReference, null)) {
                        if (this.position) {
                            var clp = thisTransform.localPosition.$clone().scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, clp.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, clp.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle = UnityEngine.Mathf.LerpAngle(this.bone.rotation, thisTransform.localRotation.getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle;
                            this.bone.arotation = angle;
                        }

                        if (this.scale) {
                            var cls = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls.y, this.overrideAlpha);
                        }

                    } else {
                        if (this.transformLerpComplete) {
                            return;
                        }

                        if (this.position) {
                            var pos = this.parentReference.InverseTransformPoint(thisTransform.position).scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, pos.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, pos.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle1 = UnityEngine.Mathf.LerpAngle(this.bone.rotation, new pc.Quat().setLookAt( new pc.Vec3( 0, 0, 1 ), this.parentReference.InverseTransformDirection(thisTransform.up.$clone()) ).getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle1;
                            this.bone.arotation = angle1;
                        }

                        if (this.scale) {
                            var cls1 = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls1.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls1.y, this.overrideAlpha);
                        }

                        this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                    }

                    this.transformLerpComplete = true;
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.DoUpdate end.*/

            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox start.*/
            AddBoundingBox: function (skinName, slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#AddBoundingBox", this ); }

                Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(this.transform.gameObject);
                Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject(this.bone.skeleton, skinName, slotName, attachmentName, this.transform);
            },
            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.Mode", {
        $kind: 1006,
        statics: {
            fields: {
                Follow: 0,
                Override: 1
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.UpdatePhase", {
        $kind: 1006,
        statics: {
            fields: {
                Local: 0,
                World: 1,
                Complete: 2
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityConstraint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bone: null,
            hierarchy: null
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnEnable", this ); }

                this.bone = this.GetComponent(Spine.Unity.SkeletonUtilityBone);
                this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                this.hierarchy.RegisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnDisable", this ); }

                this.hierarchy.UnregisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    Bridge.define("Spine.Unity.SpineAttributeBase", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            dataField: null,
            startsWith: null,
            includeNone: false,
            fallbackToTextField: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttributeBase#init", this ); }

                this.dataField = "";
                this.startsWith = "";
                this.includeNone = true;
                this.fallbackToTextField = false;
            }
        }
    });
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    Bridge.define("Spine.Unity.SpineAtlasRegion", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            atlasAssetField: null
        },
        ctors: {
            ctor: function (atlasAssetField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasRegion#ctor", this ); }

                if (atlasAssetField === void 0) { atlasAssetField = ""; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.atlasAssetField = atlasAssetField;
            }
        }
    });
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    /**
     * A struct that represents 3 strings that help identify and locate an attachment in a skeleton.
     *
     * @public
     * @class Spine.Unity.SpineAttachment.Hierarchy
     */
    Bridge.define("Spine.Unity.SpineAttachment.Hierarchy", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue", this ); }
 return new Spine.Unity.SpineAttachment.Hierarchy(); }
            }
        },
        fields: {
            skin: null,
            slot: null,
            name: null
        },
        ctors: {
            $ctor1: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$ctor1", this ); }

                this.$initialize();
                var chunks = System.String.split(fullPath, System.Array.init([47], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (chunks.length === 0) {
                    this.skin = "";
                    this.slot = "";
                    this.name = "";
                    return;
                } else if (chunks.length < 2) {
                    throw new System.Exception("Cannot generate Attachment Hierarchy from string! Not enough components! [" + (fullPath || "") + "]");
                }
                this.skin = chunks[0];
                this.slot = chunks[1];
                this.name = "";
                for (var i = 2; i < chunks.length; i = (i + 1) | 0) {
                    this.name = (this.name || "") + (chunks[i] || "");
                }
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getHashCode", this ); }

                var h = Bridge.addHash([3670596642, this.skin, this.slot, this.name]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SpineAttachment.Hierarchy)) {
                    return false;
                }
                return Bridge.equals(this.skin, o.skin) && Bridge.equals(this.slot, o.slot) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$clone", this ); }

                var s = to || new Spine.Unity.SpineAttachment.Hierarchy();
                s.skin = this.skin;
                s.slot = this.slot;
                s.name = this.name;
                return s;
            }
        }
    });
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineMesh start.*/
    Bridge.define("Spine.Unity.SpineMesh", {
        statics: {
            fields: {
                MeshHideflags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#init", this ); }

                    this.MeshHideflags = 20;
                }
            },
            methods: {
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static start.*/
                /**
                 * Factory method for creating a new mesh for use in Spine components. This can be called in field initializers.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineMesh
                 * @memberof Spine.Unity.SpineMesh
                 * @return  {UnityEngine.Mesh}
                 */
                NewSkeletonMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#NewSkeletonMesh", this ); }

                    var m = new UnityEngine.Mesh.ctor();
                    m.MarkDynamic();
                    m.name = "Skeleton Mesh";
                    m.hideFlags = Spine.Unity.SpineMesh.MeshHideflags;
                    return m;
                },
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static end.*/


            }
        }
    });
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    /**
     * Instructions for how to generate a mesh or submesh: "Render this skeleton's slots: start slot, up to but not including endSlot, using this material."
     *
     * @public
     * @class Spine.Unity.SubmeshInstruction
     */
    Bridge.define("Spine.Unity.SubmeshInstruction", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getDefaultValue", this ); }
 return new Spine.Unity.SubmeshInstruction(); }
            }
        },
        fields: {
            skeleton: null,
            startSlot: 0,
            endSlot: 0,
            material: null,
            forceSeparate: false,
            preActiveClippingSlotSource: 0,
            rawTriangleCount: 0,
            rawVertexCount: 0,
            rawFirstVertexIndex: 0,
            hasClipping: false,
            hasPMAAdditiveSlot: false
        },
        props: {
            /**
             * The number of slots in this SubmeshInstruction's range. Not necessarily the number of attachments.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SubmeshInstruction
             * @function SlotCount
             * @type number
             */
            SlotCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#SlotCount#get", this ); }

                    return ((this.endSlot - this.startSlot) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SubmeshInstruction.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#toString", this ); }

                return System.String.format("[SubmeshInstruction: slots {0} to {1}. (Material){2}. preActiveClippingSlotSource:{3}]", Bridge.box(this.startSlot, System.Int32), Bridge.box(((this.endSlot - 1) | 0), System.Int32), this.material == null ? "<none>" : this.material.name, Bridge.box(this.preActiveClippingSlotSource, System.Int32));
            },
            /*Spine.Unity.SubmeshInstruction.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getHashCode", this ); }

                var h = Bridge.addHash([6756249098, this.skeleton, this.startSlot, this.endSlot, this.material, this.forceSeparate, this.preActiveClippingSlotSource, this.rawTriangleCount, this.rawVertexCount, this.rawFirstVertexIndex, this.hasClipping, this.hasPMAAdditiveSlot]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SubmeshInstruction)) {
                    return false;
                }
                return Bridge.equals(this.skeleton, o.skeleton) && Bridge.equals(this.startSlot, o.startSlot) && Bridge.equals(this.endSlot, o.endSlot) && Bridge.equals(this.material, o.material) && Bridge.equals(this.forceSeparate, o.forceSeparate) && Bridge.equals(this.preActiveClippingSlotSource, o.preActiveClippingSlotSource) && Bridge.equals(this.rawTriangleCount, o.rawTriangleCount) && Bridge.equals(this.rawVertexCount, o.rawVertexCount) && Bridge.equals(this.rawFirstVertexIndex, o.rawFirstVertexIndex) && Bridge.equals(this.hasClipping, o.hasClipping) && Bridge.equals(this.hasPMAAdditiveSlot, o.hasPMAAdditiveSlot);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#$clone", this ); }

                var s = to || new Spine.Unity.SubmeshInstruction();
                s.skeleton = this.skeleton;
                s.startSlot = this.startSlot;
                s.endSlot = this.endSlot;
                s.material = this.material;
                s.forceSeparate = this.forceSeparate;
                s.preActiveClippingSlotSource = this.preActiveClippingSlotSource;
                s.rawTriangleCount = this.rawTriangleCount;
                s.rawVertexCount = this.rawVertexCount;
                s.rawFirstVertexIndex = this.rawFirstVertexIndex;
                s.hasClipping = this.hasClipping;
                s.hasPMAAdditiveSlot = this.hasPMAAdditiveSlot;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    Bridge.define("Spine.Unity.UpdateMode", {
        $kind: 6,
        statics: {
            fields: {
                Nothing: 0,
                OnlyAnimationStatus: 1,
                OnlyEventTimelines: 4,
                EverythingExceptMesh: 2,
                FullUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    Bridge.define("Spine.Unity.UpdateTiming", {
        $kind: 6,
        statics: {
            fields: {
                ManualUpdate: 0,
                InUpdate: 1,
                InFixedUpdate: 2
            }
        }
    });
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires any of the
     configured events.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimation", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry, eventsToWaitFor);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimation
             * @memberof Spine.Unity.WaitForSpineAnimation
             * @param   {Spine.TrackEntry}                     trackEntry         
             * @param   {number}                               eventsToWaitFor
             * @return  {Spine.Unity.WaitForSpineAnimation}
             */
            NowWaitFor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry, eventsToWaitFor);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset end.*/

            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Start) !== 0) {
                        trackEntry.addStart(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Interrupt) !== 0) {
                        trackEntry.addInterrupt(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End) !== 0) {
                        trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Dispose) !== 0) {
                        trackEntry.addDispose(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete) !== 0) {
                        trackEntry.addComplete(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                }
            },
            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineAnimation.HandleComplete start.*/
            HandleComplete: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#HandleComplete", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineAnimation.HandleComplete end.*/


        }
    });
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 1,
                Interrupt: 2,
                End: 4,
                Dispose: 8,
                Complete: 16
            }
        },
        $flags: true
    });
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState fires an event matching the given event name or EventData reference.
     *
     * @public
     * @class Spine.Unity.WaitForSpineEvent
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineEvent", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_TargetEvent: null,
            m_EventName: null,
            m_AnimationState: null,
            m_WasFired: false,
            m_unsubscribeAfterFiring: false
        },
        props: {
            /**
             * By default, WaitForSpineEvent will unsubscribe from the event immediately after it fires a correct matching event.
             If you want to reuse this WaitForSpineEvent instance on the same event, you can set this to false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.WaitForSpineEvent
             * @function WillUnsubscribeAfterFiring
             * @type boolean
             */
            WillUnsubscribeAfterFiring: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get", this ); }

                    return this.m_unsubscribeAfterFiring;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set", this ); }

                    this.m_unsubscribeAfterFiring = value;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#init", this ); }

                this.m_WasFired = false;
                this.m_unsubscribeAfterFiring = false;
            },
            ctor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#ctor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor2: function (skeletonAnimation, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor2", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.Subscribe(skeletonAnimation.state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
            },
            $ctor3: function (skeletonAnimation, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor3", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.SubscribeByName(skeletonAnimation.state, eventName, unsubscribeAfterFiring);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineEvent.Subscribe start.*/
            Subscribe: function (state, eventDataReference, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Subscribe", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (eventDataReference == null) {
                    UnityEngine.Debug.LogWarning$1("eventDataReference argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_TargetEvent = eventDataReference;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));

                this.m_unsubscribeAfterFiring = unsubscribe;

            },
            /*Spine.Unity.WaitForSpineEvent.Subscribe end.*/

            /*Spine.Unity.WaitForSpineEvent.SubscribeByName start.*/
            SubscribeByName: function (state, eventName, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#SubscribeByName", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (System.String.isNullOrEmpty(eventName)) {
                    UnityEngine.Debug.LogWarning$1("eventName argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_EventName = eventName;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));

                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.SubscribeByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName start.*/
            HandleAnimationStateEventByName: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data.name, this.m_EventName))); // Check event name string match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                } // Unsubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data, this.m_TargetEvent))); // Check event data reference match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                } // Usubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor start.*/
            NowWaitFor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 start.*/
            NowWaitFor$1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor$1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 end.*/

            /*Spine.Unity.WaitForSpineEvent.Clear start.*/
            Clear: function (state) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Clear", this ); }

                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
            },
            /*Spine.Unity.WaitForSpineEvent.Clear end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset end.*/


        },
        overloads: {
            "NowWaitFor(Spine.AnimationState, string, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     *
     * @public
     * @class Spine.Unity.WaitForSpineTrackEntryEnd
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineTrackEntryEnd", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd start.*/
            HandleEnd: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleEnd));
                }
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationEnd.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineTrackEntryEnd
             * @memberof Spine.Unity.WaitForSpineTrackEntryEnd
             * @param   {Spine.TrackEntry}                         trackEntry
             * @return  {Spine.Unity.WaitForSpineTrackEntryEnd}
             */
            NowWaitFor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry);
                return this;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset end.*/


        }
    });
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*Tab start.*/
    Bridge.define("Tab", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bodyPartLink: null,
            bubble: null,
            check: null,
            selected: null,
            fill: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Tab#init", this ); }

                this.selected = new UnityEngine.Color32();
            }
        },
        methods: {
            /*Tab.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "Tab#OnValidate", this ); }

                this.fill = this.GetComponent(UnityEngine.UI.Image);
                this.bubble = this.transform.GetChild(0).GetComponent(Scale);
                this.check = this.transform.GetChild(1).gameObject;
            },
            /*Tab.OnValidate end.*/

            /*Tab.OnDisplay start.*/
            OnDisplay: function () {
if ( TRACE ) { TRACE( "Tab#OnDisplay", this ); }

                this.bubble.OnEnter();
                this.check.SetActive(true);
                this.fill.color = new pc.Color( 1, 1, 1, 1 );
                !Bridge.staticEquals(IdleActions.OnUpdateScaleBodyPart, null) ? IdleActions.OnUpdateScaleBodyPart(this.bodyPartLink) : null;
            },
            /*Tab.OnDisplay end.*/

            /*Tab.OnExit start.*/
            OnExit: function (tick) {
if ( TRACE ) { TRACE( "Tab#OnExit", this ); }

                this.bubble.OnExit();
                if (tick) {
                    this.fill.color = UnityEngine.Color32.op_Implicit(this.selected.$clone());
                } else {
                    this.fill.color = new pc.Color( 1, 1, 1, 1 );
                }
                this.check.SetActive(false);
            },
            /*Tab.OnExit end.*/

            /*Tab.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Tab#Reset", this ); }

                this.bubble.OnExit();
                this.fill.color = new pc.Color( 1, 1, 1, 1 );
                this.check.SetActive(false);
            },
            /*Tab.Reset end.*/


        }
    });
    /*Tab end.*/

    /*TabMenuHandler start.*/
    Bridge.define("TabMenuHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            tabSelection: null,
            tabContents: null,
            nextBtn: null,
            fade: null,
            next_Btn: null,
            done_Btn: null,
            handtut: null,
            index: 0,
            firstPlay: false,
            nextable: false,
            slider: null,
            handTut: null,
            targetScaleBodyPart: null,
            isSliderShow: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TabMenuHandler#init", this ); }

                this.fade = new UnityEngine.Color();
                this.firstPlay = true;
                this.nextable = false;
                this.isSliderShow = false;
            }
        },
        methods: {
            /*TabMenuHandler.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TabMenuHandler#Awake", this ); }

                TabMenuHandler.Instance = this;
            },
            /*TabMenuHandler.Awake end.*/

            /*TabMenuHandler.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "TabMenuHandler#Start", this ); }

                this.firstPlay = false;
                this.InitState();
            },
            /*TabMenuHandler.Start end.*/

            /*TabMenuHandler.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TabMenuHandler#OnEnable", this ); }

                if (!this.firstPlay) {
                    this.InitState();
                }
            },
            /*TabMenuHandler.OnEnable end.*/

            /*TabMenuHandler.InitState start.*/
            InitState: function () {
if ( TRACE ) { TRACE( "TabMenuHandler#InitState", this ); }

                this.ResetTabs();

                this.nextable = false;
                this.done_Btn.SetActive(false);
                this.next_Btn.SetActive(true);

                //slider.value = 1;
            },
            /*TabMenuHandler.InitState end.*/

            /*TabMenuHandler.ResetTabs start.*/
            ResetTabs: function () {
if ( TRACE ) { TRACE( "TabMenuHandler#ResetTabs", this ); }

                this.index = 0;
                for (var i = 0; i < this.tabSelection.Count; i = (i + 1) | 0) {
                    if (i === this.index) {
                        this.tabSelection.getItem(i).OnDisplay();
                    } else {
                        this.tabSelection.getItem(i).Reset();
                    }
                    this.tabContents.getItem(i).SetStateContent(i === this.index);
                }
            },
            /*TabMenuHandler.ResetTabs end.*/

            /*TabMenuHandler.TurnOnNextBtn start.*/
            TurnOnNextBtn: function () {
if ( TRACE ) { TRACE( "TabMenuHandler#TurnOnNextBtn", this ); }

                this.nextable = true;
                this.nextBtn.color = new pc.Color( 1, 1, 1, 1 );
            },
            /*TabMenuHandler.TurnOnNextBtn end.*/

            /*TabMenuHandler.SetStateNextBtn start.*/
            SetStateNextBtn: function (id) {
if ( TRACE ) { TRACE( "TabMenuHandler#SetStateNextBtn", this ); }

                this.nextable = ShopController.Instance.CheckNextStep(id);
                if (!this.nextable) {
                    this.nextBtn.color = this.fade.$clone();
                }
            },
            /*TabMenuHandler.SetStateNextBtn end.*/

            /*TabMenuHandler.NextTab start.*/
            NextTab: function () {
if ( TRACE ) { TRACE( "TabMenuHandler#NextTab", this ); }

                if (((this.index + 1) | 0) === this.tabContents.Count || !this.nextable || !CameraHandler.Instance.Clickable) {
                    return;
                } //delay


                if (((this.index + 2) | 0) === this.tabContents.Count) {
                    if (ShopController.Instance.IsPickBody) {
                        UIHandler.Instance.UI_Ingame.ChangeIconToDone();
                    }
                }

                this.SetStateNextBtn(((this.index + 1) | 0));
                this.handtut.SetActive(false);

                //next.Play();
                this.tabSelection.getItem(this.index).OnExit(true);
                this.tabContents.getItem(this.index).SetStateContent(false);

                this.index = (((this.index + 1) | 0)) % this.tabSelection.Count;

                this.tabSelection.getItem(this.index).OnDisplay();
                this.tabContents.getItem(this.index).SetStateContent(true);
                ShopController.Instance.SetCurrenBodyPartController(this.index);

                SoundManager.Instance.PlaySound(Sound.next);
            },
            /*TabMenuHandler.NextTab end.*/


        }
    });
    /*TabMenuHandler end.*/

    /*Theme start.*/
    Bridge.define("Theme", {
        $kind: 6,
        statics: {
            fields: {
                Toilet: 0,
                Concert: 1,
                Beach: 2
            }
        }
    });
    /*Theme end.*/

    /*TouchController start.*/
    Bridge.define("TouchController", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rb: null,
            deltaX: 0,
            deltaY: 0,
            mousePos: null,
            speed: 0,
            isDrawing: false,
            corners: null,
            _camera: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TouchController#init", this ); }

                this.mousePos = new UnityEngine.Vector3();
                this.isDrawing = false;
                this.corners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
            }
        },
        methods: {
            /*TouchController.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "TouchController#Start", this ); }

                UIHandler.Instance.limitArea.GetWorldCorners(this.corners);
                this._camera = UnityEngine.Camera.main;
            },
            /*TouchController.Start end.*/

            /*TouchController.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "TouchController#OnValidate", this ); }

                this.rb = this.GetComponent(UnityEngine.Rigidbody2D);
            },
            /*TouchController.OnValidate end.*/

            /*TouchController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "TouchController#Update", this ); }

                this.Drawing();
            },
            /*TouchController.Update end.*/

            /*TouchController.LimitPosition start.*/
            LimitPosition: function (position) {
if ( TRACE ) { TRACE( "TouchController#LimitPosition", this ); }


                if (position.x < this.corners[0].x) {
                    position.x = this.corners[0].x;
                }
                if (position.x > this.corners[3].x) {
                    position.x = this.corners[3].x;
                }
                if (position.y < this.corners[0].y) {
                    position.y = this.corners[0].y;
                }
                if (position.y > this.corners[1].y) {
                    position.y = this.corners[1].y;
                }
                return position.$clone();
                //transform.position = position;
            },
            /*TouchController.LimitPosition end.*/

            /*TouchController.Drawing start.*/
            Drawing: function () {
if ( TRACE ) { TRACE( "TouchController#Drawing", this ); }

                // WARNING: DO NOT CHANGE THE ORDER !
                this.EndDraw();
                this.InDraw();
                this.BeginDraw();
            },
            /*TouchController.Drawing end.*/

            /*TouchController.BeginDraw start.*/
            BeginDraw: function () {
if ( TRACE ) { TRACE( "TouchController#BeginDraw", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0) && UnityEngine.GameObject.op_Equality(UnityEngine.EventSystems.EventSystem.current.currentSelectedGameObject, null)) {
                    if (this.isDrawing === false) {
                        this.isDrawing = true;
                        // Your code here!
                        this.mousePos = this._camera.ScreenToWorldPoint(UnityEngine.Input.mousePosition).add( new pc.Vec3( 0, 0, 10 ) );
                        this.deltaX = this.mousePos.x - this.transform.position.x;
                        this.deltaY = this.mousePos.y - this.transform.position.y;
                    }
                }
            },
            /*TouchController.BeginDraw end.*/

            /*TouchController.InDraw start.*/
            InDraw: function () {
if ( TRACE ) { TRACE( "TouchController#InDraw", this ); }

                if (this.isDrawing && UnityEngine.GameObject.op_Equality(UnityEngine.EventSystems.EventSystem.current.currentSelectedGameObject, null)) {
                    this.rb.MovePosition$1(this.LimitPosition(UnityEngine.Vector3.FromVector2(new pc.Vec2( this.mousePos.x - this.deltaX, this.mousePos.y - this.deltaY ))));
                    this.mousePos = this._camera.ScreenToWorldPoint(UnityEngine.Input.mousePosition).add( new pc.Vec3( 0, 0, 10 ) );
                }
            },
            /*TouchController.InDraw end.*/

            /*TouchController.EndDraw start.*/
            EndDraw: function () {
if ( TRACE ) { TRACE( "TouchController#EndDraw", this ); }

                var $t;
                if ((UnityEngine.Input.touchCount < 2 && UnityEngine.Input.GetMouseButtonUp(0)) || (UnityEngine.Input.touchCount >= 2 && ($t = UnityEngine.Input.touches)[0].phase === UnityEngine.TouchPhase.Ended)) {
                    if (this.isDrawing === true) {
                        this.isDrawing = false;
                        this.rb.velocity = pc.Vec2.ZERO.clone();
                    }
                }
            },
            /*TouchController.EndDraw end.*/


        }
    });
    /*TouchController end.*/

    /*TutHand start.*/
    Bridge.define("TutHand", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rt: null
        },
        methods: {
            /*TutHand.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TutHand#OnEnable", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.rt);
                DG.Tweening.DOTweenModuleUI.DOAnchorPosY(this.rt, 180, 0);
                DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTweenModuleUI.DOAnchorPosY(this.rt, 140, 0.4), DG.Tweening.Ease.InOutSine), -1, DG.Tweening.LoopType.Yoyo);
            },
            /*TutHand.OnEnable end.*/

            /*TutHand.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TutHand#OnDisable", this ); }

                DG.Tweening.ShortcutExtensions.DOKill(this.transform);
            },
            /*TutHand.OnDisable end.*/


        }
    });
    /*TutHand end.*/

    /*UI_Endgame start.*/
    Bridge.define("UI_Endgame", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            canvasGroup: null
        },
        methods: {
            /*UI_Endgame.OnEntrance start.*/
            OnEntrance: function () {
if ( TRACE ) { TRACE( "UI_Endgame#OnEntrance", this ); }

                Luna.Unity.LifeCycle.GameEnded();
                this.gameObject.SetActive(true);
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFade(this.canvasGroup, 1, 0.3), DG.Tweening.Ease.InOutSine);
                Luna.Unity.Analytics.LogEvent(Luna.Unity.Analytics.EventType.EndCardShown);
            },
            /*UI_Endgame.OnEntrance end.*/

            /*UI_Endgame.OnClickDownload start.*/
            OnClickDownload: function () {
if ( TRACE ) { TRACE( "UI_Endgame#OnClickDownload", this ); }

                UnityEngine.Application.OpenURL("https://apps.apple.com/us/app/toilet-makeover-mix-monsters/id6448269598");
                Luna.Unity.Playable.InstallFullGame();
            },
            /*UI_Endgame.OnClickDownload end.*/


        }
    });
    /*UI_Endgame end.*/

    /*UI_Ingame start.*/
    Bridge.define("UI_Ingame", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            nextBtn: null,
            doneBtn: null,
            tabMenuElements: null
        },
        methods: {
            /*UI_Ingame.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UI_Ingame#OnEnable", this ); }


                UnityEngine.Input.multiTouchEnabled = false;
                this.doneBtn.interactable = true;
            },
            /*UI_Ingame.OnEnable end.*/

            /*UI_Ingame.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "UI_Ingame#Start", this ); }

                var $t, $t1;
                if (CameraHandler.Instance.aspectRatio === AspectRatio.AR34) {
                    $t = Bridge.getEnumerator(this.tabMenuElements);
                    try {
                        while ($t.moveNext()) {
                            var tab = $t.Current;
                            tab.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( 1.25 );
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                } else if (CameraHandler.Instance.aspectRatio === AspectRatio.AR916) {
                    $t1 = Bridge.getEnumerator(this.tabMenuElements);
                    try {
                        while ($t1.moveNext()) {
                            var tab1 = $t1.Current;
                            tab1.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( 1.1 );
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*UI_Ingame.Start end.*/

            /*UI_Ingame.DeactiveDoneBtn start.*/
            DeactiveDoneBtn: function () {
if ( TRACE ) { TRACE( "UI_Ingame#DeactiveDoneBtn", this ); }

                this.doneBtn.interactable = false;
            },
            /*UI_Ingame.DeactiveDoneBtn end.*/

            /*UI_Ingame.ChangeIconToDone start.*/
            ChangeIconToDone: function () {
if ( TRACE ) { TRACE( "UI_Ingame#ChangeIconToDone", this ); }

                this.doneBtn.gameObject.SetActive(true);
                this.nextBtn.SetActive(false);
            },
            /*UI_Ingame.ChangeIconToDone end.*/


        }
    });
    /*UI_Ingame end.*/

    /*UI_Result start.*/
    Bridge.define("UI_Result", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            moneyTxt: null,
            bgAnim: null,
            ingameBg: null,
            characterZone: null,
            characterManager: null,
            extraMonster1: null,
            extraMonster2: null,
            shopController: null,
            timer: 0,
            range: 0,
            money: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UI_Result#init", this ); }

                this.timer = 0;
                this.range = 0.8;
                this.money = 900;
            }
        },
        methods: {
            /*UI_Result.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UI_Result#OnEnable", this ); }

                this.shopController = ShopController.Instance;

                this.money = 1000;
                this.moneyTxt.text = "$" + (System.Int32.format(this.money, "N0") || "");


                this.ingameBg.SetActive(false);
                this.bgAnim.SetActive(true);

                this.characterZone.localPosition = new pc.Vec3( 0, 1.5, 0 );
                this.characterManager.SetScale(0.9);
                this.characterManager.SetPos(new pc.Vec3( 0, -2.2, 0 ));

                this.HandleExtraMonster1();
                this.HandleExtraMonster2();
            },
            /*UI_Result.OnEnable end.*/

            /*UI_Result.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "UI_Result#Update", this ); }

                if (this.timer < this.range) {
                    this.timer += UnityEngine.Time.deltaTime;
                    return;
                }
                if (this.money > 50000) {
                    return;
                }
                this.money = (this.money + 1400) | 0;
                this.moneyTxt.text = "$" + (System.Int32.format(this.money, "N0") || "");
                this.timer = 0;
            },
            /*UI_Result.Update end.*/

            /*UI_Result.HandleExtraMonster1 start.*/
            HandleExtraMonster1: function () {
if ( TRACE ) { TRACE( "UI_Result#HandleExtraMonster1", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var head = null, eye = null, mouth = null, acc = null, body = null;

                for (var i = 0; i < this.shopController.heads.length; i = (i + 1) | 0) {
                    head = ($t = this.shopController.heads)[i];
                    if (!Bridge.referenceEquals(head, this.shopController.CurrentHead)) {
                        break;
                    }
                }

                for (var i1 = 0; i1 < this.shopController.eyes.length; i1 = (i1 + 1) | 0) {
                    eye = ($t1 = this.shopController.eyes)[i1];
                    if (!Bridge.referenceEquals(eye, this.shopController.CurrentEye)) {
                        break;
                    }
                }

                for (var i2 = 0; i2 < this.shopController.mouths.length; i2 = (i2 + 1) | 0) {
                    mouth = ($t2 = this.shopController.mouths)[i2];
                    if (!Bridge.referenceEquals(mouth, this.shopController.CurrentMouth)) {
                        break;
                    }
                }

                for (var i3 = 0; i3 < this.shopController.accs.length; i3 = (i3 + 1) | 0) {
                    acc = ($t3 = this.shopController.accs)[i3];
                    if (!Bridge.referenceEquals(acc, this.shopController.CurrentAcc)) {
                        break;
                    }
                }

                for (var i4 = 0; i4 < this.shopController.bodies.length; i4 = (i4 + 1) | 0) {
                    body = ($t4 = this.shopController.bodies)[i4];
                    if (!Bridge.referenceEquals(body, this.shopController.CurrentBody)) {
                        break;
                    }
                }

                this.extraMonster1.CreateMonster(head, eye, mouth, acc, body);
            },
            /*UI_Result.HandleExtraMonster1 end.*/

            /*UI_Result.HandleExtraMonster2 start.*/
            HandleExtraMonster2: function () {
if ( TRACE ) { TRACE( "UI_Result#HandleExtraMonster2", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var head = null, eye = null, mouth = null, acc = null, body = null;

                for (var i = (this.shopController.heads.length - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    head = ($t = this.shopController.heads)[i];
                    if (!Bridge.referenceEquals(head, this.shopController.CurrentHead)) {
                        break;
                    }
                }

                for (var i1 = (this.shopController.eyes.length - 1) | 0; i1 >= 0; i1 = (i1 - 1) | 0) {
                    eye = ($t1 = this.shopController.eyes)[i1];
                    if (!Bridge.referenceEquals(eye, this.shopController.CurrentEye)) {
                        break;
                    }
                }

                for (var i2 = (this.shopController.mouths.length - 1) | 0; i2 >= 0; i2 = (i2 - 1) | 0) {
                    mouth = ($t2 = this.shopController.mouths)[i2];
                    if (!Bridge.referenceEquals(mouth, this.shopController.CurrentMouth)) {
                        break;
                    }
                }

                for (var i3 = (this.shopController.accs.length - 1) | 0; i3 >= 0; i3 = (i3 - 1) | 0) {
                    acc = ($t3 = this.shopController.accs)[i3];
                    if (!Bridge.referenceEquals(acc, this.shopController.CurrentAcc)) {
                        break;
                    }
                }

                for (var i4 = (this.shopController.bodies.length - 1) | 0; i4 >= 0; i4 = (i4 - 1) | 0) {
                    body = ($t4 = this.shopController.bodies)[i4];
                    if (!Bridge.referenceEquals(body, this.shopController.CurrentBody)) {
                        break;
                    }
                }

                this.extraMonster2.CreateMonster(head, eye, mouth, acc, body);
            },
            /*UI_Result.HandleExtraMonster2 end.*/


        }
    });
    /*UI_Result end.*/

    /*UI_Transition start.*/
    Bridge.define("UI_Transition", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            canvasGroup: null
        },
        methods: {
            /*UI_Transition.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "UI_Transition#Start", this ); }

                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFade(this.canvasGroup, 1, 0.3), DG.Tweening.Ease.InOutSine);
                this.Invoke("OnExit", 1.2);
            },
            /*UI_Transition.Start end.*/

            /*UI_Transition.OnExit start.*/
            OnExit: function () {
if ( TRACE ) { TRACE( "UI_Transition#OnExit", this ); }

                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFade(this.canvasGroup, 0, 0.3), DG.Tweening.Ease.InOutSine);
            },
            /*UI_Transition.OnExit end.*/


        }
    });
    /*UI_Transition end.*/

    /*UIHandler start.*/
    Bridge.define("UIHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            uI_Result: null,
            uI_Ingame: null,
            endGamePanel: null,
            transition: null,
            limitArea: null,
            bodyAnim: null,
            bodyAnim2: null,
            character: null,
            moneyRain: null,
            curtainAnim: null
        },
        props: {
            UI_Ingame: {
                get: function () {
if ( TRACE ) { TRACE( "UIHandler#UI_Ingame#get", this ); }

                    return this.uI_Ingame;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UIHandler#UI_Ingame#set", this ); }

                    this.uI_Ingame = value;
                }
            }
        },
        methods: {
            /*UIHandler.PauseGameplay start.*/
            PauseGameplay: function () {
if ( TRACE ) { TRACE( "UIHandler#PauseGameplay", this ); }

                UnityEngine.Time.timeScale = 0;
                SoundManager.Instance.ChangePitch(0);
            },
            /*UIHandler.PauseGameplay end.*/

            /*UIHandler.ResumeGameplay start.*/
            ResumeGameplay: function () {
if ( TRACE ) { TRACE( "UIHandler#ResumeGameplay", this ); }

                UnityEngine.Time.timeScale = 1;
                SoundManager.Instance.ChangePitch(1);
            },
            /*UIHandler.ResumeGameplay end.*/

            /*UIHandler.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "UIHandler#Awake", this ); }

                UIHandler.Instance = this;


                Luna.Unity.LifeCycle.addOnPause(Bridge.fn.cacheBind(this, this.PauseGameplay));
                Luna.Unity.LifeCycle.addOnResume(Bridge.fn.cacheBind(this, this.ResumeGameplay));
            },
            /*UIHandler.Awake end.*/

            /*UIHandler.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "UIHandler#Start", this ); }

                EventDispatcherExtension.PostEvent(this, EventID.OnStart);
            },
            /*UIHandler.Start end.*/

            /*UIHandler.HandleDoneBtn start.*/
            HandleDoneBtn: function () {
if ( TRACE ) { TRACE( "UIHandler#HandleDoneBtn", this ); }

                this.StartCoroutine$1(this.PlayEffect());
                this.transition.gameObject.SetActive(true);
                SoundManager.Instance.PauseSound(Sound.bg);
                SoundManager.Instance.PlaySound(Sound.outtro);
            },
            /*UIHandler.HandleDoneBtn end.*/

            /*UIHandler.Done start.*/
            Done: function () {
if ( TRACE ) { TRACE( "UIHandler#Done", this ); }

                this.HandleDoneBtn();
            },
            /*UIHandler.Done end.*/

            /*UIHandler.PlayEffect start.*/
            /**
             * 0: normal, 1: challenge
             *
             * @instance
             * @private
             * @this UIHandler
             * @memberof UIHandler
             * @param   {number}                            _typeMode
             * @return  {System.Collections.IEnumerator}
             */
            PlayEffect: function (_typeMode) {
if ( TRACE ) { TRACE( "UIHandler#PlayEffect", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (_typeMode === void 0) { _typeMode = 0; }
                                        $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    CameraHandler.Instance.SetPosOfCamera(new pc.Vec3( 0, -2.8, -10 ));

                                        this.uI_Ingame.gameObject.SetActive(false);

                                        this.PlayDanceAnimForMonster();


                                        this.uI_Result.gameObject.SetActive(true);
                                        this.moneyRain.Play();

                                        $enumerator.current = new UnityEngine.WaitForSeconds(2.0);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    //curtainAnim.gameObject.SetActive(false);

                                        $enumerator.current = new UnityEngine.WaitForSeconds(2.0);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    this.endGamePanel.OnEntrance();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*UIHandler.PlayEffect end.*/

            /*UIHandler.PlayDanceAnimForMonster start.*/
            PlayDanceAnimForMonster: function () {
if ( TRACE ) { TRACE( "UIHandler#PlayDanceAnimForMonster", this ); }

                var $t, $t1;
                if (this.bodyAnim.gameObject.activeSelf) {
                    this.bodyAnim.Skeleton.setSkinByName(($t = ShopController.Instance.Bodies)[UnityEngine.PlayerPrefs.GetInt("Body")].bodypartName);
                    this.bodyAnim.AnimationState.setAnimation(0, "Zerotwo", true);
                    this.bodyAnim.Skeleton.setToSetupPose();
                } else if (this.bodyAnim2.gameObject.activeSelf) {
                    var body = ($t1 = ShopController.Instance.Bodies)[UnityEngine.PlayerPrefs.GetInt("Body")];
                    this.bodyAnim2.Skeleton.setSkinByName((System.Enum.toString(CatalogueTheme, body.catalogue) || "") + "/" + (body.bodypartName || ""));
                    var randomIdx = UnityEngine.Random.Range(0, 4);
                    if (randomIdx <= 1) {
                        this.bodyAnim2.AnimationState.setAnimation(0, "Zerotwo", true);
                    } else {
                        this.bodyAnim2.AnimationState.setAnimation(0, "Zerotwo" + randomIdx, true);
                    }
                    this.bodyAnim2.Skeleton.setToSetupPose();
                }
            },
            /*UIHandler.PlayDanceAnimForMonster end.*/


        }
    });
    /*UIHandler end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    /**
     * Holds a reference to a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonDataAsset
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonDataAsset", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        statics: {
            methods: {
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static start.*/
                ApplyMaterials: function (skeletonData, multiplyTemplate, screenTemplate, additiveTemplate, includeAdditiveSlots) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials", this ); }

                    var $t, $t1;
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor1("skeletonData");
                    }

                    var materialCache = new Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache();
                    try {
                        var entryBuffer = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                        var slotsItems = skeletonData.Slots.Items;
                        for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                            var slot = slotsItems[slotIndex];
                            if (slot.blendMode === spine.BlendMode.Normal) {
                                continue;
                            }
                            if (!includeAdditiveSlots && slot.blendMode === spine.BlendMode.Additive) {
                                continue;
                            }

                            entryBuffer.clear();
                            $t = Bridge.getEnumerator(skeletonData.Skins);
                            try {
                                while ($t.moveNext()) {
                                    var skin = $t.Current;
                                    ( entryBuffer._items.length = 0, skin.getAttachmentsForSlot( slotIndex, entryBuffer._items ), entryBuffer._size = entryBuffer._items.length );
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            var templateMaterial = null;
                            switch (slot.blendMode) {
                                case spine.BlendMode.Multiply: 
                                    templateMaterial = multiplyTemplate;
                                    break;
                                case spine.BlendMode.Screen: 
                                    templateMaterial = screenTemplate;
                                    break;
                                case spine.BlendMode.Additive: 
                                    templateMaterial = additiveTemplate;
                                    break;
                            }
                            if (templateMaterial == null) {
                                continue;
                            }

                            $t1 = Bridge.getEnumerator(entryBuffer);
                            try {
                                while ($t1.moveNext()) {
                                    var entry = $t1.Current;
                                    var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasTextureRegion);
                                    if (renderableAttachment != null) {
                                        renderableAttachment.Spine$IHasTextureRegion$Region = materialCache.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), templateMaterial);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }

                    }
                    finally {
                        if (Bridge.hasValue(materialCache)) {
                            materialCache.System$IDisposable$Dispose();
                        }
                    }
                    //attachmentBuffer.Clear();
                },
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static end.*/


            }
        },
        fields: {
            multiplyMaterialTemplate: null,
            screenMaterialTemplate: null,
            additiveMaterialTemplate: null,
            applyAdditiveMaterial: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#init", this ); }

                this.applyAdditiveMaterial = true;
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset.Apply start.*/
            Apply: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#Apply", this ); }

                Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials(skeletonData, this.multiplyMaterialTemplate, this.screenMaterialTemplate, this.additiveMaterialTemplate, this.applyAdditiveMaterial);
            },
            /*Spine.Unity.BlendModeMaterialsAsset.Apply end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    /**
     * A Spine-Unity Component that uses a Spine.AnimationState to animate its skeleton.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IAnimationStateComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IAnimationStateComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    /**
     * A Spine-Unity Component that holds a reference to an ISkeletonComponent.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    /**
     * A Spine-Unity Component that holds a reference to a SkeletonRenderer.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonRenderer
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonRenderer", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    /**
     * A Spine-Unity Component that animates a Skeleton but not necessarily with a Spine.AnimationState.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonAnimation
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonAnimation", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    /**
     * A Spine-Unity Component that manages a Spine.Skeleton instance, instantiated from a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    /**
     * Add this component to a SkeletonMecanim GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonMecanimRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonMecanimRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultMecanimLayerFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                    this.DefaultMecanimLayerFlags = -1;
                }
            }
        },
        fields: {
            mecanimLayerFlags: 0,
            movementDelta: null,
            rotationDelta: 0,
            skeletonMecanim: null
        },
        props: {
            SkeletonMecanim: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonMecanim) ? this.skeletonMecanim : (this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                this.movementDelta = new UnityEngine.Vector2();
                this.mecanimLayerFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var start = time;
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }
                return this.GetAnimationRootMotionInfo(animation, time);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.mecanimLayerFlags = Spine.Unity.SkeletonMecanimRootMotion.DefaultMecanimLayerFlags;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim);
                if (UnityEngine.Object.op_Implicit(this.skeletonMecanim)) {
                    this.skeletonMecanim.Translator.removeOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                    this.skeletonMecanim.Translator.addOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Start end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied start.*/
            OnClipApplied: function (animation, layerIndex, weight, time, lastTime, playsBackward) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied", this ); }


                if (((this.mecanimLayerFlags & 1 << layerIndex) === 0) || weight === 0) {
                    return;
                }

                if (!playsBackward) {
                    this.movementDelta = this.movementDelta.$clone().add( this.GetAnimationRootMotion$1(lastTime, time, animation).scale( weight ) );
                } else {
                    this.movementDelta = this.movementDelta.$clone().sub( this.GetAnimationRootMotion$1(time, lastTime, animation).scale( weight ) );
                }
                if (this.transformRotation) {
                    if (!playsBackward) {
                        this.rotationDelta += weight * this.GetAnimationRootMotionRotation$1(lastTime, time, animation);
                    } else {
                        this.rotationDelta -= weight * this.GetAnimationRootMotionRotation$1(time, lastTime, animation);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta", this ); }

                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.movementDelta.$clone();
                this.movementDelta = pc.Vec2.ZERO.clone();
                return result.$clone();
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta", this ); }

                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.rotationDelta;
                this.rotationDelta = 0;
                return result;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    /**
     * Add this component to a SkeletonAnimation or SkeletonGraphic GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultAnimationTrackFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                    this.DefaultAnimationTrackFlags = -1;
                }
            }
        },
        fields: {
            animationTrackFlags: 0,
            animationState: null,
            canvas: null
        },
        props: {
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#AdditionalScale#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.canvas) ? this.canvas.referencePixelsPerUnit : 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                this.animationTrackFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion", this ); }

                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var animation = track.animation;
                var start = track.getAnimationTime();
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRootMotionInfo", this ); }

                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }

                var animation = track.animation;
                var time = track.getAnimationTime();
                return this.GetAnimationRootMotionInfo(track.animation, time);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.animationTrackFlags = Spine.Unity.SkeletonRootMotion.DefaultAnimationTrackFlags;
            },
            /*Spine.Unity.SkeletonRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                var animstateComponent = Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent);
                this.animationState = (animstateComponent != null) ? animstateComponent.Spine$Unity$IAnimationStateComponent$AnimationState : null;

                if (UnityEngine.Component.op_Inequality(this.GetComponent(UnityEngine.CanvasRenderer), null)) {
                    this.canvas = this.GetComponentInParent(UnityEngine.Canvas);
                }
            },
            /*Spine.Unity.SkeletonRootMotion.Start end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta", this ); }

                var localDelta = pc.Vec2.ZERO.clone();
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.getCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.animation;
                        var start = track.animationLast;
                        var end = track.getAnimationTime();
                        var currentDelta = { v : this.GetAnimationRootMotion$1(start, end, animation) };
                        if (!pc.Vec2.equals( currentDelta.v, pc.Vec2.ZERO.clone() )) {
                            this.ApplyMixAlphaToDelta$1(currentDelta, next, track);
                            localDelta = localDelta.$clone().add( currentDelta.v.$clone() );
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta", this ); }

                var localDelta = 0;
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.getCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.animation;
                        var start = track.animationLast;
                        var end = track.getAnimationTime();
                        var currentDelta = { v : this.GetAnimationRootMotionRotation$1(start, end, animation) };
                        if (currentDelta.v !== 0) {
                            this.ApplyMixAlphaToDelta(currentDelta, next, track);
                            localDelta += currentDelta.v;
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta;
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 start.*/
            ApplyMixAlphaToDelta$1: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1", this ); }

                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v = currentDelta.v.$clone().scale( mixAlpha.v );
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta start.*/
            ApplyMixAlphaToDelta: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta", this ); }

                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v *= mixAlpha.v;
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha start.*/
            GetMixAlpha: function (cumulatedMixAlpha, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetMixAlpha", this ); }

                // code below based on AnimationState.cs
                var mix;
                if (next != null) {
                    if (next.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                        mix = 1;
                    } else {
                        mix = next.mixTime / next.mixDuration;
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    var mixAndAlpha = track.alpha * next.interruptAlpha * (1 - mix);
                    cumulatedMixAlpha.v *= mixAndAlpha;
                } else {
                    if (track.mixDuration === 0) {
                        mix = 1;
                    } else {
                        mix = track.alpha * (track.mixTime / track.mixDuration);
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    cumulatedMixAlpha.v *= mix;
                }
            },
            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha end.*/


        },
        overloads: {
            "ApplyMixAlphaToDelta(Vector2, TrackEntry, TrackEntry)": "ApplyMixAlphaToDelta$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SpineAnimation start.*/
    Bridge.define("Spine.Unity.SpineAnimation", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAnimation#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAnimation end.*/
    /**
     * @memberof System
     * @callback System.Func
     * @param   {Spine.Unity.SpineAtlasAsset}    arg
     * @return  {Spine.TextureLoader}
     */


    /*Spine.Unity.SpineAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}           atlasText                 
                 * @param   {Array.<UnityEngine.Material>}    materials                 
                 * @param   {boolean}                         initialize                
                 * @param   {System.Func}                     newCustomTextureLoader    When not null, a function instantiating
                 a custom <pre><code>TextureLoader</code></pre> with the newly created <pre><code>SpineAtlasAsset</code></pre> as argument
                 is used instead of instantiating the default <pre><code>MaterialsTextureLoader</code></pre>.
                 A valid parameter is e.g. <pre><code>(a) =&gt; new CustomTextureLoader(a)</code></pre>
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 */
                CreateRuntimeInstance: function (atlasText, materials, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.atlasFile = atlasText;
                    atlasAsset.materials = materials;
                    if (!Bridge.staticEquals(newCustomTextureLoader, null)) {
                        atlasAsset.customTextureLoader = newCustomTextureLoader(atlasAsset);
                    }

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower
                 because it has to search for atlas page matches.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText                 
                 * @param   {Array.<UnityEngine.Texture2D>}    textures                  An array of all textures referenced in the provided <pre><code>atlasText</code></pre>
                 atlas asset JSON file. When procedurally creating textures, each <pre><code>Texture.name</code></pre>
                 needs to be set to the atlas page texture filename without the .png extension,
                 e.g. 'my_skeleton' if the png filename listed in the atlas asset file is 'my_skeleton.png'.
                 * @param   {UnityEngine.Material}             materialPropertySource    
                 * @param   {boolean}                          initialize                
                 * @param   {System.Func}                      newCustomTextureLoader
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool, Func{SpineAtlasAsset, TextureLoader})}
                 */
                CreateRuntimeInstance$1: function (atlasText, textures, materialPropertySource, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    // Get atlas page names.
                    var atlasString = atlasText.text;
                    atlasString = System.String.replaceAll(atlasString, "\r", "");
                    var atlasLines = System.String.split(atlasString, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                    var pages = new (System.Collections.Generic.List$1(System.String)).ctor();
                    for (var i = 0; i < ((atlasLines.length - 1) | 0); i = (i + 1) | 0) {
                        var line = atlasLines[i].trim();
                        if (System.String.endsWith(line, ".png")) {
                            pages.add(System.String.replaceAll(line, ".png", ""));
                        }
                    }

                    // Populate Materials[] by matching texture names with page names.
                    var materials = System.Array.init(pages.Count, null, UnityEngine.Material);
                    for (var i1 = 0, n = pages.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        var mat = null;

                        // Search for a match.
                        var pageName = pages.getItem(i1);
                        for (var j = 0, m = textures.length; j < m; j = (j + 1) | 0) {
                            if (System.String.equals(pageName, textures[j].name, 5)) {
                                // Match found.
                                mat = new UnityEngine.Material.$ctor1(materialPropertySource);
                                mat.mainTexture = textures[j];
                                break;
                            }
                        }

                        if (mat != null) {
                            materials[i1] = mat;
                        } else {
                            throw new System.ArgumentException.$ctor1("Could not find matching atlas page in the texture array.");
                        }
                    }

                    // Create AtlasAsset normally
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(atlasText, materials, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static start.*/
                
                CreateRuntimeInstance$2: function (atlasText, textures, shader, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    if (shader == null) {
                        shader = UnityEngine.Shader.Find("Spine/Skeleton");
                    }

                    var materialProperySource = new UnityEngine.Material.$ctor2(shader);
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(atlasText, textures, materialProperySource, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static end.*/


            }
        },
        fields: {
            atlasFile: null,
            materials: null,
            customTextureLoader: null,
            atlas: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineAtlasAsset
             * @memberof Spine.Unity.SpineAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.atlasFile == null) {
                    UnityEngine.Debug.LogError$2("Atlas file not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    var loader;
                    if (!onlyMetaData) {
                        loader = this.customTextureLoader == null ? new Spine.Unity.MaterialsTextureLoader(this) : this.customTextureLoader;
                    } else {
                        loader = new Spine.Unity.NoOpTextureLoader();
                    }
                    this.atlas = new Spine.Atlas.$ctor1(new System.IO.StringReader(this.atlasFile.text), "", loader);
                    this.atlas.FlipV();
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error reading atlas file for atlas asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineAtlasAsset.GenerateMesh start.*/
            GenerateMesh: function (name, mesh, material, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GenerateMesh", this ); }

                if (scale === void 0) { scale = 0.01; }
                var region = this.atlas.findRegion(name);
                material.v = null;
                if (region != null) {
                    if (mesh == null) {
                        mesh = new UnityEngine.Mesh.ctor();
                        mesh.name = name;
                    }

                    var verts = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var uvs = System.Array.init(4, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    var colors = System.Array.init([
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 )
                    ], UnityEngine.Color);
                    var triangles = System.Array.init([
                        0, 
                        1, 
                        2, 
                        2, 
                        3, 
                        0
                    ], System.Int32);

                    var left, right, top, bottom;
                    left = region.width / -2.0;
                    right = left * -1.0;
                    top = region.height / 2.0;
                    bottom = top * -1;

                    verts[0] = new pc.Vec3( left, bottom, 0 ).clone().scale( scale );
                    verts[1] = new pc.Vec3( left, top, 0 ).clone().scale( scale );
                    verts[2] = new pc.Vec3( right, top, 0 ).clone().scale( scale );
                    verts[3] = new pc.Vec3( right, bottom, 0 ).clone().scale( scale );
                    var u, v, u2, v2;
                    u = region.u;
                    v = region.v;
                    u2 = region.u2;
                    v2 = region.v2;

                    if (region.degrees === 90) {
                        uvs[0] = new pc.Vec2( u2, v2 );
                        uvs[1] = new pc.Vec2( u, v2 );
                        uvs[2] = new pc.Vec2( u, v );
                        uvs[3] = new pc.Vec2( u2, v );
                    } else {
                        uvs[0] = new pc.Vec2( u, v2 );
                        uvs[1] = new pc.Vec2( u, v );
                        uvs[2] = new pc.Vec2( u2, v );
                        uvs[3] = new pc.Vec2( u2, v2 );
                    }

                    mesh.triangles = System.Array.init(0, 0, System.Int32);
                    mesh.vertices = verts;
                    mesh.uv = uvs;
                    mesh.colors = colors;
                    mesh.triangles = triangles;
                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();

                    material.v = Bridge.cast(region.page.rendererObject, UnityEngine.Material);
                } else {
                    mesh = null;
                }

                return mesh;
            },
            /*Spine.Unity.SpineAtlasAsset.GenerateMesh end.*/


        }
    });
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAttachment start.*/
    Bridge.define("Spine.Unity.SpineAttachment", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAttachment.getHierarchy:static start.*/
                getHierarchy: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getHierarchy", this ); }

                    return new Spine.Unity.SpineAttachment.Hierarchy.$ctor1(fullPath);
                },
                /*Spine.Unity.SpineAttachment.getHierarchy:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment:static start.*/
                getAttachment: function (attachmentPath, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment", this ); }

                    var hierarchy = Spine.Unity.SpineAttachment.getHierarchy(attachmentPath);
                    if (System.String.isNullOrEmpty(hierarchy.name)) {
                        return null;
                    }

                    var slot = skeletonData.findSlot(hierarchy.slot);
                    if (slot == null) {
                        return null;
                    }
                    return skeletonData.findSkin(hierarchy.skin).getAttachment(slot.index, hierarchy.name);
                },
                /*Spine.Unity.SpineAttachment.getAttachment:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment$1:static start.*/
                getAttachment$1: function (attachmentPath, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment$1", this ); }

                    return Spine.Unity.SpineAttachment.getAttachment(attachmentPath, skeletonDataAsset.GetSkeletonData(true));
                },
                /*Spine.Unity.SpineAttachment.getAttachment$1:static end.*/


            }
        },
        fields: {
            returnAttachmentPath: false,
            currentSkinOnly: false,
            placeholdersOnly: false,
            skinField: null,
            slotField: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#init", this ); }

                this.returnAttachmentPath = false;
                this.currentSkinOnly = false;
                this.placeholdersOnly = false;
                this.skinField = "";
                this.slotField = "";
            },
            
            ctor: function (currentSkinOnly, returnAttachmentPath, placeholdersOnly, slotField, dataField, skinField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#ctor", this ); }

                if (currentSkinOnly === void 0) { currentSkinOnly = true; }
                if (returnAttachmentPath === void 0) { returnAttachmentPath = false; }
                if (placeholdersOnly === void 0) { placeholdersOnly = false; }
                if (slotField === void 0) { slotField = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (skinField === void 0) { skinField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.currentSkinOnly = currentSkinOnly;
                this.returnAttachmentPath = returnAttachmentPath;
                this.placeholdersOnly = placeholdersOnly;
                this.slotField = slotField;
                this.dataField = dataField;
                this.skinField = skinField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineBone start.*/
    Bridge.define("Spine.Unity.SpineBone", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineBone.getBone:static start.*/
                getBone: function (boneName, renderer) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBone", this ); }

                    return renderer.skeleton == null ? null : renderer.skeleton.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBone:static end.*/

                /*Spine.Unity.SpineBone.getBoneData:static start.*/
                getBoneData: function (boneName, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBoneData", this ); }

                    var data = skeletonDataAsset.GetSkeletonData(true);
                    return data.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBoneData:static end.*/


            }
        },
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    Bridge.define("Spine.Unity.SpineEvent", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            /**
             * Smart popup menu for Spine Events (Spine.EventData)
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SpineEvent
             * @default false
             * @type boolean
             */
            audioOnly: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#init", this ); }

                this.audioOnly = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, audioOnly) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (audioOnly === void 0) { audioOnly = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.audioOnly = audioOnly;
            }
        }
    });
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    Bridge.define("Spine.Unity.SpineIkConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine IK Constraints (Spine.IkConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpineIkConstraint
             * @memberof Spine.Unity.SpineIkConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField    If true, and an animation list source can't be found, the field will fall back to a normal text field. If false, it will show an error.
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineIkConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    Bridge.define("Spine.Unity.SpinePathConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine Events (Spine.PathConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpinePathConstraint
             * @memberof Spine.Unity.SpinePathConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpinePathConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    Bridge.define("Spine.Unity.SpineSkin", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            
            defaultAsEmptyString: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#init", this ); }

                this.defaultAsEmptyString = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, defaultAsEmptyString) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (defaultAsEmptyString === void 0) { defaultAsEmptyString = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.defaultAsEmptyString = defaultAsEmptyString;
            }
        }
    });
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    Bridge.define("Spine.Unity.SpineSlot", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            containsBoundingBoxes: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#init", this ); }

                this.containsBoundingBoxes = false;
            },
            
            ctor: function (startsWith, dataField, containsBoundingBoxes, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (containsBoundingBoxes === void 0) { containsBoundingBoxes = false; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.containsBoundingBoxes = containsBoundingBoxes;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    Bridge.define("Spine.Unity.SpineTransformConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineTransformConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its Complete event.
     It can be configured to trigger on the End event as well to cover interruption.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationComplete
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationComplete", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#ctor", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationComplete
             * @memberof Spine.Unity.WaitForSpineAnimationComplete
             * @param   {Spine.TrackEntry}                             trackEntry         
             * @param   {boolean}                                      includeEndEvent
             * @return  {Spine.Unity.WaitForSpineAnimationComplete}
             */
            NowWaitFor$1: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }
                this.SafeSubscribe(trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationEnd
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationEnd", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#ctor", this ); }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationEnd
             * @memberof Spine.Unity.WaitForSpineAnimationEnd
             * @param   {Spine.TrackEntry}                        trackEntry
             * @return  {Spine.Unity.WaitForSpineAnimationEnd}
             */
            NowWaitFor$1: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1", this ); }

                this.SafeSubscribe(trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    Bridge.define("Spine.Unity.AnimationReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#op_Implicit", this ); }

                    return asset.Animation;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            animationName: null,
            animation: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Animation#get", this ); }

                    if (this.animation == null) {
                        this.Initialize();
                    }
                    return this.animation;
                }
            }
        },
        alias: ["SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"],
        methods: {
            /*Spine.Unity.AnimationReferenceAsset.Clear start.*/
            /**
             * Clears the cached animation corresponding to a loaded SkeletonData object.
             Use this to force a reload for the next time Animation is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.AnimationReferenceAsset
             * @memberof Spine.Unity.AnimationReferenceAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Clear", this ); }

                this.animation = null;
            },
            /*Spine.Unity.AnimationReferenceAsset.Clear end.*/

            /*Spine.Unity.AnimationReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.AnimationReferenceAsset.QuietSkeletonData);
                this.animation = skeletonData != null ? skeletonData.findAnimation(this.animationName) : null;
                if (this.animation == null) {
                    UnityEngine.Debug.LogWarningFormat("Animation '{0}' not found in SkeletonData : {1}.", [this.animationName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.AnimationReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.PointFollower start.*/
    Bridge.define("Spine.Unity.PointFollower", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonRenderer,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonRenderer: null,
            slotName: null,
            pointAttachmentName: null,
            followRotation: false,
            followSkeletonFlip: false,
            followSkeletonZPosition: false,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            point: null,
            bone: null,
            valid: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                }
            },
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonComponent#get", this ); }

                    return Bridge.as(this.skeletonRenderer, Spine.Unity.ISkeletonComponent);
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#IsValid#get", this ); }

                    return this.valid;
                }
            }
        },
        alias: [
            "SkeletonRenderer", "Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#init", this ); }

                this.followRotation = true;
                this.followSkeletonFlip = true;
                this.followSkeletonZPosition = false;
            }
        },
        methods: {
            /*Spine.Unity.PointFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#Initialize", this ); }

                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.UpdateReferences();

            },
            /*Spine.Unity.PointFollower.Initialize end.*/

            /*Spine.Unity.PointFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.PointFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.PointFollower.UpdateReferences start.*/
            UpdateReferences: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#UpdateReferences", this ); }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                this.bone = null;
                this.point = null;
                if (!System.String.isNullOrEmpty(this.pointAttachmentName)) {
                    var skeleton = this.skeletonRenderer.Skeleton;

                    var slot = skeleton.findSlot(this.slotName);
                    if (slot != null) {
                        var slotIndex = slot.data.index;
                        this.bone = slot.bone;
                        this.point = Bridge.as(skeleton.getAttachment(slotIndex, this.pointAttachmentName), Spine.PointAttachment);
                    }
                }
            },
            /*Spine.Unity.PointFollower.UpdateReferences end.*/

            /*Spine.Unity.PointFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.PointFollower.OnDestroy end.*/

            /*Spine.Unity.PointFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#LateUpdate", this ); }

                var $t;

                if (this.point == null) {
                    if (System.String.isNullOrEmpty(this.pointAttachmentName)) {
                        return;
                    }
                    this.UpdateReferences();
                    if (this.point == null) {
                        return;
                    }
                }

                var worldPos = new UnityEngine.Vector2();
                this.point.ComputeWorldPosition(this.bone, Bridge.ref(worldPos, "x"), Bridge.ref(worldPos, "y"));
                var rotation = this.point.computeWorldRotation(this.bone);

                var thisTransform = this.transform;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( worldPos.x, worldPos.y, this.followSkeletonZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followRotation) {
                        var halfRotation = rotation * 0.5 * UnityEngine.Mathf.Deg2Rad;

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( worldPos.x, worldPos.y, 0.0 ));
                    if (!this.followSkeletonZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }

                    var transformParent = thisTransform.parent;
                    if (UnityEngine.Component.op_Inequality(transformParent, null)) {
                        var m = transformParent.localToWorldMatrix.$clone();
                        if (m.e00 * m.e11 - m.e01 * m.e10 < 0) {
                            rotation = -rotation;
                        }
                    }

                    if (this.followRotation) {
                        var transformWorldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( transformWorldRotation.x, transformWorldRotation.y, transformWorldRotation.z + rotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                }

                if (this.followSkeletonFlip) {
                    var localScale = thisTransform.localScale.$clone();
                    localScale.y = Math.abs(localScale.y) * ($t = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.PointFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.PointFollower end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.MeshGeneratorDelegate
     * @param   {Spine.Unity.MeshGeneratorBuffers}    buffers
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderer start.*/
    /**
     * Base class of animated Spine skeleton components. This component manages and renders a skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer
     * @augments UnityEngine.MonoBehaviour
     * @implements  Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.SkeletonRenderer", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.ISkeletonComponent,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 8
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_NONE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 4
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 5
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE: 0,
                /**
                 * Shader property ID used for the Stencil comparison function.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @type number
                 */
                STENCIL_COMP_PARAM_ID: 0,
                SUBMESH_DUMMY_PARAM_ID: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                    this.STENCIL_COMP_MASKINTERACTION_NONE = UnityEngine.Rendering.CompareFunction.Always;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE = UnityEngine.Rendering.CompareFunction.LessEqual;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE = UnityEngine.Rendering.CompareFunction.Greater;
                    this.STENCIL_COMP_PARAM_ID = UnityEngine.Shader.PropertyToID("_StencilComp");
                    this.SUBMESH_DUMMY_PARAM_ID = UnityEngine.Shader.PropertyToID("_Submesh");
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static start.*/
                NewSpineGameObject: function (T, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#NewSpineGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(T, new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static end.*/

                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static start.*/
                /**
                 * Add and prepare a Spine component that derives from SkeletonRenderer to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderer
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @param   {Function}                         T                    T should be SkeletonRenderer or any of its derived classes.
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {T}
                 */
                AddSpineComponent: function (T, gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AddSpineComponent", this ); }

                    if (quiet === void 0) { quiet = false; }
                    var c = Bridge.rValue(gameObject.AddComponent(T));
                    if (skeletonDataAsset != null) {
Bridge.rValue(                        c).skeletonDataAsset = skeletonDataAsset;
Bridge.rValue(                        c).Initialize(false, quiet);
                    }
                    return Bridge.rValue(c);
                },
                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            /**
             * Skin name to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type string
             */
            initialSkinName: null,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipX: false,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipY: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            zSpacing: 0,
            /**
             * Use Spine's clipping feature. If false, ClippingAttachments will be ignored.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            useClipping: false,
            /**
             * If true, triangles will not be updated. Enable this as an optimization if the skeleton does not make use of attachment swapping or hiding, or draw order keys. Otherwise, setting this to false may cause errors in rendering.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            immutableTriangles: false,
            /**
             * Multiply vertex color RGB with vertex color alpha. Set this to true if the shader used for rendering is a premultiplied alpha shader. Setting this to false disables single-batch additive slots.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            pmaVertexColors: false,
            /**
             * Clears the state of the render and skeleton when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            clearStateOnDisable: false,
            /**
             * If true, second colors on slots will be added to the output Mesh as UV2 and UV3. A special "tint black" shader that interprets UV2 and UV3 as black point colors is required to render this properly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            tintBlack: false,
            /**
             * If true, the renderer assumes the skeleton only requires one Material and one submesh to render. This allows the MeshGenerator to skip checking for changes in Materials. Enable this as an optimization if the skeleton only uses one Material.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            singleSubmesh: false,
            /**
             * Applies only when 3+ submeshes are used (2+ materials with alternating order, e.g. "A B A").
             If true, GPU instancing is disabled at all materials and MaterialPropertyBlocks are assigned at each
             material to prevent aggressive batching of submeshes by e.g. the LWRP renderer, leading to incorrect
             draw order (e.g. "A1 B A2" changed to "A1A2 B").
             You can disable this parameter when everything is drawn correctly to save the additional performance cost.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            fixDrawOrder: false,
            /**
             * If true, the mesh generator adds normals to the output mesh. For better performance and reduced memory requirements, use a shader that assumes the desired normal.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            addNormals: false,
            /**
             * If true, tangents are calculated every frame and added to the Mesh. Enable this when using a shader that uses lighting that requires tangents.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            calculateTangents: false,
            /**
             * Material references for switching material sets at runtime when {@link } changes.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             */
            maskMaterials: null,
            disableRenderingOnOverride: false,
            customMaterialOverride: null,
            customSlotMaterials: null,
            currentInstructions: null,
            meshGenerator: null,
            rendererBuffers: null,
            meshRenderer: null,
            meshFilter: null,
            valid: false,
            skeleton: null,
            reusedPropertyBlock: null
        },
        events: {
            generateMeshOverride: null,
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            /**
             * Use this Dictionary to override a Material with a different Material.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            /**
             * Use this Dictionary to use a different Material to render specific Slots.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomSlotMaterials
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomSlotMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get", this ); }

                    return this.customSlotMaterials;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                }
            },
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            }
        },
        alias: [
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.useClipping = true;
                this.immutableTriangles = false;
                this.pmaVertexColors = true;
                this.clearStateOnDisable = false;
                this.tintBlack = false;
                this.singleSubmesh = false;
                this.fixDrawOrder = false;
                this.addNormals = false;
                this.calculateTangents = false;
                this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                this.disableRenderingOnOverride = true;
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.customSlotMaterials = new (System.Collections.Generic.Dictionary$2(Spine.Slot,UnityEngine.Material)).ctor();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.rendererBuffers = new Spine.Unity.MeshRendererBuffers();
            }
        },
        methods: {
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            addGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#addGenerateMeshOverride", this ); }

                this.addgenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && !Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = false;
                    }
                }
            },
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            removeGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride", this ); }

                this.removegenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = true;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings start.*/
            /**
             * Applies MeshGenerator settings to the SkeletonRenderer and its internal MeshGenerator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {Spine.Unity.MeshGenerator.Settings}    settings
             * @return  {void}
             */
            SetMeshSettings: function (settings) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMeshSettings", this ); }

                this.calculateTangents = settings.calculateTangents;
                this.immutableTriangles = settings.immutableTriangles;
                this.pmaVertexColors = settings.pmaVertexColors;
                this.tintBlack = settings.tintBlack;
                this.useClipping = settings.useClipping;
                this.zSpacing = settings.zSpacing;

                this.meshGenerator.settings = settings.$clone();
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings end.*/

            /*Spine.Unity.SkeletonRenderer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Awake", this ); }

                this.Initialize(false);
                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.Awake end.*/

            /*Spine.Unity.SkeletonRenderer.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDisable", this ); }

                if (this.clearStateOnDisable && this.valid) {
                    this.ClearState();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDestroy", this ); }

                this.rendererBuffers.Dispose();
                this.valid = false;
            },
            /*Spine.Unity.SkeletonRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonRenderer.ClearState start.*/
            /**
             * Clears the previously generated mesh and resets the skeleton's pose.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ClearState", this ); }

                var meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Inequality(meshFilter, null)) {
                    meshFilter.sharedMesh = null;
                }
                this.currentInstructions.Clear();
                if (this.skeleton != null) {
                    this.skeleton.setToSetupPose();
                }
            },
            /*Spine.Unity.SkeletonRenderer.ClearState end.*/

            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity start.*/
            /**
             * Sets a minimum buffer size for the internal MeshGenerator to prevent excess allocations during animation.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {number}    minimumVertexCount
             * @return  {void}
             */
            EnsureMeshGeneratorCapacity: function (minimumVertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity", this ); }

                this.meshGenerator.EnsureVertexCapacity(minimumVertexCount);
            },
            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity end.*/

            /*Spine.Unity.SkeletonRenderer.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Skeleton object and buffers.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, it will overwrite internal objects if they were already generated. Otherwise, the initialized component will ignore subsequent calls to initialize.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Initialize", this ); }

                var $t;
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                // Clear
                {
                    // Note: do not reset meshFilter.sharedMesh or meshRenderer.sharedMaterial to null,
                    // otherwise constant reloading will be triggered at prefabs.
                    this.currentInstructions.Clear();
                    this.rendererBuffers.Clear();
                    this.meshGenerator.Begin();
                    this.skeleton = null;
                    this.valid = false;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }

                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }
                this.valid = true;

                this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Equality(this.meshFilter, null)) {
                    this.meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);
                }

                this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.rendererBuffers.Initialize();

                this.skeleton = ($t = new Spine.Skeleton.$ctor1(skeletonData), $t.scaleX = this.initialFlipX ? -1 : 1, $t.scaleY = this.initialFlipY ? -1 : 1, $t);

                if (!System.String.isNullOrEmpty(this.initialSkinName) && !System.String.equals(this.initialSkinName, "default", 4)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                // Generate mesh once, required to update mesh bounds for visibility
                var updateModeSaved = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.skeleton.updateWorldTransform();
                this.LateUpdate();
                this.updateMode = updateModeSaved;

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

            },
            /*Spine.Unity.SkeletonRenderer.Initialize end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdate start.*/
            /**
             * Generates a new UnityEngine.Mesh from the internal Skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdate", this ); }

                if (!this.valid) {
                    return;
                }


                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.LateUpdateMesh();
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdate end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh start.*/
            LateUpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdateMesh", this ); }

                var $t, $t1;
                var doMeshOverride = !Bridge.staticEquals(this.generateMeshOverride, null);
                if ((!UnityEngine.Object.op_Implicit(this.meshRenderer) || !this.meshRenderer.enabled) && !doMeshOverride) {
                    return;
                }
                var currentInstructions = this.currentInstructions;
                var workingSubmeshInstructions = currentInstructions.submeshInstructions;
                var currentSmartMesh = this.rendererBuffers.GetNextMesh(); // Double-buffer for performance.

                var updateTriangles;

                if (this.singleSubmesh) {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(currentInstructions, this.skeleton, ($t = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.AddSubmesh(workingSubmeshInstructions.Items[0].$clone(), updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }

                } else {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, this.customSlotMaterials, this.separatorSlots, doMeshOverride, this.immutableTriangles);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    if (doMeshOverride) {
                        this.generateMeshOverride(currentInstructions);
                        if (this.disableRenderingOnOverride) {
                            return;
                        }
                    }

                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.BuildMesh(currentInstructions, updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                }

                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                // STEP 3. Move the mesh data into a UnityEngine.Mesh ===========================================================================
                var currentMesh = currentSmartMesh.mesh;
                this.meshGenerator.FillVertexData(currentMesh);

                this.rendererBuffers.UpdateSharedMaterials(workingSubmeshInstructions);

                var materialsChanged = this.rendererBuffers.MaterialsChangedInLastUpdate();
                if (updateTriangles) { // Check if the triangles should also be updated.
                    this.meshGenerator.FillTriangles(currentMesh);
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                } else if (materialsChanged) {
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                }
                if (materialsChanged && (this.maskMaterials.AnyMaterialCreated)) {
                    this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                }

                this.meshGenerator.FillLateVertexData(currentMesh);

                // STEP 4. The UnityEngine.Mesh is ready. Set it as the MeshFilter's mesh. Store the instructions used for that mesh. ===========
                if (UnityEngine.Object.op_Implicit(this.meshFilter)) {
                    this.meshFilter.sharedMesh = currentMesh;
                }
                currentSmartMesh.instructionUsed.Set(currentInstructions);

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                }

                if (this.fixDrawOrder && this.meshRenderer.sharedMaterials.length > 2) {
                    this.SetMaterialSettingsToFixDrawOrder();
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 start.*/
            FindAndApplySeparatorSlots$1: function (startsWith, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1", this ); }

                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (System.String.isNullOrEmpty(startsWith)) {
                    return;
                }

                this.FindAndApplySeparatorSlots(function (slotName) {
                    return System.String.startsWith(slotName, startsWith);
                }, clearExistingSeparators, updateStringArray);
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots start.*/
            FindAndApplySeparatorSlots: function (slotNamePredicate, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots", this ); }

                var $t, $t1, $t2;
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (Bridge.staticEquals(slotNamePredicate, null)) {
                    return;
                }
                if (!this.valid) {
                    return;
                }

                if (clearExistingSeparators) {
                    this.separatorSlots.clear();
                }

                var slots = this.skeleton.Slots;
                $t = Bridge.getEnumerator(slots);
                try {
                    while ($t.moveNext()) {
                        var slot = $t.Current;
                        if (slotNamePredicate(slot.data.name)) {
                            this.separatorSlots.add(slot);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (updateStringArray) {
                    var detectedSeparatorNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t1 = Bridge.getEnumerator(this.skeleton.Slots);
                    try {
                        while ($t1.moveNext()) {
                            var slot1 = $t1.Current;
                            var slotName = slot1.data.name;
                            if (slotNamePredicate(slotName)) {
                                detectedSeparatorNames.add(slotName);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    if (!clearExistingSeparators) {
                        var originalNames = this.separatorSlotNames;
                        $t2 = Bridge.getEnumerator(originalNames);
                        try {
                            while ($t2.moveNext()) {
                                var originalName = $t2.Current;
                                detectedSeparatorNames.add(originalName);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }

                    this.separatorSlotNames = detectedSeparatorNames.ToArray();
                }

            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots end.*/

            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames", this ); }

                if (!this.valid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slot = this.skeleton.findSlot(this.separatorSlotNames[i]);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask start.*/
            InitSpriteMaskMaterialsInsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE, Bridge.ref(this.maskMaterials, "materialsInsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask start.*/
            InitSpriteMaskMaterialsOutsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE, Bridge.ref(this.maskMaterials, "materialsOutsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType start.*/
            InitSpriteMaskMaterialsForMaskType: function (maskFunction, materialsToFill) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType", this ); }

                var originalMaterials = this.maskMaterials.materialsMaskDisabled;
                materialsToFill.v = System.Array.init(originalMaterials.length, null, UnityEngine.Material);
                for (var i = 0; i < originalMaterials.length; i = (i + 1) | 0) {
                    var newMaterial = new UnityEngine.Material.$ctor1(originalMaterials[i]);
                    newMaterial.SetFloat(Spine.Unity.SkeletonRenderer.STENCIL_COMP_PARAM_ID, maskFunction);
                    materialsToFill.v[i] = newMaterial;
                }
                return true;
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType end.*/

            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder start.*/
            /**
             * This method was introduced as a workaround for too aggressive submesh draw call batching,
             leading to incorrect draw order when 3+ materials are used at submeshes in alternating order.
             Otherwise, e.g. when using Lightweight Render Pipeline, deliberately separated draw calls
             "A1 B A2" are reordered to "A1A2 B", regardless of batching-related project settings.
             *
             * @instance
             * @private
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            SetMaterialSettingsToFixDrawOrder: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder", this ); }

                var $t, $t1;
                if (this.reusedPropertyBlock == null) {
                    this.reusedPropertyBlock = new UnityEngine.MaterialPropertyBlock();
                }

                var hasPerRendererBlock = this.meshRenderer.HasPropertyBlock();
                if (hasPerRendererBlock) {
                    this.meshRenderer.GetPropertyBlock(this.reusedPropertyBlock);
                }

                for (var i = 0; i < this.meshRenderer.sharedMaterials.length; i = (i + 1) | 0) {
                    if (!UnityEngine.Object.op_Implicit(($t = this.meshRenderer.sharedMaterials)[i])) {
                        continue;
                    }

                    if (!hasPerRendererBlock) {
                        this.meshRenderer.GetPropertyBlock$1(this.reusedPropertyBlock, i);
                    }
                    // Note: this parameter shall not exist at any shader, then Unity will create separate
                    // material instances (not in terms of memory cost or leakage).
                    this.reusedPropertyBlock.SetFloat(Spine.Unity.SkeletonRenderer.SUBMESH_DUMMY_PARAM_ID, i);
                    this.meshRenderer.SetPropertyBlock$1(this.reusedPropertyBlock, i);

                    ($t1 = this.meshRenderer.sharedMaterials)[i].enableInstancing = false;
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder end.*/


        },
        overloads: {
            "FindAndApplySeparatorSlots(string, bool, bool)": "FindAndApplySeparatorSlots$1"
        }
    });
    /*Spine.Unity.SkeletonRenderer end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple
     * @param   {number}                          meshCount           
     * @param   {Array.<UnityEngine.Mesh>}        meshes              
     * @param   {Array.<UnityEngine.Material>}    graphicMaterials    
     * @param   {Array.<UnityEngine.Texture>}     textures
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle
     * @param   {UnityEngine.Mesh}        mesh               
     * @param   {UnityEngine.Material}    graphicMaterial    
     * @param   {UnityEngine.Texture}     texture
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.ISkeletonAnimationDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonGraphic}    skeletonGraphic
     * @return  {void}
     */


    /*Spine.Unity.SkeletonGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic,Spine.Unity.ISkeletonComponent,Spine.Unity.IAnimationStateComponent,Spine.Unity.ISkeletonAnimation,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                EditReferenceRect: false,
                SeparatorPartGameObjectName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                    this.EditReferenceRect = false;
                    this.SeparatorPartGameObjectName = "Part";
                }
            },
            methods: {
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static start.*/
                /**
                 * Create a new GameObject with a SkeletonGraphic component.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Transform}            parent               
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                NewSkeletonGraphicGameObject: function (skeletonDataAsset, parent, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject", this ); }

                    var sg = Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent(new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, material);
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        sg.transform.SetParent(parent, false);
                    }
                    return sg;
                },
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static end.*/

                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static start.*/
                /**
                 * Add a SkeletonGraphic component to a GameObject.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                AddSkeletonGraphicComponent: function (gameObject, skeletonDataAsset, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent", this ); }

                    var skeletonGraphic = gameObject.AddComponent(Spine.Unity.SkeletonGraphic);
                    if (skeletonDataAsset != null) {
                        skeletonGraphic.material = material;
                        skeletonGraphic.skeletonDataAsset = skeletonDataAsset;
                        skeletonGraphic.Initialize(false);
                    }
                    var canvasRenderer = gameObject.GetComponent(UnityEngine.CanvasRenderer);
                    if (UnityEngine.Object.op_Implicit(canvasRenderer)) {
                        canvasRenderer.cullTransparentMesh = false;
                    }
                    return skeletonGraphic;
                },
                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static start.*/
                SetRectTransformSize: function (target, size) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformSize", this ); }

                    var $t;
                    var parentSize = pc.Vec2.ZERO.clone();
                    if (UnityEngine.Component.op_Inequality(target.rectTransform.parent, null)) {
                        var parentTransform = target.rectTransform.parent.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(parentTransform)) {
                            parentSize = parentTransform.rect.size.$clone();
                        }
                    }
                    var anchorAreaSize = ($t = target.rectTransform.anchorMax.$clone().sub( target.rectTransform.anchorMin ), new pc.Vec2( $t.x * parentSize.x, $t.y * parentSize.y ));
                    target.rectTransform.sizeDelta = size.$clone().sub( anchorAreaSize );
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            additiveMaterial: null,
            multiplyMaterial: null,
            screenMaterial: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            startingAnimation: null,
            startingLoop: false,
            timeScale: 0,
            freeze: false,
            layoutScaleMode: 0,
            referenceSize: null,
            referenceScale: 0,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            allowMultipleCanvasRenderers: false,
            canvasRenderers: null,
            submeshGraphics: null,
            usedRenderersCount: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            enableSeparatorSlots: false,
            separatorParts: null,
            updateSeparatorPartLocation: false,
            wasUpdatedAfterInit: false,
            requiresInstructionUpate: false,
            baseTexture: null,
            /**
             * When true, no meshes and materials are assigned at CanvasRenderers if the used override
             AssignMeshOverrideSingleRenderer or AssignMeshOverrideMultipleRenderers is non-null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @default true
             * @type boolean
             */
            disableMeshAssignmentOnOverride: false,
            customTextureOverride: null,
            customMaterialOverride: null,
            overrideTexture: null,
            skeleton: null,
            state: null,
            meshGenerator: null,
            meshBuffers: null,
            currentInstructions: null,
            meshes: null,
            usedMaterials: null,
            usedTextures: null,
            updateTiming: 0,
            unscaledTime: false
        },
        events: {
            assignMeshOverrideSingle: null,
            assignMeshOverrideMultiple: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            OnInstructionsPrepared: null,
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null,
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            OnAnimationRebuild: null,
            BeforeApply: null,
            UpdateLocal: null,
            UpdateWorld: null,
            UpdateComplete: null,
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            SeparatorParts: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SeparatorParts#get", this ); }

                    return this.separatorParts;
                }
            },
            /**
             * Use this Dictionary to override a Texture with a different Texture.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomTextureOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomTextureOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomTextureOverride#get", this ); }

                    return this.customTextureOverride;
                }
            },
            /**
             * Use this Dictionary to override the Material where the Texture was used at the original atlas.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            OverrideTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#get", this ); }

                    return this.overrideTexture;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#set", this ); }

                    this.overrideTexture = value;
                    this.canvasRenderer.SetTexture(this.mainTexture); // Refresh canvasRenderer's texture. Make sure it handles null.
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#mainTexture#get", this ); }

                    if (this.overrideTexture != null) {
                        return this.overrideTexture;
                    }
                    return this.baseTexture;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#get", this ); }

                    this.Initialize(false);
                    this.requiresInstructionUpate = true;
                    return this.skeleton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#set", this ); }

                    this.requiresInstructionUpate = true;
                    this.skeleton = value;
                }
            },
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonData#get", this ); }

                    this.Initialize(false);
                    return this.skeleton == null ? null : this.skeleton.data;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#IsValid#get", this ); }

                    return this.skeleton != null;
                }
            },
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshGenerator#get", this ); }

                    return this.meshGenerator;
                }
            },
            MeshesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get", this ); }

                    return this.meshes;
                }
            },
            MaterialsMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get", this ); }

                    return this.usedMaterials;
                }
            },
            TexturesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get", this ); }

                    return this.usedTextures;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton",
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                this.referenceSize = new UnityEngine.Vector2();
                this.timeScale = 1.0;
                this.layoutScaleMode = Spine.Unity.SkeletonGraphic.LayoutMode.None;
                this.referenceSize = pc.Vec2.ONE.clone();
                this.referenceScale = 1.0;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.allowMultipleCanvasRenderers = false;
                this.canvasRenderers = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                this.submeshGraphics = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonSubmeshGraphic)).ctor();
                this.usedRenderersCount = 0;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.enableSeparatorSlots = false;
                this.separatorParts = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.updateSeparatorPartLocation = true;
                this.wasUpdatedAfterInit = true;
                this.requiresInstructionUpate = true;
                this.disableMeshAssignmentOnOverride = true;
                this.customTextureOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Texture)).ctor();
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Material)).ctor();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshes = new (Spine.ExposedList$1(UnityEngine.Mesh)).ctor();
                this.usedMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.usedTextures = new (Spine.ExposedList$1(UnityEngine.Texture)).ctor();
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            addAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer", this ); }

                this.addassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            removeAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer", this ); }

                this.removeassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            addAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers", this ); }

                this.addassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            removeAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers", this ); }

                this.removeassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Awake", this ); }


                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);
                this.onCullStateChanged.AddListener(Bridge.fn.cacheBind(this, this.OnCullStateChanged));

                this.SyncSubmeshGraphicsWithCanvasRenderers();
                if (!this.IsValid) {
                    this.Initialize(false);
                    this.Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                }

            },
            /*Spine.Unity.SkeletonGraphic.Awake end.*/

            /*Spine.Unity.SkeletonGraphic.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDestroy", this ); }

                this.Clear();
                UnityEngine.UI.MaskableGraphic.prototype.OnDestroy.call(this);
            },
            /*Spine.Unity.SkeletonGraphic.OnDestroy end.*/

            /*Spine.Unity.SkeletonGraphic.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Rebuild", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Rebuild.call(this, update);
                if (this.canvasRenderer.cull) {
                    return;
                }
                if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    if (this.requiresInstructionUpate) {
                        this.PrepareInstructionsAndRenderers(true);
                    }
                    this.UpdateMeshToInstructions();
                }
                if (this.allowMultipleCanvasRenderers) {
                    this.canvasRenderer.Clear();
                }
            },
            /*Spine.Unity.SkeletonGraphic.Rebuild end.*/

            /*Spine.Unity.SkeletonGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDisable", this ); }

                var $t;
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        canvasRenderer.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update", this ); }

                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.Update end.*/

            /*Spine.Unity.SkeletonGraphic.Update$1 start.*/
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update$1", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonGraphic.Update$1 end.*/

            /*Spine.Unity.SkeletonGraphic.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#FixedUpdate", this ); }

                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.FixedUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers start.*/
            SyncSubmeshGraphicsWithCanvasRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers", this ); }

                var $t;
                this.submeshGraphics.clear();

                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        var submeshGraphic = canvasRenderer.GetComponent(Spine.Unity.SkeletonSubmeshGraphic);
                        if (UnityEngine.MonoBehaviour.op_Equality(submeshGraphic, null)) {
                            submeshGraphic = canvasRenderer.gameObject.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                            submeshGraphic.maskable = this.maskable;
                            submeshGraphic.raycastTarget = false;
                        }
                        this.submeshGraphics.add(submeshGraphic);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this.BeforeApply, null)) {
                    this.BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                if (!Bridge.staticEquals(this.UpdateLocal, null)) {
                    this.UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this.UpdateWorld, null)) {
                    this.UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this.UpdateComplete, null)) {
                    this.UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                if (this.freeze) {
                    return;
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.PrepareInstructionsAndRenderers();

                this.SetVerticesDirty(); // triggers Rebuild and avoids potential double-update in a single frame
            },
            /*Spine.Unity.SkeletonGraphic.LateUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged start.*/
            OnCullStateChanged: function (culled) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnCullStateChanged", this ); }

                if (culled) {
                    this.OnBecameInvisible();
                } else {
                    this.OnBecameVisible();
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameVisible", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slotName = this.separatorSlotNames[i];
                    if (Bridge.referenceEquals(slotName, "")) {
                        continue;
                    }
                    var slot = this.skeleton.findSlot(slotName);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
                this.UpdateSeparatorPartParents();
            },
            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonGraphic.GetLastMesh start.*/
            GetLastMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLastMesh", this ); }

                return this.meshBuffers.GetCurrent().mesh;
            },
            /*Spine.Unity.SkeletonGraphic.GetLastMesh end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds start.*/
            MatchRectTransformWithBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds", this ); }

                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                this.UpdateMesh();

                if (!this.allowMultipleCanvasRenderers) {
                    return this.MatchRectTransformSingleRenderer();
                } else {
                    return this.MatchRectTransformMultipleRenderers();
                }
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer start.*/
            MatchRectTransformSingleRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer", this ); }

                var mesh = this.GetLastMesh();
                if (mesh == null) {
                    return false;
                }
                if (mesh.vertexCount === 0) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                mesh.RecalculateBounds();
                this.SetRectTransformBounds(mesh.bounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers start.*/
            MatchRectTransformMultipleRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers", this ); }

                var $t;
                var anyBoundsAdded = false;
                var combinedBounds = new pc.BoundingBox.ctor();
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (!canvasRenderer.gameObject.activeSelf) {
                        continue;
                    }

                    var mesh = ($t = this.meshes.Items)[i];
                    if (mesh == null || mesh.vertexCount === 0) {
                        continue;
                    }

                    mesh.RecalculateBounds();
                    var bounds = mesh.bounds;
                    if (anyBoundsAdded) {
                        combinedBounds.add( bounds );
                    } else {
                        anyBoundsAdded = true;
                        combinedBounds = bounds;
                    }
                }

                if (!anyBoundsAdded) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }

                this.SetRectTransformBounds(combinedBounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds start.*/
            SetRectTransformBounds: function (combinedBounds) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformBounds", this ); }

                var $t;
                var size = combinedBounds.halfExtents.$clone().scale( 2 ).$clone();
                var center = combinedBounds.center.$clone();
                var p = new pc.Vec2( 0.5 - (center.x / size.x), 0.5 - (center.y / size.y) );

                Spine.Unity.SkeletonGraphic.SetRectTransformSize(this, UnityEngine.Vector2.FromVector3(size.$clone()));
                this.rectTransform.pivot = p.$clone();

                $t = Bridge.getEnumerator(this.submeshGraphics);
                try {
                    while ($t.moveNext()) {
                        var submeshGraphic = $t.Current;
                        Spine.Unity.SkeletonGraphic.SetRectTransformSize(submeshGraphic, UnityEngine.Vector2.FromVector3(size.$clone()));
                        submeshGraphic.rectTransform.pivot = p.$clone();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds end.*/

            /*Spine.Unity.SkeletonGraphic.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Clear", this ); }

                this.skeleton = null;
                this.canvasRenderer.Clear();

                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                }
                this.DestroyMeshes();
                this.usedMaterials.Clear();
                this.usedTextures.Clear();
                this.DisposeMeshBuffers();
            },
            /*Spine.Unity.SkeletonGraphic.Clear end.*/

            /*Spine.Unity.SkeletonGraphic.TrimRenderers start.*/
            TrimRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TrimRenderers", this ); }

                var $t;
                var newList = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        if (canvasRenderer.gameObject.activeSelf) {
                            newList.add(canvasRenderer);
                        } else {
                            if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying) {
                                UnityEngine.Object.DestroyImmediate(canvasRenderer.gameObject);
                            } else {
                                UnityEngine.MonoBehaviour.Destroy(canvasRenderer.gameObject);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.canvasRenderers = newList;
                this.SyncSubmeshGraphicsWithCanvasRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.TrimRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Initialize", this ); }

                var $t, $t1;
                if (this.IsValid && !overwrite) {
                    return;
                }
                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }

                if (this.skeletonDataAsset.atlasAssets.length <= 0 || ($t = this.skeletonDataAsset.atlasAssets)[0].MaterialCount <= 0) {
                    return;
                }

                this.skeleton = ($t1 = new Spine.Skeleton.$ctor1(skeletonData), $t1.scaleX = this.initialFlipX ? -1 : 1, $t1.scaleY = this.initialFlipY ? -1 : 1, $t1);

                this.InitMeshBuffers();
                this.baseTexture = ($t1 = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial.mainTexture;
                this.canvasRenderer.SetTexture(this.mainTexture); // Needed for overwriting initializations.

                // Set the initial Skin and Animation
                if (!System.String.isNullOrEmpty(this.initialSkinName)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

                this.wasUpdatedAfterInit = false;
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                if (this.state == null) {
                    this.Clear();
                    return;
                }

                if (!System.String.isNullOrEmpty(this.startingAnimation)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this.startingAnimation);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.startingLoop );
                    }
                }

                if (!Bridge.staticEquals(this.OnAnimationRebuild, null)) {
                    this.OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Initialize end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers start.*/
            PrepareInstructionsAndRenderers: function (isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                this.requiresInstructionUpate = false;
                if (!this.allowMultipleCanvasRenderers) {
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(this.currentInstructions, this.skeleton, null);
                    if (this.canvasRenderers.Count > 0) {
                        this.DisableUnusedCanvasRenderers(0, isInRebuild);
                    }
                    this.usedRenderersCount = 0;
                } else {
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(this.currentInstructions, this.skeleton, null, this.enableSeparatorSlots ? this.separatorSlots : null, this.enableSeparatorSlots ? this.separatorSlots.Count > 0 : false, false);

                    var submeshCount = this.currentInstructions.submeshInstructions.Count;
                    this.EnsureCanvasRendererCount(submeshCount);
                    this.EnsureMeshesCount(submeshCount);
                    this.EnsureUsedTexturesAndMaterialsCount(submeshCount);
                    this.EnsureSeparatorPartCount();
                    this.PrepareRendererGameObjects(this.currentInstructions, isInRebuild);
                }
                if (!Bridge.staticEquals(this.OnInstructionsPrepared, null)) {
                    this.OnInstructionsPrepared(this.currentInstructions);
                }
            },
            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMesh start.*/
            UpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMesh", this ); }

                this.PrepareInstructionsAndRenderers();
                this.UpdateMeshToInstructions();
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMesh end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions start.*/
            UpdateMeshToInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions", this ); }

                if (!this.IsValid || this.currentInstructions.rawVertexCount < 0) {
                    return;
                }
                Spine.Unity.SkeletonExtensions.SetColor$4(this.skeleton, this.color.$clone());

                if (!this.allowMultipleCanvasRenderers) {
                    this.UpdateMeshSingleCanvasRenderer(this.currentInstructions);
                } else {
                    this.UpdateMaterialsMultipleCanvasRenderers(this.currentInstructions);
                    this.UpdateMeshMultipleCanvasRenderers(this.currentInstructions);
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions start.*/
            HasMultipleSubmeshInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions", this ); }

                if (!this.IsValid) {
                    return false;
                }
                return Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder(this.skeleton);
            },
            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers start.*/
            InitMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#InitMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Clear();
                    this.meshBuffers.GetNext().Clear();
                } else {
                    this.meshBuffers = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers start.*/
            DisposeMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisposeMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers = null;
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer start.*/
            UpdateMeshSingleCanvasRenderer: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer", this ); }

                var $t, $t1;
                var smartMesh = this.meshBuffers.GetNext();
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, smartMesh.instructionUsed);
                this.meshGenerator.Begin();

                var useAddSubmesh = currentInstructions.hasActiveClipping && currentInstructions.submeshInstructions.Count > 0;
                if (useAddSubmesh) {
                    this.meshGenerator.AddSubmesh(($t = currentInstructions.submeshInstructions.Items)[0].$clone(), updateTriangles);
                } else {
                    this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                }

                var scale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    scale *= this.referenceScale;
                    if (true) {
                        scale *= this.GetLayoutScale(this.layoutScaleMode);
                    }
                }
                this.meshGenerator.ScaleVertexData(scale);
                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                var mesh = smartMesh.mesh;
                this.meshGenerator.FillVertexData(mesh);
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(mesh);
                }
                this.meshGenerator.FillLateVertexData(mesh);

                smartMesh.instructionUsed.Set(currentInstructions);
                if (!Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.assignMeshOverrideSingle(mesh, this.canvasRenderer.GetMaterial(), this.mainTexture);
                }

                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                if (assignAtCanvasRenderer) {
                    this.canvasRenderer.SetMesh(mesh);
                } else {
                    this.canvasRenderer.SetMesh(null);
                }

                if (currentInstructions.submeshInstructions.Count > 0) {
                    var material = ($t1 = currentInstructions.submeshInstructions.Items)[0].material;
                    if (material != null && !Bridge.referenceEquals(this.baseTexture, material.mainTexture)) {
                        this.baseTexture = material.mainTexture;
                        if (this.overrideTexture == null && assignAtCanvasRenderer) {
                            this.canvasRenderer.SetTexture(this.mainTexture);
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers start.*/
            UpdateMaterialsMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers", this ); }

                var $t;
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;

                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    var submeshMaterial = submeshInstructionItem.material;
                    if (useOriginalTextureAndMaterial) {
                        usedTextureItems[i] = submeshMaterial.mainTexture;
                        if (!hasBlendModeMaterials) {
                            usedMaterialItems[i] = this.materialForRendering;
                        } else {
                            var blendMode = blendModeMaterials.BlendModeForMaterial(submeshMaterial);
                            var usedMaterial = this.materialForRendering;
                            if (blendMode === spine.BlendMode.Additive && !pmaVertexColors && UnityEngine.Object.op_Implicit(this.additiveMaterial)) {
                                usedMaterial = this.additiveMaterial;
                            } else if (blendMode === spine.BlendMode.Multiply && UnityEngine.Object.op_Implicit(this.multiplyMaterial)) {
                                usedMaterial = this.multiplyMaterial;
                            } else {
                                if (blendMode === spine.BlendMode.Screen && UnityEngine.Object.op_Implicit(this.screenMaterial)) {
                                    usedMaterial = this.screenMaterial;
                                }
                            }
                            usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial);
                        }
                    } else {
                        var originalTexture = submeshMaterial.mainTexture;
                        var usedMaterial1 = { };
                        var usedTexture = { };
                        if (!this.customMaterialOverride.tryGetValue(originalTexture, usedMaterial1)) {
                            usedMaterial1.v = this.material;
                        }
                        if (!this.customTextureOverride.tryGetValue(originalTexture, usedTexture)) {
                            usedTexture.v = originalTexture;
                        }

                        usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial1.v);
                        usedTextureItems[i] = usedTexture.v;
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers start.*/
            UpdateMeshMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers", this ); }

                var $t;
                var scale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    scale *= this.referenceScale;
                    if (true) {
                        scale *= this.GetLayoutScale(this.layoutScaleMode);
                    }
                }
                // Generate meshes.
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var meshesItems = this.meshes.Items;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;
                var mainCullTransparentMesh = this.canvasRenderer.cullTransparentMesh;
                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    this.meshGenerator.Begin();
                    this.meshGenerator.AddSubmesh(submeshInstructionItem.$clone());

                    var targetMesh = meshesItems[i];
                    this.meshGenerator.ScaleVertexData(scale);
                    if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                        this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                    }
                    this.meshGenerator.FillVertexData(targetMesh);
                    this.meshGenerator.FillTriangles(targetMesh);
                    this.meshGenerator.FillLateVertexData(targetMesh);

                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride) {
                        canvasRenderer.SetMesh(targetMesh);
                    } else {
                        canvasRenderer.SetMesh(null);
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (useOriginalTextureAndMaterial && hasBlendModeMaterials) {
                        var allowCullTransparentMesh = true;
                        var materialBlendMode = blendModeMaterials.BlendModeForMaterial(usedMaterialItems[i]);
                        if ((materialBlendMode === spine.BlendMode.Normal && submeshInstructionItem.hasPMAAdditiveSlot) || (materialBlendMode === spine.BlendMode.Additive && pmaVertexColors)) {
                            allowCullTransparentMesh = false;
                        }
                        canvasRenderer.cullTransparentMesh = allowCullTransparentMesh ? mainCullTransparentMesh : false;
                    }
                    canvasRenderer.materialCount = 1;
                    if (assignAtCanvasRenderer) {
                        canvasRenderer.SetMaterial$1(usedMaterialItems[i], usedTextureItems[i]);
                    }
                }
                if (!Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.assignMeshOverrideMultiple(submeshCount, meshesItems, usedMaterialItems, usedTextureItems);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount start.*/
            EnsureCanvasRendererCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount", this ); }

                var currentCount = this.canvasRenderers.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("Renderer{0}", [Bridge.box(i, System.Int32)]), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    var canvasRenderer = go.AddComponent(UnityEngine.CanvasRenderer);
                    this.canvasRenderers.add(canvasRenderer);
                    var submeshGraphic = go.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                    submeshGraphic.maskable = this.maskable;
                    submeshGraphic.raycastTarget = false;
                    this.submeshGraphics.add(submeshGraphic);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects start.*/
            PrepareRendererGameObjects: function (currentInstructions, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects", this ); }

                var $t;
                if (isInRebuild === void 0) { isInRebuild = false; }

                var submeshCount = currentInstructions.submeshInstructions.Count;
                this.DisableUnusedCanvasRenderers(submeshCount, isInRebuild);

                var separatorSlotGroupIndex = 0;
                var targetSiblingIndex = 0;
                var parent = this.separatorSlots.Count === 0 ? this.transform : this.separatorParts.getItem(0);
                if (this.updateSeparatorPartLocation) {
                    for (var p = 0; p < this.separatorParts.Count; p = (p + 1) | 0) {
                        this.separatorParts.getItem(p).position = this.transform.position.$clone();
                        this.separatorParts.getItem(p).rotation = this.transform.rotation.$clone();
                    }
                }

                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (i >= this.usedRenderersCount) {
                        canvasRenderer.gameObject.SetActive(true);
                    }

                    if (UnityEngine.Component.op_Inequality(canvasRenderer.transform.parent, parent.transform)) {
                        canvasRenderer.transform.SetParent(parent.transform, false);
                    }

                    canvasRenderer.transform.SetSiblingIndex(Bridge.identity(targetSiblingIndex, ((targetSiblingIndex = (targetSiblingIndex + 1) | 0))));
                    var dstTransform = this.submeshGraphics.getItem(i).rectTransform;
                    dstTransform.localPosition = pc.Vec3.ZERO.clone();
                    dstTransform.pivot = this.rectTransform.pivot.$clone();
                    dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                    dstTransform.anchorMax = pc.Vec2.ONE.clone();
                    dstTransform.sizeDelta = pc.Vec2.ZERO.clone();

                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    if (submeshInstructionItem.forceSeparate) {
                        targetSiblingIndex = 0;
                        parent = this.separatorParts.getItem(((separatorSlotGroupIndex = (separatorSlotGroupIndex + 1) | 0)));
                    }
                }
                this.usedRenderersCount = submeshCount;
            },
            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects end.*/

            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers start.*/
            DisableUnusedCanvasRenderers: function (usedCount, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                for (var i = usedCount; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                    if (!isInRebuild) {
                        this.canvasRenderers.getItem(i).gameObject.SetActive(false);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount start.*/
            EnsureMeshesCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureMeshesCount", this ); }

                var oldCount = this.meshes.Count;
                this.meshes.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.meshes.Add(Spine.Unity.SpineMesh.NewSkeletonMesh());
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount start.*/
            EnsureUsedTexturesAndMaterialsCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount", this ); }

                var oldCount = this.usedMaterials.Count;
                this.usedMaterials.EnsureCapacity(targetCount);
                this.usedTextures.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.usedMaterials.Add(null);
                    this.usedTextures.Add(null);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount end.*/

            /*Spine.Unity.SkeletonGraphic.DestroyMeshes start.*/
            DestroyMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DestroyMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.meshes);
                try {
                    while ($t.moveNext()) {
                        var mesh = $t.Current;
                        UnityEngine.Object.Destroy(mesh);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.meshes.Clear();
            },
            /*Spine.Unity.SkeletonGraphic.DestroyMeshes end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount start.*/
            EnsureSeparatorPartCount: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount", this ); }

                var targetCount = (this.separatorSlots.Count + 1) | 0;
                if (targetCount === 1) {
                    return;
                }

                var currentCount = this.separatorParts.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("{0}[{1}]", Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName, Bridge.box(i, System.Int32)), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    this.separatorParts.add(go.transform);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents start.*/
            UpdateSeparatorPartParents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents", this ); }

                var usedCount = (this.separatorSlots.Count + 1) | 0;
                if (usedCount === 1) {
                    usedCount = 0; // placed directly at the SkeletonGraphic parent
                    for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                        var canvasRenderer = this.canvasRenderers.getItem(i);
                        if (System.String.contains(canvasRenderer.transform.parent.name,Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName)) {
                            canvasRenderer.transform.SetParent(this.transform, false);
                            canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                        }
                    }
                }
                for (var i1 = 0; i1 < this.separatorParts.Count; i1 = (i1 + 1) | 0) {
                    var isUsed = i1 < usedCount;
                    this.separatorParts.getItem(i1).gameObject.SetActive(isUsed);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents end.*/

            /*Spine.Unity.SkeletonGraphic.GetLayoutScale start.*/
            GetLayoutScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLayoutScale", this ); }

                var currentSize = this.GetCurrentRectSize();
                var referenceAspect = this.referenceSize.x / this.referenceSize.y;
                var frameAspect = currentSize.x / currentSize.y;
                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.FitInParent) {
                    mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth : Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight;
                } else {
                    if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.EnvelopeParent) {
                        mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight : Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth;
                    }
                }

                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight) {
                    return currentSize.x / this.referenceSize.x;
                } else if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth) {
                    return currentSize.y / this.referenceSize.y;
                }
                return 1.0;
            },
            /*Spine.Unity.SkeletonGraphic.GetLayoutScale end.*/

            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize start.*/
            GetCurrentRectSize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetCurrentRectSize", this ); }

                return this.rectTransform.rect.size.$clone();
            },
            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonGraphic end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.UpdateBonesDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */


    /*Spine.Unity.SkeletonAnimation start.*/
    Bridge.define("Spine.Unity.SkeletonAnimation", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.IAnimationStateComponent],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static start.*/
                /**
                 * Adds and prepares a SkeletonAnimation component to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation
                 */
                AddToGameObject: function (gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AddToGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(Spine.Unity.SkeletonAnimation, gameObject, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static end.*/

                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static start.*/
                /**
                 * Instantiates a new UnityEngine.GameObject and adds a prepared SkeletonAnimation component to it.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation component.
                 */
                NewSkeletonAnimationGameObject: function (skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.NewSpineGameObject(Spine.Unity.SkeletonAnimation, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static end.*/


            }
        },
        fields: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type Spine.AnimationState
             */
            state: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0,
            /**
             * If enabled, AnimationState uses unscaled game time
             (<pre><code>Time.unscaledDeltaTime</code></pre> instead of normal game time(<pre><code>Time.deltaTime</code></pre>),
             running animations independent of e.g. game pause (<pre><code>Time.timeScale</code></pre>).
             Instance SkeletonAnimation.timeScale will still be applied.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            unscaledTime: false,
            _animationName: null,
            /**
             * Whether or not {@link } should loop. This only applies to the initial animation specified in the inspector, or any subsequent Animations played through .AnimationName. Animations set through state.SetAnimation are unaffected.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            loop: false,
            /**
             * The rate at which animations progress over time. 1 means 100%. 0.5 means 50%.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @default 1
             * @type number
             */
            timeScale: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationState
             * @type Spine.AnimationState
             */
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            },
            /**
             * Setting this property sets the animation of the skeleton. If invalid, it will store the animation name for the next time the skeleton is properly initialized.
             Getting this property gets the name of the currently playing animation. If invalid, it will return the last stored animation name set through this property.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationName
             * @type string
             */
            AnimationName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#get", this ); }

                    if (!this.valid) {
                        return this._animationName;
                    } else {
                        var entry = this.state.getCurrent(0);
                        return entry == null ? null : entry.animation.name;
                    }
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#set", this ); }

                    this.Initialize(false);
                    if (Bridge.referenceEquals(this._animationName, value)) {
                        var entry = this.state.getCurrent(0);
                        if (entry != null && entry.loop === this.loop) {
                            return;
                        }
                    }
                    this._animationName = value;

                    if (System.String.isNullOrEmpty(value)) {
                        this.state.clearTrack(0);
                    } else {
                        var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(value);
                        if (animationObject != null) {
                            this.state.setAnimationWith( 0, animationObject, this.loop );
                        }
                    }
                }
            }
        },
        alias: [
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
                this.timeScale = 1;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonAnimation.ClearState start.*/
            /**
             * Clears the previously generated mesh, resets the skeleton's pose, and clears all previously active animations.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ClearState", this ); }

                Spine.Unity.SkeletonRenderer.prototype.ClearState.call(this);
                if (this.state != null) {
                    this.state.clearTracks();
                }
            },
            /*Spine.Unity.SkeletonAnimation.ClearState end.*/

            /*Spine.Unity.SkeletonAnimation.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Spine objects and buffers.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, force overwrite an already initialized object.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                this.wasUpdatedAfterInit = false;

                if (!System.String.isNullOrEmpty(this._animationName)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this._animationName);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.loop );
                    }
                }

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.Initialize end.*/

            /*Spine.Unity.SkeletonAnimation.Update$1 start.*/
            Update$1: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update$1", this ); }

                if (this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.Update$1 end.*/

            /*Spine.Unity.SkeletonAnimation.Update start.*/
            /**
             * Progresses the AnimationState according to the given deltaTime, and applies it to the Skeleton. Use Time.deltaTime to update manually. Use deltaTime 0 to update without progressing the time.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {number}    deltaTime
             * @return  {void}
             */
            Update: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update", this ); }

                if (!this.valid || this.state == null) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonAnimation.Update end.*/

            /*Spine.Unity.SkeletonAnimation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#FixedUpdate", this ); }

                if (this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.FixedUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonAnimation.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                    this._UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonAnimation.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update(0);
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonAnimation.LateUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update(0);
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonAnimation.OnBecameVisible end.*/


        },
        overloads: {
            "Update()": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation],
        fields: {
            translator: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            Translator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Translator#get", this ); }

                    return this.translator;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            }
        },
        alias: [
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonMecanim.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }

                if (this.translator == null) {
                    this.translator = new Spine.Unity.SkeletonMecanim.MecanimTranslator();
                }
                this.translator.Initialize(this.GetComponent(UnityEngine.Animator), this.skeletonDataAsset);
                this.wasUpdatedAfterInit = false;

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonMecanim.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update", this ); }

                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update end.*/

            /*Spine.Unity.SkeletonMecanim.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#FixedUpdate", this ); }

                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.FixedUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.UpdateAnimation start.*/
            UpdateAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateAnimation", this ); }

                this.wasUpdatedAfterInit = true;

                // animation status is kept by Mecanim Animator component
                if (this.updateMode <= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }

                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.UpdateAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                this.translator.Apply(this.skeleton);

                // UpdateWorldTransform and Bone Callbacks
                {
                    if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                        this._UpdateLocal(this);
                    }

                    this.skeleton.updateWorldTransform();

                    if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                        this._UpdateWorld(this);
                        this.skeleton.updateWorldTransform();
                    }

                    if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                        this._UpdateComplete(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#LateUpdate", this ); }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update();
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonMecanim.LateUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update();
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonMecanim.OnBecameVisible end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","UnityEngine","DG.Tweening","UnityEngine.UI","Spine.Unity","UnityEngine.Rendering","System.Collections.Generic","System.Collections","DG.Tweening.Core","System.Globalization","DG.Tweening.Plugins.Core.PathCore","DG.Tweening.Plugins.Options","Spine"];

    /*AspectRatio start.*/
    $m("AspectRatio", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AR34","is":true,"t":4,"rt":AspectRatio,"sn":"AR34","box":function ($v) { return Bridge.box($v, AspectRatio, System.Enum.toStringFn(AspectRatio));}},{"a":2,"n":"AR916","is":true,"t":4,"rt":AspectRatio,"sn":"AR916","box":function ($v) { return Bridge.box($v, AspectRatio, System.Enum.toStringFn(AspectRatio));}},{"a":2,"n":"AR918","is":true,"t":4,"rt":AspectRatio,"sn":"AR918","box":function ($v) { return Bridge.box($v, AspectRatio, System.Enum.toStringFn(AspectRatio));}},{"a":2,"n":"AR919","is":true,"t":4,"rt":AspectRatio,"sn":"AR919","box":function ($v) { return Bridge.box($v, AspectRatio, System.Enum.toStringFn(AspectRatio));}},{"a":2,"n":"AR920","is":true,"t":4,"rt":AspectRatio,"sn":"AR920","box":function ($v) { return Bridge.box($v, AspectRatio, System.Enum.toStringFn(AspectRatio));}}]}; }, $n);
    /*AspectRatio end.*/

    /*CameraHandler start.*/
    $m("CameraHandler", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"CameraForConfetti","t":8,"pi":[{"n":"camSize","pt":$n[0].Single,"ps":0}],"sn":"CameraForConfetti","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"CameraInGameplay","t":8,"pi":[{"n":"camSize","pt":$n[0].Single,"ps":0}],"sn":"CameraInGameplay","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"CheckConditionOrthoCameraConfig","t":8,"sn":"CheckConditionOrthoCameraConfig","rt":$n[0].Void},{"a":2,"n":"DisplayCharacterInChallenge","t":8,"sn":"DisplayCharacterInChallenge","rt":$n[0].Void},{"a":1,"n":"DoZoom","t":8,"pi":[{"n":"pos","pt":$n[1].Vector3,"ps":0},{"n":"toSize","pt":$n[0].Single,"ps":1}],"sn":"DoZoom","rt":$n[0].Void,"p":[$n[1].Vector3,$n[0].Single]},{"a":2,"n":"FocusItem","t":8,"pi":[{"n":"pos","pt":$n[1].Vector3,"ps":0},{"n":"toSize","dv":11.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"FocusItem","rt":$n[0].Void,"p":[$n[1].Vector3,$n[0].Single]},{"a":1,"n":"RegisterListener","t":8,"sn":"RegisterListener","rt":$n[0].Void},{"a":2,"n":"ResetCameraHome","t":8,"sn":"ResetCameraHome","rt":$n[0].Void},{"a":1,"n":"SetCamForPk","t":8,"sn":"SetCamForPk","rt":$n[0].Void},{"a":2,"n":"SetPosOfCamera","t":8,"pi":[{"n":"pos","pt":$n[1].Vector3,"ps":0}],"sn":"SetPosOfCamera","rt":$n[0].Void,"p":[$n[1].Vector3]},{"a":1,"n":"SetSize","t":8,"sn":"SetSize","rt":$n[0].Void},{"a":2,"n":"ZoomIn","t":8,"sn":"ZoomIn","rt":$n[0].Void},{"a":2,"n":"ZoomOut","t":8,"sn":"ZoomOut","rt":$n[0].Void},{"a":2,"n":"CameraMain","t":16,"rt":$n[1].Camera,"g":{"a":2,"n":"get_CameraMain","t":8,"rt":$n[1].Camera,"fg":"CameraMain"},"s":{"a":2,"n":"set_CameraMain","t":8,"p":[$n[1].Camera],"rt":$n[0].Void,"fs":"CameraMain"},"fn":"CameraMain"},{"a":2,"n":"Clickable","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Clickable","t":8,"rt":$n[0].Boolean,"fg":"Clickable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Clickable","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Clickable"},"fn":"Clickable"},{"a":2,"n":"FurnitureSelectable","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FurnitureSelectable","t":8,"rt":$n[0].Boolean,"fg":"FurnitureSelectable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FurnitureSelectable","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FurnitureSelectable"},"fn":"FurnitureSelectable"},{"a":2,"n":"Instance","is":true,"t":4,"rt":CameraHandler,"sn":"Instance"},{"a":1,"n":"_transform","t":4,"rt":$n[1].Transform,"sn":"_transform"},{"a":2,"n":"aspectRatio","t":4,"rt":AspectRatio,"sn":"aspectRatio","box":function ($v) { return Bridge.box($v, AspectRatio, System.Enum.toStringFn(AspectRatio));}},{"a":1,"n":"cameraMain","t":4,"rt":$n[1].Camera,"sn":"cameraMain"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"cameras","t":4,"rt":System.Array.type(UnityEngine.Camera),"sn":"cameras"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"cams","t":4,"rt":System.Array.type(UnityEngine.Transform),"sn":"cams"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"characterManager","t":4,"rt":CharacterManager,"sn":"characterManager"},{"a":1,"n":"clickable","t":4,"rt":$n[0].Boolean,"sn":"clickable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"defaultPos","t":4,"rt":$n[1].Vector3,"sn":"defaultPos"},{"a":2,"n":"defaultSize","t":4,"rt":$n[0].Single,"sn":"defaultSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"furnitureSelectable","t":4,"rt":$n[0].Boolean,"sn":"furnitureSelectable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"orthoSize","t":4,"rt":$n[0].Single,"sn":"orthoSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HideInInspector()],"a":1,"n":"shakePower","t":4,"rt":$n[0].Single,"sn":"shakePower","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HideInInspector()],"a":1,"n":"shakeTimer","t":4,"rt":$n[0].Single,"sn":"shakeTimer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"zoomPos","t":4,"rt":$n[1].Vector3,"sn":"zoomPos"}]}; }, $n);
    /*CameraHandler end.*/

    /*CanvasHandler start.*/
    $m("CanvasHandler", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void}]}; }, $n);
    /*CanvasHandler end.*/

    /*BreathButton start.*/
    $m("BreathButton", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"DoScale","t":8,"sn":"DoScale","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"buttonScale","t":4,"rt":$n[0].Single,"sn":"buttonScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"constantBreath","t":4,"rt":$n[0].Boolean,"sn":"constantBreath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"delayFirstTime","t":4,"rt":$n[0].Single,"sn":"delayFirstTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"increaseScale","t":4,"rt":$n[0].Boolean,"sn":"increaseScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"sq","t":4,"rt":$n[2].Sequence,"sn":"sq"}]}; }, $n);
    /*BreathButton end.*/

    /*MoneyFly start.*/
    $m("MoneyFly", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"InitSequence","t":8,"sn":"InitSequence","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"autoMoneySq","t":4,"rt":$n[2].Sequence,"sn":"autoMoneySq"},{"a":1,"n":"countTime","t":4,"rt":$n[0].Single,"sn":"countTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"mainChar","t":4,"rt":$n[0].Boolean,"sn":"mainChar","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"money","t":4,"rt":$n[3].Image,"sn":"money"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moneyTxt","t":4,"rt":$n[3].Text,"sn":"moneyTxt"},{"a":1,"n":"orgPos","t":4,"rt":$n[0].Single,"sn":"orgPos","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"outline","t":4,"rt":$n[3].Outline,"sn":"outline"},{"a":1,"n":"time","t":4,"rt":$n[0].Single,"sn":"time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*MoneyFly end.*/

    /*PopupPanel start.*/
    $m("PopupPanel", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CanTurnOff","t":8,"sn":"CanTurnOff","rt":$n[0].Void},{"v":true,"a":3,"n":"EntranceAnim","t":8,"sn":"EntranceAnim","rt":$n[0].Void},{"v":true,"a":3,"n":"InitEffect","t":8,"sn":"InitEffect","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"v":true,"a":2,"n":"OnExit","t":8,"sn":"OnExit","rt":$n[0].Void},{"v":true,"a":3,"n":"SetText","t":8,"pi":[{"n":"msg","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"SetText","rt":$n[0].Void,"p":[$n[0].String]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"adjustCamera","t":4,"rt":$n[0].Boolean,"sn":"adjustCamera","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"closeable","t":4,"rt":$n[0].Boolean,"sn":"closeable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"closed","t":4,"rt":$n[0].Boolean,"sn":"closed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"conffeti","t":4,"rt":$n[1].ParticleSystem,"sn":"conffeti"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"dailySpinPanel","t":4,"rt":$n[0].Boolean,"sn":"dailySpinPanel","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"entranceTime","t":4,"rt":$n[0].Single,"sn":"entranceTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"lastCamOrthoSize","t":4,"rt":$n[0].Single,"sn":"lastCamOrthoSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"panel","t":4,"rt":$n[1].Transform,"sn":"panel"},{"a":2,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*PopupPanel end.*/

    /*Scale start.*/
    $m("Scale", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"OnEnter","t":8,"sn":"OnEnter","rt":$n[0].Void},{"a":2,"n":"OnExit","t":8,"sn":"OnExit","rt":$n[0].Void}]}; }, $n);
    /*Scale end.*/

    /*TutHand start.*/
    $m("TutHand", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"rt","t":4,"rt":$n[1].RectTransform,"sn":"rt"}]}; }, $n);
    /*TutHand end.*/

    /*GridHandler start.*/
    $m("GridHandler", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"RestoreInitialPos","t":8,"sn":"RestoreInitialPos","rt":$n[0].Void},{"a":2,"n":"SetStateContent","t":8,"pi":[{"n":"state","pt":$n[0].Boolean,"ps":0}],"sn":"SetStateContent","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"cellSize","t":4,"rt":$n[0].Single,"sn":"cellSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"content","t":4,"rt":$n[1].RectTransform,"sn":"content"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"grid","t":4,"rt":$n[3].GridLayoutGroup,"sn":"grid"}]}; }, $n);
    /*GridHandler end.*/

    /*CameraController start.*/
    $m("CameraController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Instance","is":true,"t":4,"rt":CameraController,"sn":"Instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"characterManager","t":4,"rt":CharacterManager,"sn":"characterManager"}]}; }, $n);
    /*CameraController end.*/

    /*CharacterManager start.*/
    $m("CharacterManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ChangeToDanceAnim","t":8,"pi":[{"n":"saveDance","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"ChangeToDanceAnim","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetPos","t":8,"pi":[{"n":"pos","pt":$n[1].Vector3,"ps":0}],"sn":"SetPos","rt":$n[0].Void,"p":[$n[1].Vector3]},{"a":2,"n":"SetScale","t":8,"pi":[{"n":"range","pt":$n[0].Single,"ps":0}],"sn":"SetScale","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"SetTypeOfAnim","t":8,"pi":[{"n":"body","pt":$n[4].SkeletonAnimation,"ps":0},{"n":"id","dv":-1,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"SetTypeOfAnim","rt":$n[0].Void,"p":[$n[4].SkeletonAnimation,$n[0].Int32]},{"a":2,"n":"Instance","is":true,"t":4,"rt":CharacterManager,"sn":"Instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bodies","t":4,"rt":System.Array.type(Spine.Unity.SkeletonAnimation),"sn":"bodies"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boneFollowers","t":4,"rt":System.Array.type(Spine.Unity.BoneFollower),"sn":"boneFollowers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"headHolder","t":4,"rt":$n[1].Transform,"sn":"headHolder"},{"a":2,"n":"monsterBody","t":4,"rt":$n[0].String,"sn":"monsterBody"},{"a":1,"n":"numberVariantBody","t":4,"rt":$n[0].Int32,"sn":"numberVariantBody","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"sortingGroup","t":4,"rt":$n[5].SortingGroup,"sn":"sortingGroup"},{"a":2,"n":"spawnMoney","t":4,"rt":$n[0].Boolean,"sn":"spawnMoney","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*CharacterManager end.*/

    /*CurrencyConvert start.*/
    $m("CurrencyConvert", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DecimalConvert","is":true,"t":8,"pi":[{"n":"money","pt":$n[0].Int64,"ps":0},{"n":"precision","dv":1,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"DecimalConvert","rt":$n[0].String,"p":[$n[0].Int64,$n[0].Int32]},{"a":2,"n":"RoundConvert","is":true,"t":8,"pi":[{"n":"money","pt":$n[0].Int64,"ps":0}],"sn":"RoundConvert","rt":$n[0].String,"p":[$n[0].Int64]}]}; }, $n);
    /*CurrencyConvert end.*/

    /*DragDropTut start.*/
    $m("DragDropTut", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void}]}; }, $n);
    /*DragDropTut end.*/

    /*IdleActions start.*/
    $m("IdleActions", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnBoost","is":true,"t":4,"rt":Function,"sn":"OnBoost"},{"a":2,"n":"OnCalculatePrice","is":true,"t":4,"rt":Function,"sn":"OnCalculatePrice"},{"a":2,"n":"OnClaimOfflineReward","is":true,"t":4,"rt":Function,"sn":"OnClaimOfflineReward"},{"a":2,"n":"OnDeboost","is":true,"t":4,"rt":Function,"sn":"OnDeboost"},{"a":2,"n":"OnDecreaseBoosterPercent","is":true,"t":4,"rt":Function,"sn":"OnDecreaseBoosterPercent"},{"a":2,"n":"OnDisplayAdBooster","is":true,"t":4,"rt":Function,"sn":"OnDisplayAdBooster"},{"a":2,"n":"OnDisplayAdSkipInBuilding","is":true,"t":4,"rt":Function,"sn":"OnDisplayAdSkipInBuilding"},{"a":2,"n":"OnDisplayIdleUI","is":true,"t":4,"rt":Function,"sn":"OnDisplayIdleUI"},{"a":2,"n":"OnFocusItemInBuilding","is":true,"t":4,"rt":Function,"sn":"OnFocusItemInBuilding"},{"a":2,"n":"OnGlitch","is":true,"t":4,"rt":Function,"sn":"OnGlitch"},{"a":2,"n":"OnHideIdleUI","is":true,"t":4,"rt":Function,"sn":"OnHideIdleUI"},{"a":2,"n":"OnIncreaseBoosterPercent","is":true,"t":4,"rt":Function,"sn":"OnIncreaseBoosterPercent"},{"a":2,"n":"OnNotiCollection","is":true,"t":4,"rt":Function,"sn":"OnNotiCollection"},{"a":2,"n":"OnNotiLimitCharacter","is":true,"t":4,"rt":Function,"sn":"OnNotiLimitCharacter"},{"a":2,"n":"OnNotiUpgradeSlot","is":true,"t":4,"rt":Function,"sn":"OnNotiUpgradeSlot"},{"a":2,"n":"OnPopUpOfflineReward","is":true,"t":4,"rt":Function,"sn":"OnPopUpOfflineReward"},{"a":2,"n":"OnRaiseMoneyAllMonster","is":true,"t":4,"rt":Function,"sn":"OnRaiseMoneyAllMonster"},{"a":2,"n":"OnSwitchConditionToRaiseMoneyMonster","is":true,"t":4,"rt":Function,"sn":"OnSwitchConditionToRaiseMoneyMonster"},{"a":2,"n":"OnUnlockBottomMap","is":true,"t":4,"rt":Function,"sn":"OnUnlockBottomMap"},{"a":2,"n":"OnUnlockLeftMap","is":true,"t":4,"rt":Function,"sn":"OnUnlockLeftMap"},{"a":2,"n":"OnUnlockRightMap","is":true,"t":4,"rt":Function,"sn":"OnUnlockRightMap"},{"a":2,"n":"OnUnlockTopMap","is":true,"t":4,"rt":Function,"sn":"OnUnlockTopMap"},{"a":2,"n":"OnUpdateInBg","is":true,"t":4,"rt":Function,"sn":"OnUpdateInBg"},{"a":2,"n":"OnUpdateScaleBodyPart","is":true,"t":4,"rt":Function,"sn":"OnUpdateScaleBodyPart"}]}; }, $n);
    /*IdleActions end.*/

    /*SortingLayerCharacter start.*/
    $m("SortingLayerCharacter", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetDragState","t":8,"pi":[{"n":"state","pt":$n[0].Boolean,"ps":0}],"sn":"SetDragState","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"baseSortingOrderLayer","t":4,"rt":$n[0].Int32,"sn":"baseSortingOrderLayer","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isDrag","t":4,"rt":$n[0].Boolean,"sn":"isDrag","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"maxTimer","t":4,"rt":$n[0].Single,"sn":"maxTimer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"offset","t":4,"rt":$n[0].Int32,"sn":"offset","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"sortingGroup","t":4,"rt":$n[5].SortingGroup,"sn":"sortingGroup"},{"a":1,"n":"timer","t":4,"rt":$n[0].Single,"sn":"timer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*SortingLayerCharacter end.*/

    /*ItemDisplay start.*/
    $m("ItemDisplay", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Deselect","t":8,"sn":"Deselect","rt":$n[0].Void},{"a":2,"n":"OnClick","t":8,"sn":"OnClick","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"SetSib","t":8,"pi":[{"n":"idx","pt":$n[0].Int32,"ps":0}],"sn":"SetSib","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"Show","t":8,"pi":[{"n":"_item","pt":Item,"ps":0},{"n":"id","pt":$n[0].Int32,"ps":1}],"sn":"Show","rt":$n[0].Void,"p":[Item,$n[0].Int32]},{"a":2,"n":"_id","t":4,"rt":$n[0].Int32,"sn":"_id","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fill","t":4,"rt":$n[1].GameObject,"sn":"fill"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconScale","t":4,"rt":$n[1].Transform,"sn":"iconScale"},{"a":2,"n":"item","t":4,"rt":Item,"sn":"item"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"itemSprite","t":4,"rt":$n[3].Image,"sn":"itemSprite"}]}; }, $n);
    /*ItemDisplay end.*/

    /*SfxController start.*/
    $m("SfxController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"ChangeIcon","t":8,"sn":"ChangeIcon","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"PauseBoosterSound","t":8,"sn":"PauseBoosterSound","rt":$n[0].Void},{"a":2,"n":"PlayBoosterSound2","t":8,"sn":"PlayBoosterSound2","rt":$n[0].Void},{"a":2,"n":"PlayCashSound","t":8,"sn":"PlayCashSound","rt":$n[0].Void},{"a":2,"n":"PlayPopupSound","t":8,"sn":"PlayPopupSound","rt":$n[0].Void},{"a":2,"n":"PlayTapSound","t":8,"sn":"PlayTapSound","rt":$n[0].Void},{"a":2,"n":"SwitchSoundState","t":8,"sn":"SwitchSoundState","rt":$n[0].Void},{"a":2,"n":"SwitchVibrationState","t":8,"sn":"SwitchVibrationState","rt":$n[0].Void},{"a":2,"n":"UpdateSFXUI","t":8,"sn":"UpdateSFXUI","rt":$n[0].Void},{"a":2,"n":"Vibrate","t":8,"sn":"Vibrate","rt":$n[0].Void},{"a":1,"n":"FIRST_PLAY","is":true,"t":4,"rt":$n[0].String,"sn":"FIRST_PLAY"},{"a":2,"n":"Instance","is":true,"t":4,"rt":SfxController,"sn":"Instance"},{"a":1,"n":"SOUND","is":true,"t":4,"rt":$n[0].String,"sn":"SOUND"},{"a":1,"n":"VIBRATE","is":true,"t":4,"rt":$n[0].String,"sn":"VIBRATE"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sound","t":4,"rt":$n[6].List$1(UnityEngine.UI.Image),"sn":"sound"},{"a":1,"n":"soundImg","t":4,"rt":$n[1].Sprite,"sn":"soundImg"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundOff","t":4,"rt":$n[1].Sprite,"sn":"soundOff"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundOn","t":4,"rt":$n[1].Sprite,"sn":"soundOn"},{"a":1,"n":"soundState","t":4,"rt":$n[0].Int32,"sn":"soundState","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"vibrate","t":4,"rt":$n[6].List$1(UnityEngine.UI.Image),"sn":"vibrate"},{"a":1,"n":"vibrateImg","t":4,"rt":$n[1].Sprite,"sn":"vibrateImg"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"vibrateOff","t":4,"rt":$n[1].Sprite,"sn":"vibrateOff"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"vibrateOn","t":4,"rt":$n[1].Sprite,"sn":"vibrateOn"},{"a":1,"n":"vibrateState","t":4,"rt":$n[0].Int32,"sn":"vibrateState","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*SfxController end.*/

    /*SoundAudioClip start.*/
    $m("SoundAudioClip", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"audioClip","t":4,"rt":$n[1].AudioClip,"sn":"audioClip"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"pitch","t":4,"rt":$n[0].Single,"sn":"pitch","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"sound","t":4,"rt":Sound,"sn":"sound","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"source","t":4,"rt":$n[1].AudioSource,"sn":"source"},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"volume","t":4,"rt":$n[0].Single,"sn":"volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*SoundAudioClip end.*/

    /*Sound start.*/
    $m("Sound", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"beachBg","is":true,"t":4,"rt":Sound,"sn":"beachBg","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"bg","is":true,"t":4,"rt":Sound,"sn":"bg","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"bg2","is":true,"t":4,"rt":Sound,"sn":"bg2","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"cash","is":true,"t":4,"rt":Sound,"sn":"cash","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"cashCoin","is":true,"t":4,"rt":Sound,"sn":"cashCoin","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"concertBg","is":true,"t":4,"rt":Sound,"sn":"concertBg","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"congrate","is":true,"t":4,"rt":Sound,"sn":"congrate","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"done","is":true,"t":4,"rt":Sound,"sn":"done","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"endRandom","is":true,"t":4,"rt":Sound,"sn":"endRandom","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"firework","is":true,"t":4,"rt":Sound,"sn":"firework","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"heart","is":true,"t":4,"rt":Sound,"sn":"heart","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"heartBtn","is":true,"t":4,"rt":Sound,"sn":"heartBtn","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"losePk","is":true,"t":4,"rt":Sound,"sn":"losePk","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"makeoverPk","is":true,"t":4,"rt":Sound,"sn":"makeoverPk","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"musicSFX","is":true,"t":4,"rt":Sound,"sn":"musicSFX","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"next","is":true,"t":4,"rt":Sound,"sn":"next","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"outtro","is":true,"t":4,"rt":Sound,"sn":"outtro","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"point1","is":true,"t":4,"rt":Sound,"sn":"point1","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"point2","is":true,"t":4,"rt":Sound,"sn":"point2","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"point3","is":true,"t":4,"rt":Sound,"sn":"point3","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"popup","is":true,"t":4,"rt":Sound,"sn":"popup","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"readyPk","is":true,"t":4,"rt":Sound,"sn":"readyPk","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"rocket","is":true,"t":4,"rt":Sound,"sn":"rocket","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"rollSFX","is":true,"t":4,"rt":Sound,"sn":"rollSFX","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"start","is":true,"t":4,"rt":Sound,"sn":"start","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"startRandom","is":true,"t":4,"rt":Sound,"sn":"startRandom","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"startSFX","is":true,"t":4,"rt":Sound,"sn":"startSFX","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"startSFX2","is":true,"t":4,"rt":Sound,"sn":"startSFX2","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"teddy","is":true,"t":4,"rt":Sound,"sn":"teddy","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"toiletBg","is":true,"t":4,"rt":Sound,"sn":"toiletBg","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"unlockItem","is":true,"t":4,"rt":Sound,"sn":"unlockItem","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"unlockNewArea","is":true,"t":4,"rt":Sound,"sn":"unlockNewArea","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"winPk","is":true,"t":4,"rt":Sound,"sn":"winPk","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"winSFX","is":true,"t":4,"rt":Sound,"sn":"winSFX","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}},{"a":2,"n":"winSFX2","is":true,"t":4,"rt":Sound,"sn":"winSFX2","box":function ($v) { return Bridge.box($v, Sound, System.Enum.toStringFn(Sound));}}]}; }, $n);
    /*Sound end.*/

    /*SoundManager start.*/
    $m("SoundManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"ChangePitch","t":8,"pi":[{"n":"value","pt":$n[0].Single,"ps":0}],"sn":"ChangePitch","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"GetAudioClip","t":8,"pi":[{"n":"sound","pt":Sound,"ps":0}],"sn":"GetAudioClip","rt":SoundAudioClip,"p":[Sound]},{"a":2,"n":"PauseSound","t":8,"pi":[{"n":"sound","pt":Sound,"ps":0},{"n":"toggle","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"PauseSound","rt":$n[0].Void,"p":[Sound,$n[0].Boolean]},{"a":2,"n":"PlayItemClickedSound","t":8,"pi":[{"n":"choose","dv":-1,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"PlayItemClickedSound","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"PlaySFX","t":8,"pi":[{"n":"sound","pt":Sound,"ps":0},{"n":"volume","pt":$n[0].Single,"ps":1},{"n":"isPlayAgain","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"PlaySFX","rt":$n[0].Void,"p":[Sound,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"PlaySound","t":8,"pi":[{"n":"sound","pt":Sound,"ps":0},{"n":"toggle","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"PlaySound","rt":$n[0].Void,"p":[Sound,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Instance","is":true,"t":4,"rt":SoundManager,"sn":"Instance"},{"a":1,"n":"SOUND","is":true,"t":4,"rt":$n[0].String,"sn":"SOUND"},{"a":1,"n":"choose","t":4,"rt":$n[0].Int32,"sn":"choose","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"itemClickedAudio","t":4,"rt":System.Array.type(SoundAudioClip),"sn":"itemClickedAudio"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundAudioClips","t":4,"rt":System.Array.type(SoundAudioClip),"sn":"soundAudioClips"}]}; }, $n);
    /*SoundManager end.*/

    /*MonsterCreator start.*/
    $m("MonsterCreator", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CreateMonster","t":8,"pi":[{"n":"head","pt":Item,"ps":0},{"n":"eye","pt":Item,"ps":1},{"n":"mouth","pt":Item,"ps":2},{"n":"acc","pt":Item,"ps":3},{"n":"body","pt":Item,"ps":4}],"sn":"CreateMonster","rt":$n[0].Void,"p":[Item,Item,Item,Item,Item]},{"a":1,"n":"HandleBodyType","t":8,"pi":[{"n":"body","pt":Item,"ps":0}],"sn":"HandleBodyType","rt":$n[0].Void,"p":[Item]},{"a":1,"n":"SetTypeOfAnim","t":8,"pi":[{"n":"body","pt":$n[4].SkeletonAnimation,"ps":0},{"n":"id","dv":-1,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"SetTypeOfAnim","rt":$n[0].Void,"p":[$n[4].SkeletonAnimation,$n[0].Int32]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"accSR","t":4,"rt":$n[1].SpriteRenderer,"sn":"accSR"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"body1","t":4,"rt":$n[4].SkeletonAnimation,"sn":"body1"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"body2","t":4,"rt":$n[4].SkeletonAnimation,"sn":"body2"},{"at":[new UnityEngine.HeaderAttribute("Body"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boneFollower1","t":4,"rt":$n[4].BoneFollower,"sn":"boneFollower1"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boneFollower2","t":4,"rt":$n[4].BoneFollower,"sn":"boneFollower2"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eyeSR","t":4,"rt":$n[1].SpriteRenderer,"sn":"eyeSR"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"headHolder","t":4,"rt":$n[1].Transform,"sn":"headHolder"},{"at":[new UnityEngine.HeaderAttribute("BodyPart"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"headSR","t":4,"rt":$n[1].SpriteRenderer,"sn":"headSR"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"mouthSR","t":4,"rt":$n[1].SpriteRenderer,"sn":"mouthSR"}]}; }, $n);
    /*MonsterCreator end.*/

    /*PrefInfo start.*/
    $m("PrefInfo", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddCoin","is":true,"t":8,"pi":[{"n":"total","pt":$n[0].Int32,"ps":0}],"sn":"AddCoin","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"AddGem","is":true,"t":8,"pi":[{"n":"c","pt":$n[0].Int32,"ps":0}],"sn":"AddGem","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"AddKey","is":true,"t":8,"pi":[{"n":"amout","pt":$n[0].Int32,"ps":0}],"sn":"AddKey","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"Complete7Day","is":true,"t":8,"sn":"Complete7Day","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"CurrentDailyIndex","is":true,"t":8,"sn":"CurrentDailyIndex","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CurrentDailyIndexAd","is":true,"t":8,"sn":"CurrentDailyIndexAd","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Distance","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].Vector3,"ps":0},{"n":"b","pt":$n[1].Vector3,"ps":1}],"sn":"Distance","rt":$n[0].Single,"p":[$n[1].Vector3,$n[1].Vector3],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetCoin","is":true,"t":8,"sn":"GetCoin","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetCurrentSkin","is":true,"t":8,"pi":[{"n":"type","pt":$n[0].Int32,"ps":0}],"sn":"GetCurrentSkin","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetDayClaim","is":true,"t":8,"sn":"GetDayClaim","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetGem","is":true,"t":8,"sn":"GetGem","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetHeart","is":true,"t":8,"sn":"GetHeart","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetIQ","is":true,"t":8,"sn":"GetIQ","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetItemStatus","is":true,"t":8,"pi":[{"n":"id","pt":$n[0].Int32,"ps":0}],"sn":"GetItemStatus","rt":$n[0].Boolean,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetLastAdInChallenge","is":true,"t":8,"sn":"GetLastAdInChallenge","rt":$n[0].DateTime,"box":function ($v) { return Bridge.box($v, System.DateTime, System.DateTime.format);}},{"a":2,"n":"GetLastDieTime","is":true,"t":8,"sn":"GetLastDieTime","rt":$n[0].DateTime,"box":function ($v) { return Bridge.box($v, System.DateTime, System.DateTime.format);}},{"a":2,"n":"GetLastSpinTime","is":true,"t":8,"sn":"GetLastSpinTime","rt":$n[0].DateTime,"box":function ($v) { return Bridge.box($v, System.DateTime, System.DateTime.format);}},{"a":2,"n":"GetName","is":true,"t":8,"sn":"GetName","rt":$n[0].String},{"a":2,"n":"GetPlayTime","is":true,"t":8,"pi":[{"n":"id","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"GetPlayTime","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetSensitivity","is":true,"t":8,"sn":"GetSensitivity","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetSpin","is":true,"t":8,"sn":"GetSpin","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IncreasePlayTime","is":true,"t":8,"pi":[{"n":"am","pt":$n[0].Int32,"ps":0},{"n":"id","dv":"","o":true,"pt":$n[0].String,"ps":1}],"sn":"IncreasePlayTime","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"IsSub","is":true,"t":8,"sn":"IsSub","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsUnlimited","is":true,"t":8,"sn":"IsUnlimited","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsUnlocked","is":true,"t":8,"pi":[{"n":"id","pt":$n[0].Int32,"ps":0},{"n":"type","pt":$n[0].Int32,"ps":1}],"sn":"IsUnlocked","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsUsingAd","is":true,"t":8,"sn":"IsUsingAd","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SaveTimeLastLogin","is":true,"t":8,"pi":[{"n":"time","pt":$n[0].String,"ps":0}],"sn":"SaveTimeLastLogin","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"SaveTimeLastLoginAd","is":true,"t":8,"pi":[{"n":"time","pt":$n[0].String,"ps":0}],"sn":"SaveTimeLastLoginAd","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"SetAd","is":true,"t":8,"pi":[{"n":"active","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"SetAd","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetCoin","is":true,"t":8,"pi":[{"n":"total","pt":$n[0].Int32,"ps":0}],"sn":"SetCoin","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetComplete7Day","is":true,"t":8,"sn":"SetComplete7Day","rt":$n[0].Void},{"a":2,"n":"SetCurrentDailyGiftIndex","is":true,"t":8,"sn":"SetCurrentDailyGiftIndex","rt":$n[0].Void},{"a":2,"n":"SetCurrentDailyGiftIndexAd","is":true,"t":8,"sn":"SetCurrentDailyGiftIndexAd","rt":$n[0].Void},{"a":2,"n":"SetCurrentSkin","is":true,"t":8,"pi":[{"n":"c","pt":$n[0].Int32,"ps":0},{"n":"type","pt":$n[0].Int32,"ps":1}],"sn":"SetCurrentSkin","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetDayClaimed","is":true,"t":8,"sn":"SetDayClaimed","rt":$n[0].Void},{"a":2,"n":"SetGem","is":true,"t":8,"pi":[{"n":"c","pt":$n[0].Int32,"ps":0}],"sn":"SetGem","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetHeart","is":true,"t":8,"pi":[{"n":"c","pt":$n[0].Int32,"ps":0}],"sn":"SetHeart","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetHint","is":true,"t":8,"pi":[{"n":"currenHint","pt":$n[0].Int32,"ps":0}],"sn":"SetHint","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetIQ","is":true,"t":8,"pi":[{"n":"c","pt":$n[0].Single,"ps":0}],"sn":"SetIQ","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"SetItemStatus","is":true,"t":8,"pi":[{"n":"id","pt":$n[0].Int32,"ps":0},{"n":"status","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"SetItemStatus","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"SetKeyOwned","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].Int32,"ps":0}],"sn":"SetKeyOwned","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetLastAdInChallenge","is":true,"t":8,"pi":[{"n":"time","pt":$n[0].DateTime,"ps":0}],"sn":"SetLastAdInChallenge","rt":$n[0].Void,"p":[$n[0].DateTime]},{"a":2,"n":"SetLastDieTime","is":true,"t":8,"pi":[{"n":"time","pt":$n[0].DateTime,"ps":0}],"sn":"SetLastDieTime","rt":$n[0].Void,"p":[$n[0].DateTime]},{"a":2,"n":"SetLastSpinTime","is":true,"t":8,"pi":[{"n":"time","pt":$n[0].DateTime,"ps":0}],"sn":"SetLastSpinTime","rt":$n[0].Void,"p":[$n[0].DateTime]},{"a":2,"n":"SetName","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetName","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"SetPlayTime","is":true,"t":8,"pi":[{"n":"c","pt":$n[0].Int32,"ps":0},{"n":"id","dv":"","o":true,"pt":$n[0].String,"ps":1}],"sn":"SetPlayTime","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"SetProgress","is":true,"t":8,"pi":[{"n":"progress","pt":$n[0].Int32,"ps":0}],"sn":"SetProgress","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetSensitivity","is":true,"t":8,"pi":[{"n":"total","pt":$n[0].Single,"ps":0}],"sn":"SetSensitivity","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"SetSpin","is":true,"t":8,"pi":[{"n":"c","pt":$n[0].Int32,"ps":0}],"sn":"SetSpin","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetSubState","is":true,"t":8,"pi":[{"n":"purchased","pt":$n[0].Boolean,"ps":0}],"sn":"SetSubState","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetTier","is":true,"t":8,"pi":[{"n":"tier","pt":$n[0].Int32,"ps":0}],"sn":"SetTier","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetTotalExtraLife","is":true,"t":8,"pi":[{"n":"total","pt":$n[0].Int32,"ps":0}],"sn":"SetTotalExtraLife","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetUnlimited","is":true,"t":8,"pi":[{"n":"active","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"SetUnlimited","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetUnlocked","is":true,"t":8,"pi":[{"n":"id","pt":$n[0].Int32,"ps":0},{"n":"active","pt":$n[0].Boolean,"ps":1},{"n":"type","pt":$n[0].Int32,"ps":2}],"sn":"SetUnlocked","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32]},{"a":2,"n":"TimeLastDayLogin","is":true,"t":8,"sn":"TimeLastDayLogin","rt":$n[0].String},{"a":2,"n":"TimeLastDayLoginAd","is":true,"t":8,"sn":"TimeLastDayLoginAd","rt":$n[0].String},{"a":2,"n":"TotalExtraLife","is":true,"t":8,"sn":"TotalExtraLife","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TotalHint","is":true,"t":8,"sn":"TotalHint","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetKeyOwned","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_GetKeyOwned","t":8,"rt":$n[0].Int32,"fg":"GetKeyOwned","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"GetKeyOwned"},{"a":2,"n":"GetProgress","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_GetProgress","t":8,"rt":$n[0].Int32,"fg":"GetProgress","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"GetProgress"},{"a":2,"n":"GetTier","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_GetTier","t":8,"rt":$n[0].Int32,"fg":"GetTier","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"GetTier"},{"a":1,"n":"Complete7DayStr","is":true,"t":4,"rt":$n[0].String,"sn":"Complete7DayStr"},{"a":1,"n":"CurrentDailyIndexAdStr","is":true,"t":4,"rt":$n[0].String,"sn":"CurrentDailyIndexAdStr"},{"a":1,"n":"CurrentDailyIndexStr","is":true,"t":4,"rt":$n[0].String,"sn":"CurrentDailyIndexStr"},{"a":1,"n":"DayClaimed","is":true,"t":4,"rt":$n[0].String,"sn":"DayClaimed"},{"a":1,"n":"LastDayLoginAdStr","is":true,"t":4,"rt":$n[0].String,"sn":"LastDayLoginAdStr"},{"a":1,"n":"LastDayLoginStr","is":true,"t":4,"rt":$n[0].String,"sn":"LastDayLoginStr"}]}; }, $n);
    /*PrefInfo end.*/

    /*BodyPart start.*/
    $m("BodyPart", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Acc","is":true,"t":4,"rt":BodyPart,"sn":"Acc","box":function ($v) { return Bridge.box($v, BodyPart, System.Enum.toStringFn(BodyPart));}},{"a":2,"n":"Body","is":true,"t":4,"rt":BodyPart,"sn":"Body","box":function ($v) { return Bridge.box($v, BodyPart, System.Enum.toStringFn(BodyPart));}},{"a":2,"n":"Eye","is":true,"t":4,"rt":BodyPart,"sn":"Eye","box":function ($v) { return Bridge.box($v, BodyPart, System.Enum.toStringFn(BodyPart));}},{"a":2,"n":"Head","is":true,"t":4,"rt":BodyPart,"sn":"Head","box":function ($v) { return Bridge.box($v, BodyPart, System.Enum.toStringFn(BodyPart));}},{"a":2,"n":"Mouth","is":true,"t":4,"rt":BodyPart,"sn":"Mouth","box":function ($v) { return Bridge.box($v, BodyPart, System.Enum.toStringFn(BodyPart));}}]}; }, $n);
    /*BodyPart end.*/

    /*CatalogueTheme start.*/
    $m("CatalogueTheme", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Normal","is":true,"t":4,"rt":CatalogueTheme,"sn":"Normal","box":function ($v) { return Bridge.box($v, CatalogueTheme, System.Enum.toStringFn(CatalogueTheme));}},{"a":2,"n":"Skibidi","is":true,"t":4,"rt":CatalogueTheme,"sn":"Skibidi","box":function ($v) { return Bridge.box($v, CatalogueTheme, System.Enum.toStringFn(CatalogueTheme));}},{"a":2,"n":"alime","is":true,"t":4,"rt":CatalogueTheme,"sn":"alime","box":function ($v) { return Bridge.box($v, CatalogueTheme, System.Enum.toStringFn(CatalogueTheme));}},{"a":2,"n":"trend","is":true,"t":4,"rt":CatalogueTheme,"sn":"trend","box":function ($v) { return Bridge.box($v, CatalogueTheme, System.Enum.toStringFn(CatalogueTheme));}}]}; }, $n);
    /*CatalogueTheme end.*/

    /*Theme start.*/
    $m("Theme", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Beach","is":true,"t":4,"rt":Theme,"sn":"Beach","box":function ($v) { return Bridge.box($v, Theme, System.Enum.toStringFn(Theme));}},{"a":2,"n":"Concert","is":true,"t":4,"rt":Theme,"sn":"Concert","box":function ($v) { return Bridge.box($v, Theme, System.Enum.toStringFn(Theme));}},{"a":2,"n":"Toilet","is":true,"t":4,"rt":Theme,"sn":"Toilet","box":function ($v) { return Bridge.box($v, Theme, System.Enum.toStringFn(Theme));}}]}; }, $n);
    /*Theme end.*/

    /*Priority start.*/
    $m("Priority", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"High","is":true,"t":4,"rt":Priority,"sn":"High","box":function ($v) { return Bridge.box($v, Priority, System.Enum.toStringFn(Priority));}},{"a":2,"n":"Low","is":true,"t":4,"rt":Priority,"sn":"Low","box":function ($v) { return Bridge.box($v, Priority, System.Enum.toStringFn(Priority));}},{"a":2,"n":"SeasonReward","is":true,"t":4,"rt":Priority,"sn":"SeasonReward","box":function ($v) { return Bridge.box($v, Priority, System.Enum.toStringFn(Priority));}}]}; }, $n);
    /*Priority end.*/

    /*Item start.*/
    $m("Item", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "Item", menuName: "Scriptable Object/Item", order: 0
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"adNum","t":4,"rt":$n[0].Int32,"sn":"adNum","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("=======")],"a":2,"n":"bodyPart","t":4,"rt":BodyPart,"sn":"bodyPart","box":function ($v) { return Bridge.box($v, BodyPart, System.Enum.toStringFn(BodyPart));}},{"a":2,"n":"bodypartName","t":4,"rt":$n[0].String,"sn":"bodypartName"},{"a":2,"n":"catalogue","t":4,"rt":CatalogueTheme,"sn":"catalogue","box":function ($v) { return Bridge.box($v, CatalogueTheme, System.Enum.toStringFn(CatalogueTheme));}},{"a":2,"n":"dataAsset","t":4,"rt":$n[0].Int32,"sn":"dataAsset","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"id","t":4,"rt":$n[0].Int32,"sn":"id","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Currency")],"a":2,"n":"isAd","t":4,"rt":$n[0].Boolean,"sn":"isAd","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"part","t":4,"rt":$n[1].Sprite,"sn":"part"},{"at":[new UnityEngine.HeaderAttribute("Theme")],"a":2,"n":"pkTheme","t":4,"rt":Theme,"sn":"pkTheme","box":function ($v) { return Bridge.box($v, Theme, System.Enum.toStringFn(Theme));}},{"a":2,"n":"preview","t":4,"rt":$n[1].Sprite,"sn":"preview"},{"a":2,"n":"price","t":4,"rt":$n[0].Int32,"sn":"price","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Priority")],"a":2,"n":"priority","t":4,"rt":Priority,"sn":"priority","box":function ($v) { return Bridge.box($v, Priority, System.Enum.toStringFn(Priority));}},{"a":2,"n":"realPos","t":4,"rt":$n[1].Vector3,"sn":"realPos"},{"a":2,"n":"specialPos","t":4,"rt":$n[0].Boolean,"sn":"specialPos","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Item end.*/

    /*ShopController start.*/
    $m("ShopController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"CheckNextStep","t":8,"pi":[{"n":"id","pt":$n[0].Int32,"ps":0}],"sn":"CheckNextStep","rt":$n[0].Boolean,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"FocusHeadCharacter","t":8,"sn":"FocusHeadCharacter","rt":$n[0].Void},{"a":1,"n":"ForcusEntireCharacter","t":8,"sn":"ForcusEntireCharacter","rt":$n[0].Void},{"a":1,"n":"GetReference","t":8,"sn":"GetReference","rt":$n[0].Void},{"a":2,"n":"HandleSortItemIngame","t":8,"sn":"HandleSortItemIngame","rt":$n[0].Void},{"a":2,"n":"InitItems","t":8,"pi":[{"n":"items","pt":System.Array.type(Item),"ps":0},{"n":"content","pt":$n[1].Transform,"ps":1},{"n":"startIdx","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"InitItems","rt":$n[0].Void,"p":[System.Array.type(Item),$n[1].Transform,$n[0].Int32]},{"a":1,"n":"OnClickItem","t":8,"pi":[{"n":"id","pt":$n[0].Int32,"ps":0}],"sn":"OnClickItem","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetCurrenBodyPartController","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"SetCurrenBodyPartController","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"SortArr","t":8,"pi":[{"n":"items","pt":System.Array.type(Item),"ps":0}],"sn":"SortArr","rt":$n[0].Void,"p":[System.Array.type(Item)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Bodies","t":16,"rt":System.Array.type(Item),"g":{"a":2,"n":"get_Bodies","t":8,"rt":System.Array.type(Item),"fg":"Bodies"},"s":{"a":2,"n":"set_Bodies","t":8,"p":[System.Array.type(Item)],"rt":$n[0].Void,"fs":"Bodies"},"fn":"Bodies"},{"a":2,"n":"CurrentAcc","t":16,"rt":Item,"g":{"a":2,"n":"get_CurrentAcc","t":8,"rt":Item,"fg":"CurrentAcc"},"s":{"a":2,"n":"set_CurrentAcc","t":8,"p":[Item],"rt":$n[0].Void,"fs":"CurrentAcc"},"fn":"CurrentAcc"},{"a":2,"n":"CurrentBody","t":16,"rt":Item,"g":{"a":2,"n":"get_CurrentBody","t":8,"rt":Item,"fg":"CurrentBody"},"s":{"a":2,"n":"set_CurrentBody","t":8,"p":[Item],"rt":$n[0].Void,"fs":"CurrentBody"},"fn":"CurrentBody"},{"a":2,"n":"CurrentEye","t":16,"rt":Item,"g":{"a":2,"n":"get_CurrentEye","t":8,"rt":Item,"fg":"CurrentEye"},"s":{"a":2,"n":"set_CurrentEye","t":8,"p":[Item],"rt":$n[0].Void,"fs":"CurrentEye"},"fn":"CurrentEye"},{"a":2,"n":"CurrentHead","t":16,"rt":Item,"g":{"a":2,"n":"get_CurrentHead","t":8,"rt":Item,"fg":"CurrentHead"},"s":{"a":2,"n":"set_CurrentHead","t":8,"p":[Item],"rt":$n[0].Void,"fs":"CurrentHead"},"fn":"CurrentHead"},{"a":2,"n":"CurrentMouth","t":16,"rt":Item,"g":{"a":2,"n":"get_CurrentMouth","t":8,"rt":Item,"fg":"CurrentMouth"},"s":{"a":2,"n":"set_CurrentMouth","t":8,"p":[Item],"rt":$n[0].Void,"fs":"CurrentMouth"},"fn":"CurrentMouth"},{"a":2,"n":"IsPickBody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsPickBody","t":8,"rt":$n[0].Boolean,"fg":"IsPickBody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_IsPickBody","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsPickBody"},"fn":"IsPickBody"},{"a":2,"n":"Instance","is":true,"t":4,"rt":ShopController,"sn":"Instance"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"acc","t":4,"rt":$n[1].GameObject,"sn":"acc"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"accContents","t":4,"rt":$n[1].Transform,"sn":"accContents"},{"a":1,"n":"accController","t":4,"rt":TouchController,"sn":"accController"},{"a":1,"n":"acc_img","t":4,"rt":$n[1].SpriteRenderer,"sn":"acc_img"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"accs","t":4,"rt":System.Array.type(Item),"sn":"accs"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"bodies","t":4,"rt":System.Array.type(Item),"sn":"bodies"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"body","t":4,"rt":$n[1].GameObject,"sn":"body"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"body2","t":4,"rt":$n[1].GameObject,"sn":"body2"},{"a":1,"n":"bodyAnim","t":4,"rt":$n[4].SkeletonAnimation,"sn":"bodyAnim"},{"a":1,"n":"bodyAnim2","t":4,"rt":$n[4].SkeletonAnimation,"sn":"bodyAnim2"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"bodyContent","t":4,"rt":$n[1].Transform,"sn":"bodyContent"},{"a":1,"n":"bodyPart","t":4,"rt":BodyPart,"sn":"bodyPart","box":function ($v) { return Bridge.box($v, BodyPart, System.Enum.toStringFn(BodyPart));}},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boneFollower","t":4,"rt":$n[4].BoneFollower,"sn":"boneFollower"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boneFollower2","t":4,"rt":$n[4].BoneFollower,"sn":"boneFollower2"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"characterManager","t":4,"rt":$n[1].Transform,"sn":"characterManager"},{"a":1,"n":"currentAcc","t":4,"rt":Item,"sn":"currentAcc"},{"a":1,"n":"currentBody","t":4,"rt":Item,"sn":"currentBody"},{"a":1,"n":"currentEye","t":4,"rt":Item,"sn":"currentEye"},{"at":[new UnityEngine.HeaderAttribute("Current body part in scriptable object")],"a":1,"n":"currentHead","t":4,"rt":Item,"sn":"currentHead"},{"a":1,"n":"currentMouth","t":4,"rt":Item,"sn":"currentMouth"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eye","t":4,"rt":$n[1].GameObject,"sn":"eye"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"eyeContent","t":4,"rt":$n[1].Transform,"sn":"eyeContent"},{"a":1,"n":"eyeController","t":4,"rt":TouchController,"sn":"eyeController"},{"a":1,"n":"eyePos","t":4,"rt":$n[1].Vector3,"sn":"eyePos"},{"a":1,"n":"eye_img","t":4,"rt":$n[1].SpriteRenderer,"sn":"eye_img"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"eyes","t":4,"rt":System.Array.type(Item),"sn":"eyes"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"handTut","t":4,"rt":$n[1].GameObject,"sn":"handTut"},{"at":[new UnityEngine.HeaderAttribute("Preview Bodypart"),new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"head","t":4,"rt":$n[1].GameObject,"sn":"head"},{"at":[new UnityEngine.HeaderAttribute("BodyPart Content"),new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"headContent","t":4,"rt":$n[1].Transform,"sn":"headContent"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"headHolder","t":4,"rt":$n[1].Transform,"sn":"headHolder"},{"a":1,"n":"head_img","t":4,"rt":$n[1].SpriteRenderer,"sn":"head_img"},{"at":[new UnityEngine.HeaderAttribute("List Scriptable Object"),new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"heads","t":4,"rt":System.Array.type(Item),"sn":"heads"},{"a":1,"n":"idAcc","t":4,"rt":$n[0].Int32,"sn":"idAcc","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"idEye","t":4,"rt":$n[0].Int32,"sn":"idEye","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"idMouth","t":4,"rt":$n[0].Int32,"sn":"idMouth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"isPickAcc","t":4,"rt":$n[0].Boolean,"sn":"isPickAcc","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isPickBody","t":4,"rt":$n[0].Boolean,"sn":"isPickBody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isPickEye","t":4,"rt":$n[0].Boolean,"sn":"isPickEye","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isPickHead","t":4,"rt":$n[0].Boolean,"sn":"isPickHead","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isPickMouth","t":4,"rt":$n[0].Boolean,"sn":"isPickMouth","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"mouth","t":4,"rt":$n[1].GameObject,"sn":"mouth"},{"at":[new UnityEngine.HideInInspector(),new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"mouthContent","t":4,"rt":$n[1].Transform,"sn":"mouthContent"},{"a":1,"n":"mouthController","t":4,"rt":TouchController,"sn":"mouthController"},{"a":1,"n":"mouthPos","t":4,"rt":$n[1].Vector3,"sn":"mouthPos"},{"a":1,"n":"mouth_img","t":4,"rt":$n[1].SpriteRenderer,"sn":"mouth_img"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"mouths","t":4,"rt":System.Array.type(Item),"sn":"mouths"}]}; }, $n);
    /*ShopController end.*/

    /*Tab start.*/
    $m("Tab", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnDisplay","t":8,"sn":"OnDisplay","rt":$n[0].Void},{"a":2,"n":"OnExit","t":8,"pi":[{"n":"tick","pt":$n[0].Boolean,"ps":0}],"sn":"OnExit","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"at":[new UnityEngine.HeaderAttribute("Ref"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bodyPartLink","t":4,"rt":$n[1].Transform,"sn":"bodyPartLink"},{"at":[new UnityEngine.HeaderAttribute("State"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bubble","t":4,"rt":Scale,"sn":"bubble"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"check","t":4,"rt":$n[1].GameObject,"sn":"check"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fill","t":4,"rt":$n[3].Image,"sn":"fill"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"selected","t":4,"rt":$n[1].Color32,"sn":"selected"}]}; }, $n);
    /*Tab end.*/

    /*TabMenuHandler start.*/
    $m("TabMenuHandler", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"InitState","t":8,"sn":"InitState","rt":$n[0].Void},{"a":2,"n":"NextTab","t":8,"sn":"NextTab","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"ResetTabs","t":8,"sn":"ResetTabs","rt":$n[0].Void},{"a":2,"n":"SetStateNextBtn","t":8,"pi":[{"n":"id","pt":$n[0].Int32,"ps":0}],"sn":"SetStateNextBtn","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"TurnOnNextBtn","t":8,"sn":"TurnOnNextBtn","rt":$n[0].Void},{"a":2,"n":"Instance","is":true,"t":4,"rt":TabMenuHandler,"sn":"Instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"done_Btn","t":4,"rt":$n[1].GameObject,"sn":"done_Btn"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fade","t":4,"rt":$n[1].Color,"sn":"fade"},{"a":1,"n":"firstPlay","t":4,"rt":$n[0].Boolean,"sn":"firstPlay","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"handTut","t":4,"rt":$n[1].GameObject,"sn":"handTut"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"handtut","t":4,"rt":$n[1].GameObject,"sn":"handtut"},{"a":1,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"isSliderShow","t":4,"rt":$n[0].Boolean,"sn":"isSliderShow","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"nextBtn","t":4,"rt":$n[3].Image,"sn":"nextBtn"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"next_Btn","t":4,"rt":$n[1].GameObject,"sn":"next_Btn"},{"a":1,"n":"nextable","t":4,"rt":$n[0].Boolean,"sn":"nextable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Slider"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"slider","t":4,"rt":$n[3].Slider,"sn":"slider"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"tabContents","t":4,"rt":$n[6].List$1(GridHandler),"sn":"tabContents"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"tabSelection","t":4,"rt":$n[6].List$1(Tab),"sn":"tabSelection"},{"a":2,"n":"targetScaleBodyPart","t":4,"rt":$n[1].Transform,"sn":"targetScaleBodyPart"}]}; }, $n);
    /*TabMenuHandler end.*/

    /*TouchController start.*/
    $m("TouchController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BeginDraw","t":8,"sn":"BeginDraw","rt":$n[0].Void},{"a":1,"n":"Drawing","t":8,"sn":"Drawing","rt":$n[0].Void},{"a":2,"n":"EndDraw","t":8,"sn":"EndDraw","rt":$n[0].Void},{"a":2,"n":"InDraw","t":8,"sn":"InDraw","rt":$n[0].Void},{"a":1,"n":"LimitPosition","t":8,"pi":[{"n":"position","pt":$n[1].Vector3,"ps":0}],"sn":"LimitPosition","rt":$n[1].Vector3,"p":[$n[1].Vector3]},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"_camera","t":4,"rt":$n[1].Camera,"sn":"_camera"},{"a":1,"n":"corners","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"corners"},{"a":1,"n":"deltaX","t":4,"rt":$n[0].Single,"sn":"deltaX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"deltaY","t":4,"rt":$n[0].Single,"sn":"deltaY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"isDrawing","t":4,"rt":$n[0].Boolean,"sn":"isDrawing","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mousePos","t":4,"rt":$n[1].Vector3,"sn":"mousePos"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"rb","t":4,"rt":$n[1].Rigidbody2D,"sn":"rb"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"speed","t":4,"rt":$n[0].Single,"sn":"speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*TouchController end.*/

    /*UI_Endgame start.*/
    $m("UI_Endgame", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnClickDownload","t":8,"sn":"OnClickDownload","rt":$n[0].Void},{"a":2,"n":"OnEntrance","t":8,"sn":"OnEntrance","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"canvasGroup","t":4,"rt":$n[1].CanvasGroup,"sn":"canvasGroup"}]}; }, $n);
    /*UI_Endgame end.*/

    /*UI_Ingame start.*/
    $m("UI_Ingame", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ChangeIconToDone","t":8,"sn":"ChangeIconToDone","rt":$n[0].Void},{"a":2,"n":"DeactiveDoneBtn","t":8,"sn":"DeactiveDoneBtn","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"doneBtn","t":4,"rt":$n[3].Button,"sn":"doneBtn"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"nextBtn","t":4,"rt":$n[1].GameObject,"sn":"nextBtn"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"tabMenuElements","t":4,"rt":$n[6].List$1(UnityEngine.RectTransform),"sn":"tabMenuElements"}]}; }, $n);
    /*UI_Ingame end.*/

    /*UI_Result start.*/
    $m("UI_Result", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleExtraMonster1","t":8,"sn":"HandleExtraMonster1","rt":$n[0].Void},{"a":1,"n":"HandleExtraMonster2","t":8,"sn":"HandleExtraMonster2","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bgAnim","t":4,"rt":$n[1].GameObject,"sn":"bgAnim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"characterManager","t":4,"rt":CharacterManager,"sn":"characterManager"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"characterZone","t":4,"rt":$n[1].Transform,"sn":"characterZone"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"extraMonster1","t":4,"rt":MonsterCreator,"sn":"extraMonster1"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"extraMonster2","t":4,"rt":MonsterCreator,"sn":"extraMonster2"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ingameBg","t":4,"rt":$n[1].GameObject,"sn":"ingameBg"},{"a":1,"n":"money","t":4,"rt":$n[0].Int32,"sn":"money","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moneyTxt","t":4,"rt":$n[3].Text,"sn":"moneyTxt"},{"a":1,"n":"range","t":4,"rt":$n[0].Single,"sn":"range","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"shopController","t":4,"rt":ShopController,"sn":"shopController"},{"a":1,"n":"timer","t":4,"rt":$n[0].Single,"sn":"timer","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*UI_Result end.*/

    /*UI_Transition start.*/
    $m("UI_Transition", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnExit","t":8,"sn":"OnExit","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"canvasGroup","t":4,"rt":$n[1].CanvasGroup,"sn":"canvasGroup"}]}; }, $n);
    /*UI_Transition end.*/

    /*UIHandler start.*/
    $m("UIHandler", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Done","t":8,"sn":"Done","rt":$n[0].Void},{"a":1,"n":"HandleDoneBtn","t":8,"sn":"HandleDoneBtn","rt":$n[0].Void},{"a":1,"n":"PauseGameplay","t":8,"sn":"PauseGameplay","rt":$n[0].Void},{"a":2,"n":"PlayDanceAnimForMonster","t":8,"sn":"PlayDanceAnimForMonster","rt":$n[0].Void},{"a":1,"n":"PlayEffect","t":8,"pi":[{"n":"_typeMode","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"PlayEffect","rt":$n[7].IEnumerator,"p":[$n[0].Int32]},{"a":1,"n":"ResumeGameplay","t":8,"sn":"ResumeGameplay","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UI_Ingame","t":16,"rt":UI_Ingame,"g":{"a":2,"n":"get_UI_Ingame","t":8,"rt":UI_Ingame,"fg":"UI_Ingame"},"s":{"a":2,"n":"set_UI_Ingame","t":8,"p":[UI_Ingame],"rt":$n[0].Void,"fs":"UI_Ingame"},"fn":"UI_Ingame"},{"a":2,"n":"Instance","is":true,"t":4,"rt":UIHandler,"sn":"Instance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bodyAnim","t":4,"rt":$n[4].SkeletonAnimation,"sn":"bodyAnim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bodyAnim2","t":4,"rt":$n[4].SkeletonAnimation,"sn":"bodyAnim2"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"character","t":4,"rt":$n[1].GameObject,"sn":"character"},{"a":2,"n":"curtainAnim","t":4,"rt":$n[4].SkeletonGraphic,"sn":"curtainAnim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"endGamePanel","t":4,"rt":UI_Endgame,"sn":"endGamePanel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"limitArea","t":4,"rt":$n[1].RectTransform,"sn":"limitArea"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moneyRain","t":4,"rt":$n[1].ParticleSystem,"sn":"moneyRain"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"transition","t":4,"rt":UI_Transition,"sn":"transition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"uI_Ingame","t":4,"rt":UI_Ingame,"sn":"uI_Ingame"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"uI_Result","t":4,"rt":UI_Result,"sn":"uI_Result"}]}; }, $n);
    /*UIHandler end.*/

    /*EventDispatcher start.*/
    $m("EventDispatcher", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"ClearAllListener","t":8,"sn":"ClearAllListener","rt":$n[0].Void},{"a":2,"n":"HasInstance","is":true,"t":8,"sn":"HasInstance","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"PostEvent","t":8,"pi":[{"n":"eventID","pt":EventID,"ps":0},{"n":"param","dv":null,"o":true,"pt":$n[0].Object,"ps":1}],"sn":"PostEvent","rt":$n[0].Void,"p":[EventID,$n[0].Object]},{"a":2,"n":"RegisterListener","t":8,"pi":[{"n":"eventID","pt":EventID,"ps":0},{"n":"callback","pt":Function,"ps":1}],"sn":"RegisterListener","rt":$n[0].Void,"p":[EventID,Function]},{"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"eventID","pt":EventID,"ps":0},{"n":"callback","pt":Function,"ps":1}],"sn":"RemoveListener","rt":$n[0].Void,"p":[EventID,Function]},{"a":2,"n":"Instance","is":true,"t":16,"rt":EventDispatcher,"g":{"a":2,"n":"get_Instance","t":8,"rt":EventDispatcher,"fg":"Instance","is":true},"s":{"a":1,"n":"set_Instance","t":8,"p":[EventDispatcher],"rt":$n[0].Void,"fs":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"_listeners","t":4,"rt":$n[6].Dictionary$2(EventID,Function),"sn":"_listeners"},{"a":1,"n":"s_instance","is":true,"t":4,"rt":EventDispatcher,"sn":"s_instance"}]}; }, $n);
    /*EventDispatcher end.*/

    /*EventDispatcherExtension start.*/
    $m("EventDispatcherExtension", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"PostEvent","is":true,"t":8,"pi":[{"n":"sender","pt":$n[1].MonoBehaviour,"ps":0},{"n":"eventID","pt":EventID,"ps":1}],"sn":"PostEvent","rt":$n[0].Void,"p":[$n[1].MonoBehaviour,EventID]},{"a":2,"n":"PostEvent","is":true,"t":8,"pi":[{"n":"listener","pt":$n[1].MonoBehaviour,"ps":0},{"n":"eventID","pt":EventID,"ps":1},{"n":"param","pt":$n[0].Object,"ps":2}],"sn":"PostEvent$1","rt":$n[0].Void,"p":[$n[1].MonoBehaviour,EventID,$n[0].Object]},{"a":2,"n":"RegisterListener","is":true,"t":8,"pi":[{"n":"listener","pt":$n[1].MonoBehaviour,"ps":0},{"n":"eventID","pt":EventID,"ps":1},{"n":"callback","pt":Function,"ps":2}],"sn":"RegisterListener","rt":$n[0].Void,"p":[$n[1].MonoBehaviour,EventID,Function]}]}; }, $n);
    /*EventDispatcherExtension end.*/

    /*EventID start.*/
    $m("EventID", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnBuyItem","is":true,"t":4,"rt":EventID,"sn":"OnBuyItem","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnClick","is":true,"t":4,"rt":EventID,"sn":"OnClick","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnDisplayAdItem","is":true,"t":4,"rt":EventID,"sn":"OnDisplayAdItem","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnEnterIdleMode","is":true,"t":4,"rt":EventID,"sn":"OnEnterIdleMode","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnEnterLeaderboard","is":true,"t":4,"rt":EventID,"sn":"OnEnterLeaderboard","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnEnterPkMode","is":true,"t":4,"rt":EventID,"sn":"OnEnterPkMode","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnEnterShop","is":true,"t":4,"rt":EventID,"sn":"OnEnterShop","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnPickLevel","is":true,"t":4,"rt":EventID,"sn":"OnPickLevel","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnReplay","is":true,"t":4,"rt":EventID,"sn":"OnReplay","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnReplayPK","is":true,"t":4,"rt":EventID,"sn":"OnReplayPK","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnRewardSpin","is":true,"t":4,"rt":EventID,"sn":"OnRewardSpin","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnRewardTop1","is":true,"t":4,"rt":EventID,"sn":"OnRewardTop1","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnRewardTop10","is":true,"t":4,"rt":EventID,"sn":"OnRewardTop10","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnRewardTop100","is":true,"t":4,"rt":EventID,"sn":"OnRewardTop100","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnRewardTop2","is":true,"t":4,"rt":EventID,"sn":"OnRewardTop2","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnRewardTop3","is":true,"t":4,"rt":EventID,"sn":"OnRewardTop3","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnRewardTop50","is":true,"t":4,"rt":EventID,"sn":"OnRewardTop50","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnStart","is":true,"t":4,"rt":EventID,"sn":"OnStart","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnSubcribe","is":true,"t":4,"rt":EventID,"sn":"OnSubcribe","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnTakeAShot","is":true,"t":4,"rt":EventID,"sn":"OnTakeAShot","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnTurnOffInteractNativeAd","is":true,"t":4,"rt":EventID,"sn":"OnTurnOffInteractNativeAd","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnTurnOffSuggestSymbolItems","is":true,"t":4,"rt":EventID,"sn":"OnTurnOffSuggestSymbolItems","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnUnlock","is":true,"t":4,"rt":EventID,"sn":"OnUnlock","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnUnlockAdItems","is":true,"t":4,"rt":EventID,"sn":"OnUnlockAdItems","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnUnlockLevel","is":true,"t":4,"rt":EventID,"sn":"OnUnlockLevel","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}},{"a":2,"n":"OnUnlockPkMode","is":true,"t":4,"rt":EventID,"sn":"OnUnlockPkMode","box":function ($v) { return Bridge.box($v, EventID, System.Enum.toStringFn(EventID));}}]}; }, $n);
    /*EventID end.*/

    /*MyDebug start.*/
    $m("MyDebug", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Log","is":true,"t":8,"pi":[{"n":"message","pt":$n[0].Object,"ps":0}],"sn":"Log","rt":$n[0].Void,"p":[$n[0].Object]},{"a":2,"n":"Log","is":true,"t":8,"pi":[{"n":"message","pt":$n[0].Object,"ps":0},{"n":"context","pt":$n[1].Object,"ps":1}],"sn":"Log$1","rt":$n[0].Void,"p":[$n[0].Object,$n[1].Object]},{"a":2,"n":"LogError","is":true,"t":8,"pi":[{"n":"message","pt":$n[0].Object,"ps":0}],"sn":"LogError","rt":$n[0].Void,"p":[$n[0].Object]},{"a":2,"n":"LogError","is":true,"t":8,"pi":[{"n":"message","pt":$n[0].Object,"ps":0},{"n":"context","pt":$n[1].Object,"ps":1}],"sn":"LogError$1","rt":$n[0].Void,"p":[$n[0].Object,$n[1].Object]},{"a":2,"n":"LogWarning","is":true,"t":8,"pi":[{"n":"message","pt":$n[0].Object,"ps":0}],"sn":"LogWarning","rt":$n[0].Void,"p":[$n[0].Object]},{"a":2,"n":"LogWarning","is":true,"t":8,"pi":[{"n":"message","pt":$n[0].Object,"ps":0},{"n":"context","pt":$n[1].Object,"ps":1}],"sn":"LogWarning$1","rt":$n[0].Void,"p":[$n[0].Object,$n[1].Object]},{"a":1,"n":"canLog","is":true,"t":4,"rt":$n[0].Boolean,"sn":"canLog","ro":true,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*MyDebug end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[2].Tweener,"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[2].Sequence,"p":[$n[1].SpriteRenderer,pc.ColorGradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[2].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[2].Tweener,"p":[$n[3].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[2].Tweener,"p":[$n[3].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[2].Tweener,"p":[$n[3].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Outline,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Outline,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$3","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"fromValue","pt":$n[0].Int32,"ps":1},{"n":"endValue","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[9].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[8].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[3].Text,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[9].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Outline,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Outline,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$4","rt":$n[8].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Image,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[2].Sequence,"p":[$n[3].Image,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[2].Tweener,"p":[$n[3].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[2].Sequence,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].ScrollRect,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[2].Tweener,"p":[$n[3].ScrollRect,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"punch","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[2].Tweener,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Outline,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOScale","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Outline,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[2].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos","rt":$n[2].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[2].ShakeRandomnessMode]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[1].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[2].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos$1","rt":$n[2].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[1].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[2].ShakeRandomnessMode]},{"a":2,"n":"DOShapeCircle","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"center","pt":$n[1].Vector2,"ps":1},{"n":"endValueDegrees","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"relativeCenter","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOShapeCircle","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.CircleOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[2].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[8].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[3].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[2].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[8].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[2].Tweener,"p":[$n[3].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[2].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[1].RectTransform,"ps":0},{"n":"to","pt":$n[1].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[1].Vector2,"p":[$n[1].RectTransform,$n[1].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[2].Sequence,"p":[$n[1].Material,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[2].Sequence,"p":[$n[1].Material,pc.ColorGradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[8].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[2].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[1].CustomYieldInstruction,"p":[$n[2].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[2].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[1].CustomYieldInstruction,"p":[$n[2].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[2].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[1].CustomYieldInstruction,"p":[$n[2].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[2].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[1].CustomYieldInstruction,"p":[$n[2].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[2].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[1].CustomYieldInstruction,"p":[$n[2].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[2].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[1].CustomYieldInstruction,"p":[$n[2].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[2].DOTweenCYInstruction.WaitForCompletion,$n[2].DOTweenCYInstruction.WaitForRewind,$n[2].DOTweenCYInstruction.WaitForKill,$n[2].DOTweenCYInstruction.WaitForElapsedLoops,$n[2].DOTweenCYInstruction.WaitForPosition,$n[2].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[2].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].Tween],"pi":[{"n":"tween","pt":$n[2].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[2].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[2].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].Tween],"pi":[{"n":"tween","pt":$n[2].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[2].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[2].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].Tween],"pi":[{"n":"tween","pt":$n[2].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[2].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[2].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[2].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[2].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[2].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[2].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[2].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[2].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].Tween],"pi":[{"n":"tween","pt":$n[2].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[2].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[2].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[2].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[10].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[2].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[8].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[10].Path,$n[0].Single,$n[2].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[11].PathOptions,"ps":0},{"n":"t","pt":$n[2].Tween,"ps":1},{"n":"newRot","pt":$n[1].Quaternion,"ps":2},{"n":"trans","pt":$n[1].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[11].PathOptions,$n[2].Tween,$n[1].Quaternion,$n[1].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*Spine.BoneMatrix start.*/
    $m("Spine.BoneMatrix", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[12].Bone],"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[spine.BoneData],"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"CalculateSetupWorld","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"CalculateSetupWorld","rt":$n[12].BoneMatrix,"p":[spine.BoneData]},{"a":1,"n":"GetInheritedInternal","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0},{"n":"parentMatrix","pt":$n[12].BoneMatrix,"ps":1}],"sn":"GetInheritedInternal","rt":$n[12].BoneMatrix,"p":[spine.BoneData,$n[12].BoneMatrix]},{"a":2,"n":"TransformMatrix","t":8,"pi":[{"n":"local","pt":$n[12].BoneMatrix,"ps":0}],"sn":"TransformMatrix","rt":$n[12].BoneMatrix,"p":[$n[12].BoneMatrix]},{"a":2,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    $m("Spine.SpineSkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InheritsRotation","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsRotation","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InheritsScale","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsScale","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWeighted","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0}],"sn":"IsWeighted","rt":$n[0].Boolean,"p":[spine.VertexAttachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    $m("Spine.Unity.AnimationReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/Animation Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[4].AnimationReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[12].Animation,"p":[$n[4].AnimationReferenceAsset]},{"a":2,"n":"Animation","t":16,"rt":$n[12].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[12].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"animation","t":4,"rt":$n[12].Animation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":3,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    $m("Spine.Unity.AtlasAssetBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[12].Atlas,"p":[$n[0].Boolean]},{"ab":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ab":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ab":true,"a":2,"n":"Materials","t":16,"rt":$n[6].IEnumerable$1(UnityEngine.Material),"g":{"ab":true,"a":2,"n":"get_Materials","t":8,"rt":$n[6].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ab":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ab":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":1,"backing":true,"n":"<IsLoaded>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<MaterialCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Materials>k__BackingField","t":4,"rt":$n[6].IEnumerable$1(UnityEngine.Material),"sn":"Materials"},{"a":1,"backing":true,"n":"<PrimaryMaterial>k__BackingField","t":4,"rt":$n[1].Material,"sn":"PrimaryMaterial"}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials", function () { return {"nested":[$n[4].BlendModeMaterials.ReplacementMaterial],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyMaterials","t":8,"pi":[{"n":"skeletonData","pt":$n[12].SkeletonData,"ps":0}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[12].SkeletonData]},{"a":2,"n":"BlendModeForMaterial","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"BlendModeForMaterial","rt":spine.BlendMode,"p":[$n[1].Material],"box":function ($v) { return Bridge.box($v, spine.BlendMode, System.Enum.toStringFn(spine.BlendMode));}},{"a":3,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[12].AtlasRegion,"ps":0},{"n":"replacementMaterials","pt":$n[6].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[12].AtlasRegion,"p":[$n[12].AtlasRegion,$n[6].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)]},{"a":2,"n":"RequiresBlendModeMaterials","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RequiresBlendModeMaterials","t":8,"rt":$n[0].Boolean,"fg":"RequiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RequiresBlendModeMaterials","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RequiresBlendModeMaterials"},"fn":"RequiresBlendModeMaterials"},{"a":2,"n":"additiveMaterials","t":4,"rt":$n[6].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"additiveMaterials"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterials","t":4,"rt":$n[6].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"multiplyMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":3,"n":"requiresBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"requiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterials","t":4,"rt":$n[6].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"screenMaterials"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    $m("Spine.Unity.BlendModeMaterials.ReplacementMaterial", function () { return {"td":$n[4].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"pageName","t":4,"rt":$n[0].String,"sn":"pageName"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    $m("Spine.Unity.EventDataReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/EventData Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[4].EventDataReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":spine.EventData,"p":[$n[4].EventDataReferenceAsset]},{"a":2,"n":"EventData","t":16,"rt":spine.EventData,"g":{"a":2,"n":"get_EventData","t":8,"rt":spine.EventData,"fg":"EventData"},"fn":"EventData"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventData","t":4,"rt":spine.EventData,"sn":"eventData"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineEvent("", "skeletonDataAsset", true, false, false)],"a":3,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    $m("Spine.Unity.RegionlessAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[12].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":spine.BoundingBoxAttachment,"p":[$n[12].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[12].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":spine.ClippingAttachment,"p":[$n[12].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[12].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":spine.Sequence,"ps":3}],"sn":"NewMeshAttachment","rt":$n[12].MeshAttachment,"p":[$n[12].Skin,$n[0].String,$n[0].String,spine.Sequence]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[12].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":spine.PathAttachment,"p":[$n[12].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[12].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[12].PointAttachment,"p":[$n[12].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[12].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":spine.Sequence,"ps":3}],"sn":"NewRegionAttachment","rt":$n[12].RegionAttachment,"p":[$n[12].Skin,$n[0].String,$n[0].String,spine.Sequence]},{"a":1,"n":"EmptyRegion","is":true,"t":16,"rt":$n[12].AtlasRegion,"g":{"a":1,"n":"get_EmptyRegion","t":8,"rt":$n[12].AtlasRegion,"fg":"EmptyRegion","is":true},"fn":"EmptyRegion"},{"a":1,"n":"emptyRegion","is":true,"t":4,"rt":$n[12].AtlasRegion,"sn":"emptyRegion"}]}; }, $n);
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    $m("Spine.Unity.SkeletonDataAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New SkeletonDataAsset", menuName: "Spine/SkeletonData Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAsset","pt":$n[4].AtlasAssetBase,"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[4].SkeletonDataAsset,"p":[$n[1].TextAsset,$n[4].AtlasAssetBase,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAssets","pt":System.Array.type(Spine.Unity.AtlasAssetBase),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[4].SkeletonDataAsset,"p":[$n[1].TextAsset,System.Array.type(Spine.Unity.AtlasAssetBase),$n[0].Boolean,$n[0].Single]},{"a":2,"n":"FillStateData","t":8,"pi":[{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"FillStateData","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"GetAnimationStateData","t":8,"sn":"GetAnimationStateData","rt":spine.AnimationStateData},{"a":4,"n":"GetAtlasArray","t":8,"sn":"GetAtlasArray","rt":System.Array.type(Spine.Atlas)},{"a":2,"n":"GetSkeletonData","t":8,"pi":[{"n":"quiet","pt":$n[0].Boolean,"ps":0}],"sn":"GetSkeletonData","rt":$n[12].SkeletonData,"p":[$n[0].Boolean]},{"a":4,"n":"InitializeWithData","t":8,"pi":[{"n":"sd","pt":$n[12].SkeletonData,"ps":0}],"sn":"InitializeWithData","rt":$n[0].Void,"p":[$n[12].SkeletonData]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"attachmentLoader","pt":$n[12].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData","rt":$n[12].SkeletonData,"p":[$n[0].Array.type(System.Byte),$n[12].AttachmentLoader,$n[0].Single]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0},{"n":"attachmentLoader","pt":$n[12].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData$1","rt":$n[12].SkeletonData,"p":[$n[0].String,$n[12].AttachmentLoader,$n[0].Single]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"a":2,"n":"atlasAssets","t":4,"rt":System.Array.type(Spine.Unity.AtlasAssetBase),"sn":"atlasAssets"},{"a":2,"n":"blendModeMaterials","t":4,"rt":$n[4].BlendModeMaterials,"sn":"blendModeMaterials"},{"a":2,"n":"controller","t":4,"rt":$n[1].RuntimeAnimatorController,"sn":"controller"},{"a":2,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"duration","t":4,"rt":$n[0].Array.type(System.Single),"sn":"duration"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"fromAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"fromAnimation"},{"a":2,"n":"isUpgradingBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"isUpgradingBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonData","t":4,"rt":$n[12].SkeletonData,"sn":"skeletonData"},{"at":[new UnityEngine.TooltipAttribute("Use SkeletonDataModifierAssets to apply changes to the SkeletonData after being loaded, such as apply blend mode Materials to Attachments under slots with special blend modes.")],"a":2,"n":"skeletonDataModifiers","t":4,"rt":$n[6].List$1(Spine.Unity.SkeletonDataModifierAsset),"sn":"skeletonDataModifiers"},{"a":2,"n":"skeletonJSON","t":4,"rt":$n[1].TextAsset,"sn":"skeletonJSON"},{"a":1,"n":"stateData","t":4,"rt":spine.AnimationStateData,"sn":"stateData"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"toAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"toAnimation"}]}; }, $n);
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    $m("Spine.Unity.SkeletonDataCompatibility", function () { return {"nested":[$n[4].SkeletonDataCompatibility.SourceType,$n[4].SkeletonDataCompatibility.VersionInfo,$n[4].SkeletonDataCompatibility.CompatibilityProblemInfo],"att":1048961,"a":2,"s":true}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.SourceType", function () { return {"td":$n[4].SkeletonDataCompatibility,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Binary","is":true,"t":4,"rt":$n[4].SkeletonDataCompatibility.SourceType,"sn":"Binary","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"Json","is":true,"t":4,"rt":$n[4].SkeletonDataCompatibility.SourceType,"sn":"Json","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.VersionInfo", function () { return {"td":$n[4].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"rawVersion","t":4,"rt":$n[0].String,"sn":"rawVersion"},{"a":2,"n":"sourceType","t":4,"rt":$n[4].SkeletonDataCompatibility.SourceType,"sn":"sourceType","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"version","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"version"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", function () { return {"td":$n[4].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DescriptionString","t":8,"sn":"DescriptionString","rt":$n[0].String},{"a":2,"n":"actualVersion","t":4,"rt":$n[4].SkeletonDataCompatibility.VersionInfo,"sn":"actualVersion"},{"a":2,"n":"compatibleVersions","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"compatibleVersions"},{"a":2,"n":"explicitProblemDescription","t":4,"rt":$n[0].String,"sn":"explicitProblemDescription"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    $m("Spine.Unity.SkeletonDataModifierAsset", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[12].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[12].SkeletonData]}]}; }, $n);
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    $m("Spine.Unity.SpineAtlasAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine Atlas Asset", menuName: "Spine/Spine Atlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[4].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Material),$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$1","rt":$n[4].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Material,$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$2","rt":$n[4].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Shader,$n[0].Boolean,Function]},{"a":2,"n":"GenerateMesh","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"mesh","pt":$n[1].Mesh,"ps":1},{"n":"material","out":true,"pt":$n[1].Material,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"GenerateMesh","rt":$n[1].Mesh,"p":[$n[0].String,$n[1].Mesh,$n[1].Material,$n[0].Single]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[12].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[6].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[6].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[12].Atlas,"sn":"atlas"},{"a":2,"n":"atlasFile","t":4,"rt":$n[1].TextAsset,"sn":"atlasFile"},{"a":2,"n":"customTextureLoader","t":4,"rt":$n[12].TextureLoader,"sn":"customTextureLoader"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    $m("Spine.Unity.NoOpTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[12].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[12].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    $m("Spine.Unity.MaterialsTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].SpineAtlasAsset],"pi":[{"n":"atlasAsset","pt":$n[4].SpineAtlasAsset,"ps":0}],"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[12].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[12].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]},{"a":1,"n":"atlasAsset","t":4,"rt":$n[4].SpineAtlasAsset,"sn":"atlasAsset"}]}; }, $n);
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.BoneFollower start.*/
    $m("Spine.Unity.BoneFollower", function () { return {"nested":[$n[4].BoneFollower.AxisOrientation],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/BoneFollower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[4].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[4].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[4].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[4].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[4].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"bone","t":4,"rt":$n[12].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonRenderer", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("followScale")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("resetOnAwake")],"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[4].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    $m("Spine.Unity.BoneFollower.AxisOrientation", function () { return {"td":$n[4].BoneFollower,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XAxis","is":true,"t":4,"rt":$n[4].BoneFollower.AxisOrientation,"sn":"XAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"YAxis","is":true,"t":4,"rt":$n[4].BoneFollower.AxisOrientation,"sn":"YAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}}]}; }, $n);
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    $m("Spine.Unity.BoneFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/UI/BoneFollowerGraphic"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonGraphic","t":16,"rt":$n[4].SkeletonGraphic,"g":{"a":2,"n":"get_SkeletonGraphic","t":8,"rt":$n[4].SkeletonGraphic,"fg":"SkeletonGraphic"},"s":{"a":2,"n":"set_SkeletonGraphic","t":8,"p":[$n[4].SkeletonGraphic],"rt":$n[0].Void,"fs":"SkeletonGraphic"},"fn":"SkeletonGraphic"},{"a":2,"n":"bone","t":4,"rt":$n[12].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[4].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    $m("Spine.Unity.BoundingBoxFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[12].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":3}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[12].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[4].SkeletonRenderer,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[4].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[12].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[12].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[6].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[6].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"slot","t":4,"rt":$n[12].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    $m("Spine.Unity.BoundingBoxFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[12].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":4}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[12].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Single,$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[4].SkeletonGraphic,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[4].SkeletonGraphic]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[12].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[12].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[6].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[6].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"slot","t":4,"rt":$n[12].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonGraphic", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.PointFollower start.*/
    $m("Spine.Unity.PointFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/Point Follower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#PointFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[4].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[4].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"UpdateReferences","t":8,"sn":"UpdateReferences","rt":$n[0].Void},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[4].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[4].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[4].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[4].SkeletonRenderer,"fg":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":1,"n":"bone","t":4,"rt":$n[12].Bone,"sn":"bone"},{"a":2,"n":"followRotation","t":4,"rt":$n[0].Boolean,"sn":"followRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonZPosition","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"point","t":4,"rt":$n[12].PointAttachment,"sn":"point"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "slotName", "skeletonRenderer", "", true, true)],"a":2,"n":"pointAttachmentName","t":4,"rt":$n[0].String,"sn":"pointAttachmentName"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":1,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    $m("Spine.Unity.SkeletonSubmeshGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"OnPopulateMesh","t":8,"pi":[{"n":"vh","pt":$n[3].VertexHelper,"ps":0}],"sn":"OnPopulateMesh","rt":$n[0].Void,"p":[$n[3].VertexHelper]},{"ov":true,"a":2,"n":"SetMaterialDirty","t":8,"sn":"SetMaterialDirty","rt":$n[0].Void},{"ov":true,"a":2,"n":"SetVerticesDirty","t":8,"sn":"SetVerticesDirty","rt":$n[0].Void}]}; }, $n);
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    $m("Spine.Unity.SkeletonMecanimRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanimRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[4].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"OnClipApplied","t":8,"pi":[{"n":"animation","pt":$n[12].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1},{"n":"weight","pt":$n[0].Single,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"lastTime","pt":$n[0].Single,"ps":4},{"n":"playsBackward","pt":$n[0].Boolean,"ps":5}],"sn":"OnClipApplied","rt":$n[0].Void,"p":[$n[12].Animation,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"SkeletonMecanim","t":16,"rt":$n[4].SkeletonMecanim,"g":{"a":2,"n":"get_SkeletonMecanim","t":8,"rt":$n[4].SkeletonMecanim,"fg":"SkeletonMecanim"},"fn":"SkeletonMecanim"},{"a":1,"n":"DefaultMecanimLayerFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultMecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"mecanimLayerFlags","t":4,"rt":$n[0].Int32,"sn":"mecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"movementDelta","t":4,"rt":$n[1].Vector2,"sn":"movementDelta"},{"a":3,"n":"rotationDelta","t":4,"rt":$n[0].Single,"sn":"rotationDelta","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonMecanim","t":4,"rt":$n[4].SkeletonMecanim,"sn":"skeletonMecanim"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    $m("Spine.Unity.SkeletonRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[12].TrackEntry,"ps":1},{"n":"track","pt":$n[12].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta","rt":$n[0].Void,"p":[$n[0].Single,$n[12].TrackEntry,$n[12].TrackEntry]},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[1].Vector2,"ps":0},{"n":"next","pt":$n[12].TrackEntry,"ps":1},{"n":"track","pt":$n[12].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta$1","rt":$n[0].Void,"p":[$n[1].Vector2,$n[12].TrackEntry,$n[12].TrackEntry]},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetMixAlpha","t":8,"pi":[{"n":"cumulatedMixAlpha","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[12].TrackEntry,"ps":1},{"n":"track","pt":$n[12].TrackEntry,"ps":2}],"sn":"GetMixAlpha","rt":$n[0].Void,"p":[$n[0].Single,$n[12].TrackEntry,$n[12].TrackEntry]},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[4].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"ov":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":1,"n":"DefaultAnimationTrackFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultAnimationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationState","t":4,"rt":$n[12].AnimationState,"sn":"animationState"},{"a":2,"n":"animationTrackFlags","t":4,"rt":$n[0].Int32,"sn":"animationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"canvas","t":4,"rt":$n[1].Canvas,"sn":"canvas"}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    $m("Spine.Unity.SkeletonRootMotionBase", function () { return {"nested":[Function,$n[4].SkeletonRootMotionBase.RootMotionInfo],"att":1048705,"a":2,"at":[new UnityEngine.DefaultExecutionOrder(1)],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustRootMotionToDistance","t":8,"pi":[{"n":"distanceToTarget","pt":$n[1].Vector2,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"adjustX","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"adjustY","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"minX","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"maxX","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":5},{"n":"minY","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6},{"n":"maxY","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":7},{"n":"allowXTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"allowYTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"AdjustRootMotionToDistance","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ApplyConstraintToPos","t":8,"pi":[{"n":"animation","pt":$n[12].Animation,"ps":0},{"n":"constraint","pt":$n[12].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintPos","pt":$n[0].Boolean,"ps":4},{"n":"pos","ref":true,"pt":$n[1].Vector2,"ps":5}],"sn":"ApplyConstraintToPos","rt":$n[0].Void,"p":[$n[12].Animation,$n[12].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[1].Vector2]},{"a":1,"n":"ApplyConstraintToRotation","t":8,"pi":[{"n":"animation","pt":$n[12].Animation,"ps":0},{"n":"constraint","pt":$n[12].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintRotation","pt":$n[0].Boolean,"ps":4},{"n":"rotation","ref":true,"pt":$n[0].Single,"ps":5}],"sn":"ApplyConstraintToRotation","rt":$n[0].Void,"p":[$n[12].Animation,$n[12].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ApplyRootMotion","t":8,"pi":[{"n":"skeletonTranslationDelta","pt":$n[1].Vector2,"ps":0},{"n":"skeletonRotationDelta","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":2},{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":3}],"sn":"ApplyRootMotion","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Single,$n[1].Vector2,$n[0].Boolean]},{"a":1,"n":"ApplyTransformConstraints","t":8,"sn":"ApplyTransformConstraints","rt":$n[0].Void},{"ab":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"v":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ClearEffectiveBoneOffsets","t":8,"pi":[{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":0}],"sn":"ClearEffectiveBoneOffsets","rt":$n[0].Void,"p":[$n[1].Vector2]},{"a":1,"n":"ClearRigidbodyTempMovement","t":8,"sn":"ClearRigidbodyTempMovement","rt":$n[0].Void},{"a":3,"n":"FindRigidbodyComponent","t":8,"sn":"FindRigidbodyComponent","rt":$n[0].Void},{"a":1,"n":"FindTransformConstraintsAffectingBone","t":8,"sn":"FindTransformConstraintsAffectingBone","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GatherTopLevelBones","t":8,"sn":"GatherTopLevelBones","rt":$n[0].Void},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"animation","pt":$n[12].Animation,"ps":0}],"sn":"GetAnimationRootMotion","rt":$n[1].Vector2,"p":[$n[12].Animation]},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[12].Animation,"ps":2}],"sn":"GetAnimationRootMotion$1","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,$n[12].Animation]},{"a":2,"n":"GetAnimationRootMotionInfo","t":8,"pi":[{"n":"animation","pt":$n[12].Animation,"ps":0},{"n":"currentTime","pt":$n[0].Single,"ps":1}],"sn":"GetAnimationRootMotionInfo","rt":$n[4].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[12].Animation,$n[0].Single]},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"animation","pt":$n[12].Animation,"ps":0}],"sn":"GetAnimationRootMotionRotation","rt":$n[0].Single,"p":[$n[12].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[12].Animation,"ps":2}],"sn":"GetAnimationRootMotionRotation$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[12].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetConstraintLastPosIndex","t":8,"pi":[{"n":"constraintIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetConstraintLastPosIndex","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ab":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ab":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[4].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"sn":"GetScaleAffectingRootMotion","rt":$n[1].Vector2},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"pi":[{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":0}],"sn":"GetScaleAffectingRootMotion$1","rt":$n[1].Vector2,"p":[$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceMovementDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":1},{"n":"totalScale","out":true,"pt":$n[1].Vector2,"ps":2}],"sn":"GetSkeletonSpaceMovementDelta","rt":$n[1].Vector2,"p":[$n[1].Vector2,$n[1].Vector2,$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceRotationDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[0].Single,"ps":0},{"n":"totalScaleAffectingRootMotion","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpaceRotationDelta","rt":$n[0].Single,"p":[$n[0].Single,$n[1].Vector2],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":2},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":3},{"n":"animation","pt":$n[12].Animation,"ps":4}],"sn":"GetTimelineMovementDelta","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,spine.TranslateXTimeline,spine.TranslateYTimeline,$n[12].Animation]},{"a":1,"n":"HandleUpdateLocal","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[4].ISkeletonAnimation,"ps":0}],"sn":"HandleUpdateLocal","rt":$n[0].Void,"p":[$n[4].ISkeletonAnimation]},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"PhysicsUpdate","t":8,"pi":[{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":0}],"sn":"PhysicsUpdate","rt":$n[0].Void,"p":[$n[0].Boolean]},{"v":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SetEffectiveBoneOffsetsTo","t":8,"pi":[{"n":"displacementSkeletonSpace","pt":$n[1].Vector2,"ps":0},{"n":"rotationSkeletonSpace","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":2}],"sn":"SetEffectiveBoneOffsetsTo","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Single,$n[1].Vector2]},{"a":2,"n":"SetRootMotionBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetRootMotionBone","rt":$n[0].Void,"p":[$n[0].String]},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateLastConstraintPos","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintPos","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":1,"n":"UpdateLastConstraintRotation","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintRotation","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":2,"n":"AdditionalRigidbody2DMovement","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_AdditionalRigidbody2DMovement","t":8,"rt":$n[1].Vector2,"fg":"AdditionalRigidbody2DMovement"},"s":{"a":2,"n":"set_AdditionalRigidbody2DMovement","t":8,"p":[$n[1].Vector2],"rt":$n[0].Void,"fs":"AdditionalRigidbody2DMovement"},"fn":"AdditionalRigidbody2DMovement"},{"v":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"v":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":2,"n":"PreviousRigidbodyRootMotion2D","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion2D","t":8,"rt":$n[1].Vector2,"fg":"PreviousRigidbodyRootMotion2D"},"fn":"PreviousRigidbodyRootMotion2D"},{"a":2,"n":"PreviousRigidbodyRootMotion3D","t":16,"rt":$n[1].Vector3,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion3D","t":8,"rt":$n[1].Vector3,"fg":"PreviousRigidbodyRootMotion3D"},"fn":"PreviousRigidbodyRootMotion3D"},{"a":2,"n":"RootMotionBone","t":16,"rt":$n[12].Bone,"g":{"a":2,"n":"get_RootMotionBone","t":8,"rt":$n[12].Bone,"fg":"RootMotionBone"},"fn":"RootMotionBone"},{"a":3,"n":"SkeletonAnimationUsesFixedUpdate","t":16,"rt":$n[0].Boolean,"g":{"a":3,"n":"get_SkeletonAnimationUsesFixedUpdate","t":8,"rt":$n[0].Boolean,"fg":"SkeletonAnimationUsesFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"SkeletonAnimationUsesFixedUpdate"},{"a":2,"n":"TargetSkeletonAnimationComponent","t":16,"rt":$n[4].ISkeletonAnimation,"g":{"a":2,"n":"get_TargetSkeletonAnimationComponent","t":8,"rt":$n[4].ISkeletonAnimation,"fg":"TargetSkeletonAnimationComponent"},"fn":"TargetSkeletonAnimationComponent"},{"a":2,"n":"TargetSkeletonComponent","t":16,"rt":$n[4].ISkeletonComponent,"g":{"a":2,"n":"get_TargetSkeletonComponent","t":8,"rt":$n[4].ISkeletonComponent,"fg":"TargetSkeletonComponent"},"fn":"TargetSkeletonComponent"},{"a":2,"n":"UsesRigidbody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRigidbody","t":8,"rt":$n[0].Boolean,"fg":"UsesRigidbody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"UsesRigidbody"},{"a":3,"n":"accumulatedUntilFixedUpdate","t":4,"rt":$n[0].Boolean,"sn":"accumulatedUntilFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"additionalRigidbody2DMovement","t":4,"rt":$n[1].Vector2,"sn":"additionalRigidbody2DMovement"},{"a":2,"n":"applyRigidbody2DGravity","t":4,"rt":$n[0].Boolean,"sn":"applyRigidbody2DGravity","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"disableOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"initialOffset","t":4,"rt":$n[1].Vector2,"sn":"initialOffset"},{"a":3,"n":"initialOffsetRotation","t":4,"rt":$n[0].Single,"sn":"initialOffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"previousRigidbodyRootMotion","t":4,"rt":$n[1].Vector3,"sn":"previousRigidbodyRootMotion"},{"a":2,"n":"rigidBody","t":4,"rt":$n[1].Rigidbody,"sn":"rigidBody"},{"at":[new UnityEngine.HeaderAttribute("Optional")],"a":2,"n":"rigidBody2D","t":4,"rt":$n[1].Rigidbody2D,"sn":"rigidBody2D"},{"a":3,"n":"rigidbody2DRotation","t":4,"rt":$n[0].Single,"sn":"rigidbody2DRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"rigidbodyDisplacement","t":4,"rt":$n[1].Vector3,"sn":"rigidbodyDisplacement"},{"a":3,"n":"rigidbodyLocalRotation","t":4,"rt":$n[1].Quaternion,"sn":"rigidbodyLocalRotation"},{"a":3,"n":"rootMotionBone","t":4,"rt":$n[12].Bone,"sn":"rootMotionBone"},{"a":3,"n":"rootMotionBoneIndex","t":4,"rt":$n[0].Int32,"sn":"rootMotionBoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineBone("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"rootMotionBoneName","t":4,"rt":$n[0].String,"sn":"rootMotionBoneName"},{"a":2,"n":"rootMotionScaleRotation","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleX","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleY","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateXPerY","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateXPerY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateYPerX","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateYPerX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"skeletonComponent","t":4,"rt":$n[4].ISkeletonComponent,"sn":"skeletonComponent"},{"a":3,"n":"tempSkeletonDisplacement","t":4,"rt":$n[1].Vector2,"sn":"tempSkeletonDisplacement"},{"a":3,"n":"tempSkeletonRotation","t":4,"rt":$n[0].Single,"sn":"tempSkeletonRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"topLevelBones","t":4,"rt":$n[6].List$1(Spine.Bone),"sn":"topLevelBones"},{"a":3,"n":"transformConstraintIndices","t":4,"rt":$n[6].List$1(System.Int32),"sn":"transformConstraintIndices"},{"a":3,"n":"transformConstraintLastPos","t":4,"rt":$n[6].List$1(UnityEngine.Vector2),"sn":"transformConstraintLastPos"},{"a":3,"n":"transformConstraintLastRotation","t":4,"rt":$n[6].List$1(System.Single),"sn":"transformConstraintLastRotation"},{"a":2,"n":"transformPositionX","t":4,"rt":$n[0].Boolean,"sn":"transformPositionX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformPositionY","t":4,"rt":$n[0].Boolean,"sn":"transformPositionY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformRotation","t":4,"rt":$n[0].Boolean,"sn":"transformRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"PhysicsUpdateRootMotionOverride","t":2,"ad":{"a":2,"n":"add_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addPhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removePhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"ProcessRootMotionOverride","t":2,"ad":{"a":2,"n":"add_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    $m("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", function () { return {"td":$n[4].SkeletonRootMotionBase,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"current","t":4,"rt":$n[1].Vector2,"sn":"current"},{"a":2,"n":"end","t":4,"rt":$n[1].Vector2,"sn":"end"},{"a":2,"n":"mid","t":4,"rt":$n[1].Vector2,"sn":"mid"},{"a":2,"n":"start","t":4,"rt":$n[1].Vector2,"sn":"start"},{"a":2,"n":"timeIsPastMid","t":4,"rt":$n[0].Boolean,"sn":"timeIsPastMid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    $m("Spine.Unity.SkeletonAnimation", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonAnimation"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonAnimation-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddToGameObject","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"AddToGameObject","rt":$n[4].SkeletonAnimation,"p":[$n[1].GameObject,$n[4].SkeletonDataAsset,$n[0].Boolean]},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSkeletonAnimationGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NewSkeletonAnimationGameObject","rt":$n[4].SkeletonAnimation,"p":[$n[4].SkeletonDataAsset,$n[0].Boolean]},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":3,"n":"Update","t":8,"sn":"Update$1","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AnimationName","t":8,"rt":$n[0].String,"fg":"AnimationName"},"s":{"a":2,"n":"set_AnimationName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AnimationName"},"fn":"AnimationName"},{"a":2,"n":"AnimationState","t":16,"rt":$n[12].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[12].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[4].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[4].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[4].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"_animationName","t":4,"rt":$n[0].String,"sn":"_animationName"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"state","t":4,"rt":$n[12].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[4].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    $m("Spine.Unity.SkeletonGraphic", function () { return {"nested":[$n[4].SkeletonGraphic.LayoutMode,Function,Function,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.CanvasRenderer, UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonGraphic (Unity UI Canvas)"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphic-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSkeletonGraphicComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"AddSkeletonGraphicComponent","rt":$n[4].SkeletonGraphic,"p":[$n[1].GameObject,$n[4].SkeletonDataAsset,$n[1].Material]},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":3,"n":"DestroyMeshes","t":8,"sn":"DestroyMeshes","rt":$n[0].Void},{"a":3,"n":"DisableUnusedCanvasRenderers","t":8,"pi":[{"n":"usedCount","pt":$n[0].Int32,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DisableUnusedCanvasRenderers","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"DisposeMeshBuffers","t":8,"sn":"DisposeMeshBuffers","rt":$n[0].Void},{"a":3,"n":"EnsureCanvasRendererCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCanvasRendererCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureMeshesCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshesCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureSeparatorPartCount","t":8,"sn":"EnsureSeparatorPartCount","rt":$n[0].Void},{"a":3,"n":"EnsureUsedTexturesAndMaterialsCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureUsedTexturesAndMaterialsCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GetCurrentRectSize","t":8,"sn":"GetCurrentRectSize","rt":$n[1].Vector2},{"a":2,"n":"GetLastMesh","t":8,"sn":"GetLastMesh","rt":$n[1].Mesh},{"a":3,"n":"GetLayoutScale","t":8,"pi":[{"n":"mode","pt":$n[4].SkeletonGraphic.LayoutMode,"ps":0}],"sn":"GetLayoutScale","rt":$n[0].Single,"p":[$n[4].SkeletonGraphic.LayoutMode],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"HasMultipleSubmeshInstructions","t":8,"sn":"HasMultipleSubmeshInstructions","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"InitMeshBuffers","t":8,"sn":"InitMeshBuffers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":3,"n":"MatchRectTransformMultipleRenderers","t":8,"sn":"MatchRectTransformMultipleRenderers","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"MatchRectTransformSingleRenderer","t":8,"sn":"MatchRectTransformSingleRenderer","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MatchRectTransformWithBounds","t":8,"sn":"MatchRectTransformWithBounds","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"NewSkeletonGraphicGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"NewSkeletonGraphicGameObject","rt":$n[4].SkeletonGraphic,"p":[$n[4].SkeletonDataAsset,$n[1].Transform,$n[1].Material]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":3,"n":"OnCullStateChanged","t":8,"pi":[{"n":"culled","pt":$n[0].Boolean,"ps":0}],"sn":"OnCullStateChanged","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"PrepareInstructionsAndRenderers","t":8,"pi":[{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"PrepareInstructionsAndRenderers","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"PrepareRendererGameObjects","t":8,"pi":[{"n":"currentInstructions","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"PrepareRendererGameObjects","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"ov":true,"a":2,"n":"Rebuild","t":8,"pi":[{"n":"update","pt":$n[3].CanvasUpdate,"ps":0}],"sn":"Rebuild","rt":$n[0].Void,"p":[$n[3].CanvasUpdate]},{"a":1,"n":"SetRectTransformBounds","t":8,"pi":[{"n":"combinedBounds","pt":$n[1].Bounds,"ps":0}],"sn":"SetRectTransformBounds","rt":$n[0].Void,"p":[$n[1].Bounds]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Graphic,"ps":0},{"n":"size","pt":$n[1].Vector2,"ps":1}],"sn":"SetRectTransformSize","rt":$n[0].Void,"p":[$n[3].Graphic,$n[1].Vector2]},{"a":3,"n":"SyncSubmeshGraphicsWithCanvasRenderers","t":8,"sn":"SyncSubmeshGraphicsWithCanvasRenderers","rt":$n[0].Void},{"a":2,"n":"TrimRenderers","t":8,"sn":"TrimRenderers","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateMaterialsMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMaterialsMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMesh","t":8,"sn":"UpdateMesh","rt":$n[0].Void},{"a":3,"n":"UpdateMeshMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":3,"n":"UpdateMeshSingleCanvasRenderer","t":8,"pi":[{"n":"currentInstructions","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshSingleCanvasRenderer","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMeshToInstructions","t":8,"sn":"UpdateMeshToInstructions","rt":$n[0].Void},{"a":3,"n":"UpdateSeparatorPartParents","t":8,"sn":"UpdateSeparatorPartParents","rt":$n[0].Void},{"a":2,"n":"AnimationState","t":16,"rt":$n[12].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[12].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[6].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[6].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomTextureOverride","t":16,"rt":$n[6].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"g":{"a":2,"n":"get_CustomTextureOverride","t":8,"rt":$n[6].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"fg":"CustomTextureOverride"},"fn":"CustomTextureOverride"},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"MaterialsMultipleCanvasRenderers","t":16,"rt":$n[12].ExposedList$1(UnityEngine.Material),"g":{"a":2,"n":"get_MaterialsMultipleCanvasRenderers","t":8,"rt":$n[12].ExposedList$1(UnityEngine.Material),"fg":"MaterialsMultipleCanvasRenderers"},"fn":"MaterialsMultipleCanvasRenderers"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[4].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[4].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshesMultipleCanvasRenderers","t":16,"rt":$n[12].ExposedList$1(UnityEngine.Mesh),"g":{"a":2,"n":"get_MeshesMultipleCanvasRenderers","t":8,"rt":$n[12].ExposedList$1(UnityEngine.Mesh),"fg":"MeshesMultipleCanvasRenderers"},"fn":"MeshesMultipleCanvasRenderers"},{"a":2,"n":"OverrideTexture","t":16,"rt":$n[1].Texture,"g":{"a":2,"n":"get_OverrideTexture","t":8,"rt":$n[1].Texture,"fg":"OverrideTexture"},"s":{"a":2,"n":"set_OverrideTexture","t":8,"p":[$n[1].Texture],"rt":$n[0].Void,"fs":"OverrideTexture"},"fn":"OverrideTexture"},{"a":2,"n":"SeparatorParts","t":16,"rt":$n[6].List$1(UnityEngine.Transform),"g":{"a":2,"n":"get_SeparatorParts","t":8,"rt":$n[6].List$1(UnityEngine.Transform),"fg":"SeparatorParts"},"fn":"SeparatorParts"},{"a":2,"n":"Skeleton","t":16,"rt":$n[12].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[12].Skeleton,"fg":"Skeleton"},"s":{"a":2,"n":"set_Skeleton","t":8,"p":[$n[12].Skeleton],"rt":$n[0].Void,"fs":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[12].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[12].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"TexturesMultipleCanvasRenderers","t":16,"rt":$n[12].ExposedList$1(UnityEngine.Texture),"g":{"a":2,"n":"get_TexturesMultipleCanvasRenderers","t":8,"rt":$n[12].ExposedList$1(UnityEngine.Texture),"fg":"TexturesMultipleCanvasRenderers"},"fn":"TexturesMultipleCanvasRenderers"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[4].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[4].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[4].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[4].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[4].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[4].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"ov":true,"a":2,"n":"mainTexture","t":16,"rt":$n[1].Texture,"g":{"ov":true,"a":2,"n":"get_mainTexture","t":8,"rt":$n[1].Texture,"fg":"mainTexture"},"fn":"mainTexture"},{"a":3,"n":"EditReferenceRect","is":true,"t":4,"rt":$n[0].Boolean,"sn":"EditReferenceRect","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SeparatorPartGameObjectName","is":true,"t":4,"rt":$n[0].String,"sn":"SeparatorPartGameObjectName"},{"a":2,"n":"additiveMaterial","t":4,"rt":$n[1].Material,"sn":"additiveMaterial"},{"a":2,"n":"allowMultipleCanvasRenderers","t":4,"rt":$n[0].Boolean,"sn":"allowMultipleCanvasRenderers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"baseTexture","t":4,"rt":$n[1].Texture,"sn":"baseTexture"},{"a":2,"n":"canvasRenderers","t":4,"rt":$n[6].List$1(UnityEngine.CanvasRenderer),"sn":"canvasRenderers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[4].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[6].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customTextureOverride","t":4,"rt":$n[6].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"sn":"customTextureOverride","ro":true},{"a":2,"n":"disableMeshAssignmentOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableMeshAssignmentOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"enableSeparatorSlots","t":4,"rt":$n[0].Boolean,"sn":"enableSeparatorSlots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"freeze","t":4,"rt":$n[0].Boolean,"sn":"freeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"layoutScaleMode","t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"layoutScaleMode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":1,"n":"meshBuffers","t":4,"rt":$n[4].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"meshBuffers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"meshGenerator","t":4,"rt":$n[4].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshes","t":4,"rt":$n[12].ExposedList$1(UnityEngine.Mesh),"sn":"meshes","ro":true},{"a":2,"n":"multiplyMaterial","t":4,"rt":$n[1].Material,"sn":"multiplyMaterial"},{"a":1,"n":"overrideTexture","t":4,"rt":$n[1].Texture,"sn":"overrideTexture"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceScale","t":4,"rt":$n[0].Single,"sn":"referenceScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceSize","t":4,"rt":$n[1].Vector2,"sn":"referenceSize"},{"a":1,"n":"requiresInstructionUpate","t":4,"rt":$n[0].Boolean,"sn":"requiresInstructionUpate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterial","t":4,"rt":$n[1].Material,"sn":"screenMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"separatorParts","t":4,"rt":$n[6].List$1(UnityEngine.Transform),"sn":"separatorParts"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[6].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":3,"n":"skeleton","t":4,"rt":$n[12].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"a":2,"n":"startingLoop","t":4,"rt":$n[0].Boolean,"sn":"startingLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"state","t":4,"rt":$n[12].AnimationState,"sn":"state"},{"a":3,"n":"submeshGraphics","t":4,"rt":$n[6].List$1(Spine.Unity.SkeletonSubmeshGraphic),"sn":"submeshGraphics"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[4].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateSeparatorPartLocation","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartLocation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[4].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[4].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":1,"n":"usedMaterials","t":4,"rt":$n[12].ExposedList$1(UnityEngine.Material),"sn":"usedMaterials","ro":true},{"a":3,"n":"usedRenderersCount","t":4,"rt":$n[0].Int32,"sn":"usedRenderersCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"usedTextures","t":4,"rt":$n[12].ExposedList$1(UnityEngine.Texture),"sn":"usedTextures","ro":true},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AssignMeshOverrideMultipleRenderers","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"AssignMeshOverrideSingleRenderer","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnInstructionsPrepared","t":2,"ad":{"a":2,"n":"add_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideMultiple","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideSingle","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    $m("Spine.Unity.SkeletonGraphic.LayoutMode", function () { return {"td":$n[4].SkeletonGraphic,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EnvelopeParent","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"EnvelopeParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"FitInParent","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"FitInParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"HeightControlsWidth","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"HeightControlsWidth","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"None","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"WidthControlsHeight","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"WidthControlsHeight","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    $m("Spine.Unity.SkeletonMecanim", function () { return {"nested":[$n[4].SkeletonMecanim.MecanimTranslator],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Animator),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanim-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"v":true,"a":2,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":3,"n":"UpdateAnimation","t":8,"sn":"UpdateAnimation","rt":$n[0].Void},{"a":2,"n":"Translator","t":16,"rt":$n[4].SkeletonMecanim.MecanimTranslator,"g":{"a":2,"n":"get_Translator","t":8,"rt":$n[4].SkeletonMecanim.MecanimTranslator,"fg":"Translator"},"fn":"Translator"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[4].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[4].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[4].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"translator","t":4,"rt":$n[4].SkeletonMecanim.MecanimTranslator,"sn":"translator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[4].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator", function () { return {"td":$n[4].SkeletonMecanim,"nested":[Function,$n[4].SkeletonMecanim.MecanimTranslator.MixMode,$n[4].SkeletonMecanim.MecanimTranslator.ClipInfos,$n[4].SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer,$n[4].SkeletonMecanim.MecanimTranslator.IntEqualityComparer],"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"AnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[12].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[12].Skeleton]},{"a":1,"n":"ApplyAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[12].Skeleton,"ps":0},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":1},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"layerIndex","pt":$n[0].Int32,"ps":3},{"n":"layerWeight","pt":$n[0].Single,"ps":4},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":5},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"ApplyAnimation","rt":$n[0].Boolean,"p":[$n[12].Skeleton,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyInterruptionAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[12].Skeleton,"ps":0},{"n":"interpolateWeightTo1","pt":$n[0].Boolean,"ps":1},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":2},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"layerIndex","pt":$n[0].Int32,"ps":4},{"n":"layerWeight","pt":$n[0].Single,"ps":5},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":6},{"n":"interruptingClipTimeAddition","pt":$n[0].Single,"ps":7},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8}],"sn":"ApplyInterruptionAnimation","rt":$n[0].Boolean,"p":[$n[12].Skeleton,$n[0].Boolean,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ClearClipInfosForLayers","t":8,"sn":"ClearClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"GetActiveAnimationAndTime","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetActiveAnimationAndTime","rt":$n[6].KeyValuePair$2(Spine.Animation,System.Single),"p":[$n[0].Int32]},{"a":1,"n":"GetAnimation","t":8,"pi":[{"n":"clip","pt":$n[1].AnimationClip,"ps":0}],"sn":"GetAnimation","rt":$n[12].Animation,"p":[$n[1].AnimationClip]},{"a":1,"n":"GetAnimatorClipInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"clipInfoCount","out":true,"pt":$n[0].Int32,"ps":2},{"n":"nextClipInfoCount","out":true,"pt":$n[0].Int32,"ps":3},{"n":"interruptingClipInfoCount","out":true,"pt":$n[0].Int32,"ps":4},{"n":"clipInfo","out":true,"pt":$n[6].IList$1(UnityEngine.AnimatorClipInfo),"ps":5},{"n":"nextClipInfo","out":true,"pt":$n[6].IList$1(UnityEngine.AnimatorClipInfo),"ps":6},{"n":"interruptingClipInfo","out":true,"pt":$n[6].IList$1(UnityEngine.AnimatorClipInfo),"ps":7},{"n":"shallInterpolateWeightTo1","out":true,"pt":$n[0].Boolean,"ps":8}],"sn":"GetAnimatorClipInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[6].IList$1(UnityEngine.AnimatorClipInfo),$n[6].IList$1(UnityEngine.AnimatorClipInfo),$n[6].IList$1(UnityEngine.AnimatorClipInfo),$n[0].Boolean]},{"a":1,"n":"GetAnimatorStateInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"stateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"nextStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"interruptingStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":4},{"n":"interruptingClipTimeAddition","out":true,"pt":$n[0].Single,"ps":5}],"sn":"GetAnimatorStateInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[0].Single]},{"a":1,"n":"GetMixMode","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":1}],"sn":"GetMixMode","rt":$n[4].SkeletonMecanim.MecanimTranslator.MixMode,"p":[$n[0].Int32,spine.MixBlend],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":1,"n":"GetStateUpdatesFromAnimator","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetStateUpdatesFromAnimator","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"InitClipInfosForLayers","t":8,"sn":"InitClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"animator","pt":$n[1].Animator,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[1].Animator,$n[4].SkeletonDataAsset]},{"a":1,"n":"OnClipAppliedCallback","t":8,"pi":[{"n":"clip","pt":$n[12].Animation,"ps":0},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"isLooping","pt":$n[0].Boolean,"ps":4},{"n":"weight","pt":$n[0].Single,"ps":5}],"sn":"OnClipAppliedCallback","rt":$n[0].Void,"p":[$n[12].Animation,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ToSpineAnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"ToSpineAnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Animator","t":16,"rt":$n[1].Animator,"g":{"a":2,"n":"get_Animator","t":8,"rt":$n[1].Animator,"fg":"Animator"},"fn":"Animator"},{"a":2,"n":"MecanimLayerCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MecanimLayerCount","t":8,"rt":$n[0].Int32,"fg":"MecanimLayerCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MecanimLayerCount"},{"a":2,"n":"MecanimLayerNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_MecanimLayerNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"MecanimLayerNames"},"fn":"MecanimLayerNames"},{"a":1,"n":"WeightEpsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"WeightEpsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"animationTable","t":4,"rt":$n[6].Dictionary$2(System.Int32,Spine.Animation),"sn":"animationTable","ro":true},{"a":1,"n":"animator","t":4,"rt":$n[1].Animator,"sn":"animator"},{"a":2,"n":"autoReset","t":4,"rt":$n[0].Boolean,"sn":"autoReset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"clipNameHashCodeTable","t":4,"rt":$n[6].Dictionary$2(UnityEngine.AnimationClip,System.Int32),"sn":"clipNameHashCodeTable","ro":true},{"a":2,"n":"layerBlendModes","t":4,"rt":System.Array.type(spine.MixBlend),"sn":"layerBlendModes"},{"a":3,"n":"layerClipInfos","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos),"sn":"layerClipInfos"},{"a":2,"n":"layerMixModes","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode),"sn":"layerMixModes"},{"a":1,"n":"previousAnimations","t":4,"rt":$n[6].List$1(Spine.Animation),"sn":"previousAnimations","ro":true},{"a":2,"n":"useCustomMixMode","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnClipApplied","t":2,"ad":{"a":2,"n":"add_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnClipApplied","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnClipApplied","t":2,"ad":{"a":3,"n":"add__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnClipApplied","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", function () { return {"td":$n[4].SkeletonMecanim.MecanimTranslator,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AlwaysMix","is":true,"t":4,"rt":$n[4].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"AlwaysMix","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"Hard","is":true,"t":4,"rt":$n[4].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"MixNext","is":true,"t":4,"rt":$n[4].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"MixNext","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", function () { return {"td":$n[4].SkeletonMecanim.MecanimTranslator,"att":1048580,"a":3,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clipInfoCount","t":4,"rt":$n[0].Int32,"sn":"clipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"clipInfos","t":4,"rt":$n[6].List$1(UnityEngine.AnimatorClipInfo),"sn":"clipInfos","ro":true},{"a":2,"n":"interruptingClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"interruptingClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"interruptingClipInfos","t":4,"rt":$n[6].List$1(UnityEngine.AnimatorClipInfo),"sn":"interruptingClipInfos","ro":true},{"a":2,"n":"interruptingClipTimeAddition","t":4,"rt":$n[0].Single,"sn":"interruptingClipTimeAddition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"interruptingStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"interruptingStateInfo"},{"a":2,"n":"isInterruptionActive","t":4,"rt":$n[0].Boolean,"sn":"isInterruptionActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLastFrameOfInterruption","t":4,"rt":$n[0].Boolean,"sn":"isLastFrameOfInterruption","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nextClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"nextClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"nextClipInfos","t":4,"rt":$n[6].List$1(UnityEngine.AnimatorClipInfo),"sn":"nextClipInfos","ro":true},{"a":2,"n":"nextStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"nextStateInfo"},{"a":2,"n":"stateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"stateInfo"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", function () { return {"td":$n[4].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[1].AnimationClip,"ps":0},{"n":"y","pt":$n[1].AnimationClip,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[1].AnimationClip,$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[1].AnimationClip,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[6].IEqualityComparer$1(UnityEngine.AnimationClip),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", function () { return {"td":$n[4].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[0].Int32,"ps":0},{"n":"y","pt":$n[0].Int32,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[0].Int32,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[6].IEqualityComparer$1(System.Int32),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    $m("Spine.Unity.SkeletonRenderer", function () { return {"nested":[$n[4].SkeletonRenderer.SpriteMaskInteractionMaterials,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderer-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSpineComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"AddSpineComponent","rt":System.Object,"p":[$n[1].GameObject,$n[4].SkeletonDataAsset,$n[0].Boolean]},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":2,"n":"EnsureMeshGeneratorCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshGeneratorCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"slotNamePredicate","pt":Function,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots","rt":$n[0].Void,"p":[Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"startsWith","pt":$n[0].String,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"InitSpriteMaskMaterialsForMaskType","t":8,"pi":[{"n":"maskFunction","pt":$n[5].CompareFunction,"ps":0},{"n":"materialsToFill","ref":true,"pt":System.Array.type(UnityEngine.Material),"ps":1}],"sn":"InitSpriteMaskMaterialsForMaskType","rt":$n[0].Boolean,"p":[$n[5].CompareFunction,System.Array.type(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsInsideMask","t":8,"sn":"InitSpriteMaskMaterialsInsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsOutsideMask","t":8,"sn":"InitSpriteMaskMaterialsOutsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"v":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"v":true,"a":2,"n":"LateUpdateMesh","t":8,"sn":"LateUpdateMesh","rt":$n[0].Void},{"a":2,"n":"NewSpineGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"tpc":1,"tprm":["T"],"sn":"NewSpineGameObject","rt":System.Object,"p":[$n[4].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"v":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"a":1,"n":"SetMaterialSettingsToFixDrawOrder","t":8,"sn":"SetMaterialSettingsToFixDrawOrder","rt":$n[0].Void},{"a":2,"n":"SetMeshSettings","t":8,"pi":[{"n":"settings","pt":$n[4].MeshGenerator.Settings,"ps":0}],"sn":"SetMeshSettings","rt":$n[0].Void,"p":[$n[4].MeshGenerator.Settings]},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[6].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[6].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomSlotMaterials","t":16,"rt":$n[6].Dictionary$2(Spine.Slot,UnityEngine.Material),"g":{"a":2,"n":"get_CustomSlotMaterials","t":8,"rt":$n[6].Dictionary$2(Spine.Slot,UnityEngine.Material),"fg":"CustomSlotMaterials"},"fn":"CustomSlotMaterials"},{"a":2,"n":"Skeleton","t":16,"rt":$n[12].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[12].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[4].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[4].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[4].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_NONE","is":true,"t":4,"rt":$n[5].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_NONE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","is":true,"t":4,"rt":$n[5].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","is":true,"t":4,"rt":$n[5].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"STENCIL_COMP_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SUBMESH_DUMMY_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"SUBMESH_DUMMY_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("calculateNormals")],"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentInstructions","t":4,"rt":$n[4].SkeletonRendererInstruction,"sn":"currentInstructions","ro":true},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[6].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customSlotMaterials","t":4,"rt":$n[6].Dictionary$2(Spine.Slot,UnityEngine.Material),"sn":"customSlotMaterials","ro":true},{"a":2,"n":"disableRenderingOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableRenderingOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fixDrawOrder","t":4,"rt":$n[0].Boolean,"sn":"fixDrawOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"maskMaterials","t":4,"rt":$n[4].SkeletonRenderer.SpriteMaskInteractionMaterials,"sn":"maskMaterials"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[4].MeshGenerator,"sn":"meshGenerator","ro":true},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rendererBuffers","t":4,"rt":$n[4].MeshRendererBuffers,"sn":"rendererBuffers","ro":true},{"a":1,"n":"reusedPropertyBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"reusedPropertyBlock"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("submeshSeparators"),new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[6].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":2,"n":"singleSubmesh","t":4,"rt":$n[0].Boolean,"sn":"singleSubmesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeleton","t":4,"rt":$n[12].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[4].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[4].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GenerateMeshOverride","t":2,"ad":{"a":2,"n":"add_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addGenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeGenerateMeshOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"generateMeshOverride","t":2,"ad":{"a":1,"n":"add_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addgenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removegenerateMeshOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    $m("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", function () { return {"td":$n[4].SkeletonRenderer,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnyMaterialCreated","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AnyMaterialCreated","t":8,"rt":$n[0].Boolean,"fg":"AnyMaterialCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"AnyMaterialCreated"},{"a":2,"n":"materialsInsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsInsideMask"},{"a":2,"n":"materialsMaskDisabled","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsMaskDisabled"},{"a":2,"n":"materialsOutsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsOutsideMask"}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials", function () { return {"nested":[$n[4].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,$n[4].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphicCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomTextureOverrides","t":8,"sn":"RemoveCustomTextureOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomTextureOverrides","t":8,"sn":"SetCustomTextureOverrides","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[6].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customTextureOverrides","t":4,"rt":$n[6].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride),"sn":"customTextureOverrides"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[4].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[4].SkeletonGraphicCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", function () { return {"td":$n[4].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonGraphicCustomMaterials.AtlasTextureOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[4].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementTexture","t":4,"rt":$n[1].Texture,"sn":"replacementTexture"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials", function () { return {"nested":[$n[4].SkeletonRendererCustomMaterials.SlotMaterialOverride,$n[4].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomSlotMaterials","t":8,"sn":"RemoveCustomSlotMaterials","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomSlotMaterials","t":8,"sn":"SetCustomSlotMaterials","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[6].List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customSlotMaterials","t":4,"rt":$n[6].List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride),"sn":"customSlotMaterials"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", function () { return {"td":$n[4].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonRendererCustomMaterials.SlotMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[4].SkeletonRendererCustomMaterials.SlotMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[4].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonRendererCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[4].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalMaterial","t":4,"rt":$n[1].Material,"sn":"originalMaterial"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    $m("Spine.Unity.SkeletonPartsRenderer", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshRenderer, UnityEngine.MeshFilter),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearMesh","t":8,"sn":"ClearMesh","rt":$n[0].Void},{"a":1,"n":"LazyIntialize","t":8,"sn":"LazyIntialize","rt":$n[0].Void},{"a":2,"n":"NewPartsRendererGameObject","is":true,"t":8,"pi":[{"n":"parent","pt":$n[1].Transform,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"sortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"NewPartsRendererGameObject","rt":$n[4].SkeletonPartsRenderer,"p":[$n[1].Transform,$n[0].String,$n[0].Int32]},{"a":2,"n":"RenderParts","t":8,"pi":[{"n":"instructions","pt":$n[12].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"RenderParts","rt":$n[0].Void,"p":[$n[12].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetPropertyBlock","t":8,"pi":[{"n":"block","pt":$n[1].MaterialPropertyBlock,"ps":0}],"sn":"SetPropertyBlock","rt":$n[0].Void,"p":[$n[1].MaterialPropertyBlock]},{"a":2,"n":"MeshFilter","t":16,"rt":$n[1].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[1].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[4].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[4].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshRenderer","t":16,"rt":$n[1].MeshRenderer,"g":{"a":2,"n":"get_MeshRenderer","t":8,"rt":$n[1].MeshRenderer,"fg":"MeshRenderer"},"fn":"MeshRenderer"},{"a":1,"n":"buffers","t":4,"rt":$n[4].MeshRendererBuffers,"sn":"buffers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[4].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[4].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    $m("Spine.Unity.SkeletonRenderSeparator", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPartsRenderer","t":8,"pi":[{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"name","dv":null,"o":true,"pt":$n[0].String,"ps":1}],"sn":"AddPartsRenderer","rt":$n[4].SkeletonPartsRenderer,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"AddToSkeletonRenderer","is":true,"t":8,"pi":[{"n":"skeletonRenderer","pt":$n[4].SkeletonRenderer,"ps":0},{"n":"sortingLayerID","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"extraPartsRenderers","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"baseSortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":4},{"n":"addMinimumPartsRenderers","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddToSkeletonRenderer","rt":$n[4].SkeletonRenderSeparator,"p":[$n[4].SkeletonRenderer,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"ClearPartsRendererMeshes","t":8,"sn":"ClearPartsRendererMeshes","rt":$n[0].Void},{"a":1,"n":"HandleRender","t":8,"pi":[{"n":"instruction","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"HandleRender","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[4].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[4].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[4].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"DefaultSortingOrderIncrement","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultSortingOrderIncrement","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"copiedBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"copiedBlock"},{"at":[new UnityEngine.TooltipAttribute("Copies MeshRenderer flags into each parts renderer")],"a":2,"n":"copyMeshRendererFlags","t":4,"rt":$n[0].Boolean,"sn":"copyMeshRendererFlags","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"copyPropertyBlock","t":4,"rt":$n[0].Boolean,"sn":"copyPropertyBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mainMeshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"mainMeshRenderer"},{"a":2,"n":"partsRenderers","t":4,"rt":$n[6].List$1(Spine.Unity.SkeletonPartsRenderer),"sn":"partsRenderers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    $m("Spine.Unity.ActivateBasedOnFlipDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensateMovementAfterFlipX","t":8,"pi":[{"n":"toActivate","pt":$n[1].Transform,"ps":0},{"n":"toDeactivate","pt":$n[1].Transform,"ps":1}],"sn":"CompensateMovementAfterFlipX","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"HandleFlip","t":8,"pi":[{"n":"isFlippedX","pt":$n[0].Boolean,"ps":0}],"sn":"HandleFlip","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ResetJointPositions","t":8,"pi":[{"n":"joints","pt":System.Array.type(UnityEngine.HingeJoint2D),"ps":0}],"sn":"ResetJointPositions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.HingeJoint2D)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"activeOnFlippedX","t":4,"rt":$n[1].GameObject,"sn":"activeOnFlippedX"},{"a":2,"n":"activeOnNormalX","t":4,"rt":$n[1].GameObject,"sn":"activeOnNormalX"},{"a":1,"n":"jointsFlippedX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsFlippedX"},{"a":1,"n":"jointsNormalX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsNormalX"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[4].ISkeletonComponent,"sn":"skeletonComponent"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"wasFlippedXBefore","t":4,"rt":$n[0].Boolean,"sn":"wasFlippedXBefore","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    $m("Spine.Unity.FollowLocationRigidbody", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[1].Rigidbody,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    $m("Spine.Unity.FollowLocationRigidbody2D", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody2D)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":2,"n":"followFlippedX","t":4,"rt":$n[0].Boolean,"sn":"followFlippedX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[1].Rigidbody2D,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    $m("Spine.Unity.FollowSkeletonUtilityRootRotation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensatePositionToXRotation","t":8,"sn":"CompensatePositionToXRotation","rt":$n[0].Void},{"a":1,"n":"CompensatePositionToYRotation","t":8,"sn":"CompensatePositionToYRotation","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"FLIP_ANGLE_THRESHOLD","is":true,"t":4,"rt":$n[0].Single,"sn":"FLIP_ANGLE_THRESHOLD","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevLocalEulerAngles","t":4,"rt":$n[1].Vector3,"sn":"prevLocalEulerAngles"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    $m("Spine.Unity.SkeletonUtility", function () { return {"nested":[Function],"att":1048833,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.ISkeletonAnimation),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtility")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoneRigidbody2D","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"isKinematic","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"gravityScale","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AddBoneRigidbody2D","rt":$n[1].Rigidbody2D,"p":[$n[1].GameObject,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddBoundingBoxAsComponent","is":true,"t":8,"pi":[{"n":"box","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"slot","pt":$n[12].Slot,"ps":1},{"n":"gameObject","pt":$n[1].GameObject,"ps":2},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"AddBoundingBoxAsComponent","rt":$n[1].PolygonCollider2D,"p":[spine.BoundingBoxAttachment,$n[12].Slot,$n[1].GameObject,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":1},{"n":"slot","pt":$n[12].Slot,"ps":2},{"n":"parent","pt":$n[1].Transform,"ps":3},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"AddBoundingBoxGameObject$1","rt":$n[1].PolygonCollider2D,"p":[$n[0].String,spine.BoundingBoxAttachment,$n[12].Slot,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[12].Skeleton,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1},{"n":"slotName","pt":$n[0].String,"ps":2},{"n":"attachmentName","pt":$n[0].String,"ps":3},{"n":"parent","pt":$n[1].Transform,"ps":4},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddBoundingBoxGameObject","rt":$n[1].PolygonCollider2D,"p":[$n[12].Skeleton,$n[0].String,$n[0].String,$n[0].String,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"CollectBones","t":8,"sn":"CollectBones","rt":$n[0].Void},{"a":2,"n":"GetBoneRoot","t":8,"sn":"GetBoneRoot","rt":$n[1].Transform},{"a":2,"n":"GetBoundingBoxBounds","is":true,"t":8,"pi":[{"n":"boundingBox","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"depth","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"GetBoundingBoxBounds","rt":$n[1].Bounds,"p":[spine.BoundingBoxAttachment,$n[0].Single]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"g","pt":$n[4].SkeletonGraphic,"ps":0}],"sn":"HandleRendererReset","rt":$n[0].Void,"p":[$n[4].SkeletonGraphic]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"r","pt":$n[4].SkeletonRenderer,"ps":0}],"sn":"HandleRendererReset$1","rt":$n[0].Void,"p":[$n[4].SkeletonRenderer]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RegisterBone","t":8,"pi":[{"n":"bone","pt":$n[4].SkeletonUtilityBone,"ps":0}],"sn":"RegisterBone","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityBone]},{"a":2,"n":"RegisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[4].SkeletonUtilityConstraint,"ps":0}],"sn":"RegisterConstraint","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityConstraint]},{"a":2,"n":"ResubscribeEvents","t":8,"sn":"ResubscribeEvents","rt":$n[0].Void},{"a":2,"n":"SetColliderPointsLocal","is":true,"t":8,"pi":[{"n":"collider","pt":$n[1].PolygonCollider2D,"ps":0},{"n":"slot","pt":$n[12].Slot,"ps":1},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":2},{"n":"scale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SetColliderPointsLocal","rt":$n[0].Void,"p":[$n[1].PolygonCollider2D,$n[12].Slot,spine.BoundingBoxAttachment,$n[0].Single]},{"a":2,"n":"SpawnBone","t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[4].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBone","rt":$n[1].GameObject,"p":[$n[12].Bone,$n[1].Transform,$n[4].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnBoneRecursively","t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[4].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBoneRecursively","rt":$n[1].GameObject,"p":[$n[12].Bone,$n[1].Transform,$n[4].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnHierarchy","t":8,"pi":[{"n":"mode","pt":$n[4].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnHierarchy","rt":$n[1].GameObject,"p":[$n[4].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnRoot","t":8,"pi":[{"n":"mode","pt":$n[4].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnRoot","rt":$n[1].GameObject,"p":[$n[4].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnregisterBone","t":8,"pi":[{"n":"bone","pt":$n[4].SkeletonUtilityBone,"ps":0}],"sn":"UnregisterBone","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityBone]},{"a":2,"n":"UnregisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[4].SkeletonUtilityConstraint,"ps":0}],"sn":"UnregisterConstraint","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityConstraint]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllBones","t":8,"pi":[{"n":"phase","pt":$n[4].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"UpdateAllBones","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"UpdateComplete","t":8,"pi":[{"n":"anim","pt":$n[4].ISkeletonAnimation,"ps":0}],"sn":"UpdateComplete","rt":$n[0].Void,"p":[$n[4].ISkeletonAnimation]},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"anim","pt":$n[4].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[4].ISkeletonAnimation]},{"a":1,"n":"UpdateWorld","t":8,"pi":[{"n":"anim","pt":$n[4].ISkeletonAnimation,"ps":0}],"sn":"UpdateWorld","rt":$n[0].Void,"p":[$n[4].ISkeletonAnimation]},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"PositionScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PositionScale","t":8,"rt":$n[0].Single,"fg":"PositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"PositionScale"},{"a":2,"n":"Skeleton","t":16,"rt":$n[12].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[12].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[4].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[4].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"boneComponents","t":4,"rt":$n[6].List$1(Spine.Unity.SkeletonUtilityBone),"sn":"boneComponents"},{"a":2,"n":"boneRoot","t":4,"rt":$n[1].Transform,"sn":"boneRoot"},{"a":1,"n":"canvas","t":4,"rt":$n[1].Canvas,"sn":"canvas"},{"a":2,"n":"constraintComponents","t":4,"rt":$n[6].List$1(Spine.Unity.SkeletonUtilityConstraint),"sn":"constraintComponents"},{"a":2,"n":"flipBy180DegreeRotation","t":4,"rt":$n[0].Boolean,"sn":"flipBy180DegreeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasConstraints","t":4,"rt":$n[0].Boolean,"sn":"hasConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasOverrideBones","t":4,"rt":$n[0].Boolean,"sn":"hasOverrideBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"needToReprocessBones","t":4,"rt":$n[0].Boolean,"sn":"needToReprocessBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"positionScale","t":4,"rt":$n[0].Single,"sn":"positionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[4].ISkeletonAnimation,"sn":"skeletonAnimation"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[4].ISkeletonComponent,"sn":"skeletonComponent"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnReset","t":2,"ad":{"a":2,"n":"add_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnReset","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnReset","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    $m("Spine.Unity.SkeletonUtilityBone", function () { return {"nested":[$n[4].SkeletonUtilityBone.Mode,$n[4].SkeletonUtilityBone.UpdatePhase],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonUtilityBone"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityBone")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoundingBox","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"AddBoundingBox","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].String]},{"a":2,"n":"BoneTransformModeIncompatible","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0}],"sn":"BoneTransformModeIncompatible","rt":$n[0].Boolean,"p":[$n[12].Bone],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DoUpdate","t":8,"pi":[{"n":"phase","pt":$n[4].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"DoUpdate","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"HandleOnReset","t":8,"sn":"HandleOnReset","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IncompatibleTransformMode","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IncompatibleTransformMode","t":8,"rt":$n[0].Boolean,"fg":"IncompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IncompatibleTransformMode"},{"a":2,"n":"bone","t":4,"rt":$n[12].Bone,"sn":"bone"},{"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":1,"n":"cachedTransform","t":4,"rt":$n[1].Transform,"sn":"cachedTransform"},{"a":2,"n":"hierarchy","t":4,"rt":$n[4].SkeletonUtility,"sn":"hierarchy"},{"a":1,"n":"incompatibleTransformMode","t":4,"rt":$n[0].Boolean,"sn":"incompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mode","t":4,"rt":$n[4].SkeletonUtilityBone.Mode,"sn":"mode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"overrideAlpha","t":4,"rt":$n[0].Single,"sn":"overrideAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"parentReference","t":4,"rt":$n[1].Transform,"sn":"parentReference"},{"a":2,"n":"position","t":4,"rt":$n[0].Boolean,"sn":"position","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotation","t":4,"rt":$n[0].Boolean,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Boolean,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":2,"n":"transformLerpComplete","t":4,"rt":$n[0].Boolean,"sn":"transformLerpComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"zPosition","t":4,"rt":$n[0].Boolean,"sn":"zPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    $m("Spine.Unity.SkeletonUtilityBone.Mode", function () { return {"td":$n[4].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Follow","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.Mode,"sn":"Follow","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"a":2,"n":"Override","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.Mode,"sn":"Override","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    $m("Spine.Unity.SkeletonUtilityBone.UpdatePhase", function () { return {"td":$n[4].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.UpdatePhase,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.UpdatePhase,"sn":"Local","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.UpdatePhase,"sn":"World","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    $m("Spine.Unity.SkeletonUtilityConstraint", function () { return {"att":1048705,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityConstraint")],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"bone","t":4,"rt":$n[4].SkeletonUtilityBone,"sn":"bone"},{"a":3,"n":"hierarchy","t":4,"rt":$n[4].SkeletonUtility,"sn":"hierarchy"}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.UpdateMode start.*/
    $m("Spine.Unity.UpdateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EverythingExceptMesh","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"EverythingExceptMesh","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"FullUpdate","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"FullUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"Nothing","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"Nothing","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyAnimationStatus","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"OnlyAnimationStatus","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyEventTimelines","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"OnlyEventTimelines","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}}]}; }, $n);
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    $m("Spine.Unity.UpdateTiming", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"InFixedUpdate","is":true,"t":4,"rt":$n[4].UpdateTiming,"sn":"InFixedUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InUpdate","is":true,"t":4,"rt":$n[4].UpdateTiming,"sn":"InUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"ManualUpdate","is":true,"t":4,"rt":$n[4].UpdateTiming,"sn":"ManualUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.ISpineComponent start.*/
    $m("Spine.Unity.ISpineComponent", function () { return {"att":161,"a":2}; }, $n);
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    $m("Spine.Unity.ISpineComponentExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"IsNullOrDestroyed","is":true,"t":8,"pi":[{"n":"component","pt":$n[4].ISpineComponent,"ps":0}],"sn":"IsNullOrDestroyed","rt":$n[0].Boolean,"p":[$n[4].ISpineComponent],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    $m("Spine.Unity.ISkeletonAnimation", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[12].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[12].Skeleton,"fg":"Spine$Unity$ISkeletonAnimation$Skeleton"},"fn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"ab":true,"a":2,"n":"UpdateTiming","t":16,"rt":$n[4].UpdateTiming,"g":{"ab":true,"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[4].UpdateTiming,"fg":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"ab":true,"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[4].UpdateTiming],"rt":$n[0].Void,"fs":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},"fn":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},{"ab":true,"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"ab":true,"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateComplete","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateLocal","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateWorld","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[12].Skeleton,"sn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"a":1,"backing":true,"n":"<UpdateTiming>k__BackingField","t":4,"rt":$n[4].UpdateTiming,"sn":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    $m("Spine.Unity.IHasSkeletonDataAsset", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},"fn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    $m("Spine.Unity.ISkeletonComponent", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[12].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[12].Skeleton,"fg":"Spine$Unity$ISkeletonComponent$Skeleton"},"fn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},"fn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[12].Skeleton,"sn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    $m("Spine.Unity.IAnimationStateComponent", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"AnimationState","t":16,"rt":$n[12].AnimationState,"g":{"ab":true,"a":2,"n":"get_AnimationState","t":8,"rt":$n[12].AnimationState,"fg":"Spine$Unity$IAnimationStateComponent$AnimationState"},"fn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"ab":true,"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"ab":true,"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},"fn":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},{"a":1,"backing":true,"n":"<AnimationState>k__BackingField","t":4,"rt":$n[12].AnimationState,"sn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"a":1,"backing":true,"n":"<UnscaledTime>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    $m("Spine.Unity.IHasSkeletonRenderer", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[4].SkeletonRenderer,"g":{"ab":true,"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[4].SkeletonRenderer,"fg":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},"fn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},{"a":1,"backing":true,"n":"<SkeletonRenderer>k__BackingField","t":4,"rt":$n[4].SkeletonRenderer,"sn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    $m("Spine.Unity.IHasSkeletonComponent", function () { return {"att":161,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonComponent","t":16,"rt":$n[4].ISkeletonComponent,"g":{"ab":true,"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[4].ISkeletonComponent,"fg":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},"fn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},{"a":1,"backing":true,"n":"<SkeletonComponent>k__BackingField","t":4,"rt":$n[4].ISkeletonComponent,"sn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    $m("Spine.Unity.DoubleBuffered$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":T},{"a":2,"n":"GetNext","t":8,"sn":"GetNext","rt":T},{"a":1,"n":"a","t":4,"rt":T,"sn":"a","ro":true},{"a":1,"n":"b","t":4,"rt":T,"sn":"b","ro":true},{"a":1,"n":"usingA","t":4,"rt":$n[0].Boolean,"sn":"usingA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    $m("Spine.Unity.MeshGeneratorBuffers", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"colorBuffer","t":4,"rt":System.Array.type(UnityEngine.Color32),"sn":"colorBuffer"},{"a":2,"n":"meshGenerator","t":4,"rt":$n[4].MeshGenerator,"sn":"meshGenerator"},{"a":2,"n":"uvBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"uvBuffer"},{"a":2,"n":"vertexBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"vertexBuffer"},{"a":2,"n":"vertexCount","t":4,"rt":$n[0].Int32,"sn":"vertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshGenerator start.*/
    $m("Spine.Unity.MeshGenerator", function () { return {"nested":[$n[4].MeshGenerator.Settings],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddAttachmentTintBlack","t":8,"pi":[{"n":"r2","pt":$n[0].Single,"ps":0},{"n":"g2","pt":$n[0].Single,"ps":1},{"n":"b2","pt":$n[0].Single,"ps":2},{"n":"a","pt":$n[0].Single,"ps":3},{"n":"vertexCount","pt":$n[0].Int32,"ps":4}],"sn":"AddAttachmentTintBlack","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"AddSubmesh","t":8,"pi":[{"n":"instruction","pt":$n[4].SubmeshInstruction,"ps":0},{"n":"updateTriangles","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"AddSubmesh","rt":$n[0].Void,"p":[$n[4].SubmeshInstruction,$n[0].Boolean]},{"a":2,"n":"Begin","t":8,"sn":"Begin","rt":$n[0].Void},{"a":2,"n":"BuildMesh","t":8,"pi":[{"n":"instruction","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMesh","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"BuildMeshWithArrays","t":8,"pi":[{"n":"instruction","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMeshWithArrays","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"EnsureVertexCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0},{"n":"inlcudeTintBlack","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"includeTangents","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNormals","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"EnsureVertexCapacity","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FillLateVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillLateVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"regionAttachment","pt":$n[12].RegionAttachment,"ps":1}],"sn":"FillMeshLocal$1","rt":$n[0].Void,"p":[$n[1].Mesh,$n[12].RegionAttachment]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"meshAttachment","pt":$n[12].MeshAttachment,"ps":1},{"n":"skeletonData","pt":$n[12].SkeletonData,"ps":2}],"sn":"FillMeshLocal","rt":$n[0].Void,"p":[$n[1].Mesh,$n[12].MeshAttachment,$n[12].SkeletonData]},{"a":2,"n":"FillTriangles","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillTriangles","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"GenerateSingleSubmeshInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[12].Skeleton,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"GenerateSingleSubmeshInstruction","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[12].Skeleton,$n[1].Material]},{"a":2,"n":"GenerateSkeletonRendererInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[12].Skeleton,"ps":1},{"n":"customSlotMaterials","pt":$n[6].Dictionary$2(Spine.Slot,UnityEngine.Material),"ps":2},{"n":"separatorSlots","pt":$n[6].List$1(Spine.Slot),"ps":3},{"n":"generateMeshOverride","pt":$n[0].Boolean,"ps":4},{"n":"immutableTriangles","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GenerateSkeletonRendererInstruction","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[12].Skeleton,$n[6].Dictionary$2(Spine.Slot,UnityEngine.Material),$n[6].List$1(Spine.Slot),$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetMeshBounds","t":8,"sn":"GetMeshBounds","rt":$n[1].Bounds},{"a":2,"n":"RequiresMultipleSubmeshesByDrawOrder","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[12].Skeleton,"ps":0}],"sn":"RequiresMultipleSubmeshesByDrawOrder","rt":$n[0].Boolean,"p":[$n[12].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ScaleVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"ScaleVertexData","rt":$n[0].Void,"p":[$n[0].Single]},{"a":4,"n":"SolveTangents2DBuffer","is":true,"t":8,"pi":[{"n":"tangents","pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2}],"sn":"SolveTangents2DBuffer","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":4,"n":"SolveTangents2DEnsureSize","is":true,"t":8,"pi":[{"n":"tangentBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2},{"n":"vertexBufferLength","pt":$n[0].Int32,"ps":3}],"sn":"SolveTangents2DEnsureSize","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"SolveTangents2DTriangles","is":true,"t":8,"pi":[{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"triangleCount","pt":$n[0].Int32,"ps":2},{"n":"vertices","pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"uvs","pt":System.Array.type(UnityEngine.Vector2),"ps":4},{"n":"vertexCount","pt":$n[0].Int32,"ps":5}],"sn":"SolveTangents2DTriangles","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector2),$n[0].Array.type(System.Int32),$n[0].Int32,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"SubmeshIndexCount","t":8,"pi":[{"n":"submeshIndex","pt":$n[0].Int32,"ps":0}],"sn":"SubmeshIndexCount","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TryReplaceMaterials","is":true,"t":8,"pi":[{"n":"workingSubmeshInstructions","pt":$n[12].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"customMaterialOverride","pt":$n[6].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"ps":1}],"sn":"TryReplaceMaterials","rt":$n[0].Void,"p":[$n[12].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[6].Dictionary$2(UnityEngine.Material,UnityEngine.Material)]},{"a":2,"n":"Buffers","t":16,"rt":$n[4].MeshGeneratorBuffers,"g":{"a":2,"n":"get_Buffers","t":8,"rt":$n[4].MeshGeneratorBuffers,"fg":"Buffers"},"fn":"Buffers"},{"a":2,"n":"VertexCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_VertexCount","t":8,"rt":$n[0].Int32,"fg":"VertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"VertexCount"},{"a":1,"n":"AttachmentColors32","is":true,"t":4,"rt":$n[6].List$1(UnityEngine.Color32),"sn":"AttachmentColors32"},{"a":1,"n":"AttachmentIndices","is":true,"t":4,"rt":$n[6].List$1(System.Int32),"sn":"AttachmentIndices"},{"a":1,"n":"AttachmentUVs","is":true,"t":4,"rt":$n[6].List$1(UnityEngine.Vector2),"sn":"AttachmentUVs"},{"a":1,"n":"AttachmentVerts","is":true,"t":4,"rt":$n[6].List$1(UnityEngine.Vector3),"sn":"AttachmentVerts"},{"a":1,"n":"BoundsMaxDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMaxDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"BoundsMinDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMinDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"clipper","t":4,"rt":$n[12].SkeletonClipping,"sn":"clipper"},{"a":3,"n":"colorBuffer","t":4,"rt":$n[12].ExposedList$1(UnityEngine.Color32),"sn":"colorBuffer","ro":true},{"a":1,"n":"meshBoundsMax","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMax"},{"a":1,"n":"meshBoundsMin","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMin"},{"a":1,"n":"meshBoundsThickness","t":4,"rt":$n[0].Single,"sn":"meshBoundsThickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"normals","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"normals"},{"a":1,"n":"regionTriangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"regionTriangles"},{"a":2,"n":"settings","t":4,"rt":$n[4].MeshGenerator.Settings,"sn":"settings"},{"a":1,"n":"submeshIndex","t":4,"rt":$n[0].Int32,"sn":"submeshIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"submeshes","t":4,"rt":$n[12].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"submeshes","ro":true},{"a":1,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector4),"sn":"tangents"},{"a":1,"n":"tempTanBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"tempTanBuffer"},{"a":1,"n":"tempVerts","t":4,"rt":$n[0].Array.type(System.Single),"sn":"tempVerts"},{"a":1,"n":"uv2","t":4,"rt":$n[12].ExposedList$1(UnityEngine.Vector2),"sn":"uv2"},{"a":1,"n":"uv3","t":4,"rt":$n[12].ExposedList$1(UnityEngine.Vector2),"sn":"uv3"},{"a":3,"n":"uvBuffer","t":4,"rt":$n[12].ExposedList$1(UnityEngine.Vector2),"sn":"uvBuffer","ro":true},{"a":3,"n":"vertexBuffer","t":4,"rt":$n[12].ExposedList$1(UnityEngine.Vector3),"sn":"vertexBuffer","ro":true}]}; }, $n);
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    $m("Spine.Unity.MeshGenerator.Settings", function () { return {"td":$n[4].MeshGenerator,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Default","is":true,"t":16,"rt":$n[4].MeshGenerator.Settings,"g":{"a":2,"n":"get_Default","t":8,"rt":$n[4].MeshGenerator.Settings,"fg":"Default","is":true},"fn":"Default"},{"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Enable when using Additive blend mode at SkeletonGraphic under a CanvasGroup. When enabled, Additive alpha value is stored at uv2.g instead of color.a to capture CanvasGroup modifying color.a.")],"a":2,"n":"canvasGroupTintBlack","t":4,"rt":$n[0].Boolean,"sn":"canvasGroupTintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Vertex Data")],"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    $m("Spine.Unity.MeshRendererBuffers", function () { return {"nested":[$n[4].MeshRendererBuffers.SmartMesh],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GetNextMesh","t":8,"sn":"GetNextMesh","rt":$n[4].MeshRendererBuffers.SmartMesh},{"a":2,"n":"GetUpdatedSharedMaterialsArray","t":8,"sn":"GetUpdatedSharedMaterialsArray","rt":System.Array.type(UnityEngine.Material)},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"MaterialsChangedInLastUpdate","t":8,"sn":"MaterialsChangedInLastUpdate","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"UpdateSharedMaterials","t":8,"pi":[{"n":"instructions","pt":$n[12].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0}],"sn":"UpdateSharedMaterials","rt":$n[0].Void,"p":[$n[12].ExposedList$1(Spine.Unity.SubmeshInstruction)]},{"a":1,"n":"doubleBufferedMesh","t":4,"rt":$n[4].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"doubleBufferedMesh"},{"a":4,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":4,"n":"submeshMaterials","t":4,"rt":$n[12].ExposedList$1(UnityEngine.Material),"sn":"submeshMaterials","ro":true}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    $m("Spine.Unity.MeshRendererBuffers.SmartMesh", function () { return {"td":$n[4].MeshRendererBuffers,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"instructionUsed","t":4,"rt":$n[4].SkeletonRendererInstruction,"sn":"instructionUsed"},{"a":2,"n":"mesh","t":4,"rt":$n[1].Mesh,"sn":"mesh"}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    $m("Spine.Unity.SkeletonRendererInstruction", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GeometryNotEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"b","pt":$n[4].SkeletonRendererInstruction,"ps":1}],"sn":"GeometryNotEqual","rt":$n[0].Boolean,"p":[$n[4].SkeletonRendererInstruction,$n[4].SkeletonRendererInstruction],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":2,"n":"SetWithSubset","t":8,"pi":[{"n":"instructions","pt":$n[12].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"SetWithSubset","rt":$n[0].Void,"p":[$n[12].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"attachments","t":4,"rt":$n[12].ExposedList$1(spine.Attachment),"sn":"attachments","ro":true},{"a":2,"n":"hasActiveClipping","t":4,"rt":$n[0].Boolean,"sn":"hasActiveClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"submeshInstructions","t":4,"rt":$n[12].ExposedList$1(Spine.Unity.SubmeshInstruction),"sn":"submeshInstructions","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SpineMesh start.*/
    $m("Spine.Unity.SpineMesh", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"NewSkeletonMesh","is":true,"t":8,"sn":"NewSkeletonMesh","rt":$n[1].Mesh},{"a":4,"n":"MeshHideflags","is":true,"t":4,"rt":$n[1].HideFlags,"sn":"MeshHideflags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}}]}; }, $n);
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    $m("Spine.Unity.SubmeshInstruction", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"SlotCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotCount","t":8,"rt":$n[0].Int32,"fg":"SlotCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotCount"},{"a":2,"n":"endSlot","t":4,"rt":$n[0].Int32,"sn":"endSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"forceSeparate","t":4,"rt":$n[0].Boolean,"sn":"forceSeparate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasClipping","t":4,"rt":$n[0].Boolean,"sn":"hasClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasPMAAdditiveSlot","t":4,"rt":$n[0].Boolean,"sn":"hasPMAAdditiveSlot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"preActiveClippingSlotSource","t":4,"rt":$n[0].Int32,"sn":"preActiveClippingSlotSource","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawFirstVertexIndex","t":4,"rt":$n[0].Int32,"sn":"rawFirstVertexIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawTriangleCount","t":4,"rt":$n[0].Int32,"sn":"rawTriangleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeleton","t":4,"rt":$n[12].Skeleton,"sn":"skeleton"},{"a":2,"n":"startSlot","t":4,"rt":$n[0].Int32,"sn":"startSlot","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset", function () { return {"nested":[$n[4].BlendModeMaterialsAsset.AtlasMaterialCache],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/SkeletonData Modifiers/Blend Mode Materials", order: 200
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[12].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[12].SkeletonData]},{"a":2,"n":"ApplyMaterials","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[12].SkeletonData,"ps":0},{"n":"multiplyTemplate","pt":$n[1].Material,"ps":1},{"n":"screenTemplate","pt":$n[1].Material,"ps":2},{"n":"additiveTemplate","pt":$n[1].Material,"ps":3},{"n":"includeAdditiveSlots","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[12].SkeletonData,$n[1].Material,$n[1].Material,$n[1].Material,$n[0].Boolean]},{"a":2,"n":"additiveMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"additiveMaterialTemplate"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"multiplyMaterialTemplate"},{"a":2,"n":"screenMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"screenMaterialTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", function () { return {"td":$n[4].BlendModeMaterialsAsset,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[12].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[12].AtlasRegion,"p":[$n[12].AtlasRegion,$n[1].Material]},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":1,"n":"GetAtlasPageWithMaterial","t":8,"pi":[{"n":"originalPage","pt":$n[12].AtlasPage,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"GetAtlasPageWithMaterial","rt":$n[12].AtlasPage,"p":[$n[12].AtlasPage,$n[1].Material]},{"a":1,"n":"cache","t":4,"rt":$n[6].Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage),"sn":"cache","ro":true}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    $m("Spine.Unity.SpineAttributeBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"dataField","t":4,"rt":$n[0].String,"sn":"dataField"},{"a":2,"n":"fallbackToTextField","t":4,"rt":$n[0].Boolean,"sn":"fallbackToTextField","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"includeNone","t":4,"rt":$n[0].Boolean,"sn":"includeNone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"startsWith","t":4,"rt":$n[0].String,"sn":"startsWith"}]}; }, $n);
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineBone start.*/
    $m("Spine.Unity.SpineBone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"},{"a":2,"n":"GetBone","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"renderer","pt":$n[4].SkeletonRenderer,"ps":1}],"sn":"getBone","rt":$n[12].Bone,"p":[$n[0].String,$n[4].SkeletonRenderer]},{"a":2,"n":"GetBoneData","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1}],"sn":"getBoneData","rt":spine.BoneData,"p":[$n[0].String,$n[4].SkeletonDataAsset]}]}; }, $n);
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineSlot start.*/
    $m("Spine.Unity.SpineSlot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"containsBoundingBoxes","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"containsBoundingBoxes","t":4,"rt":$n[0].Boolean,"sn":"containsBoundingBoxes","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineAnimation start.*/
    $m("Spine.Unity.SpineAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineEvent start.*/
    $m("Spine.Unity.SpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"audioOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"audioOnly","t":4,"rt":$n[0].Boolean,"sn":"audioOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    $m("Spine.Unity.SpineIkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    $m("Spine.Unity.SpineTransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    $m("Spine.Unity.SpinePathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    $m("Spine.Unity.SpineSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"defaultAsEmptyString","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"defaultAsEmptyString","t":4,"rt":$n[0].Boolean,"sn":"defaultAsEmptyString","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineAttachment start.*/
    $m("Spine.Unity.SpineAttachment", function () { return {"nested":[$n[4].SpineAttachment.Hierarchy],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].String,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"currentSkinOnly","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"returnAttachmentPath","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"placeholdersOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"slotField","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":4},{"n":"skinField","dv":"","o":true,"pt":$n[0].String,"ps":5},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"ctor"},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonData","pt":$n[12].SkeletonData,"ps":1}],"sn":"getAttachment","rt":spine.Attachment,"p":[$n[0].String,$n[12].SkeletonData]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1}],"sn":"getAttachment$1","rt":spine.Attachment,"p":[$n[0].String,$n[4].SkeletonDataAsset]},{"a":2,"n":"GetHierarchy","is":true,"t":8,"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"getHierarchy","rt":$n[4].SpineAttachment.Hierarchy,"p":[$n[0].String]},{"a":2,"n":"currentSkinOnly","t":4,"rt":$n[0].Boolean,"sn":"currentSkinOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"placeholdersOnly","t":4,"rt":$n[0].Boolean,"sn":"placeholdersOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"returnAttachmentPath","t":4,"rt":$n[0].Boolean,"sn":"returnAttachmentPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skinField","t":4,"rt":$n[0].String,"sn":"skinField"},{"a":2,"n":"slotField","t":4,"rt":$n[0].String,"sn":"slotField"}]}; }, $n);
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    $m("Spine.Unity.SpineAttachment.Hierarchy", function () { return {"td":$n[4].SpineAttachment,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    $m("Spine.Unity.SpineAtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"atlasAssetField","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"atlasAssetField","t":4,"rt":$n[0].String,"sn":"atlasAssetField"}]}; }, $n);
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.MathUtilities start.*/
    $m("Spine.Unity.MathUtilities", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].Vector2,"ps":0},{"n":"b","pt":$n[1].Vector2,"ps":1},{"n":"value","pt":$n[1].Vector2,"ps":2}],"sn":"InverseLerp$1","rt":$n[1].Vector2,"p":[$n[1].Vector2,$n[1].Vector2,$n[1].Vector2]},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].Vector3,"ps":0},{"n":"b","pt":$n[1].Vector3,"ps":1},{"n":"value","pt":$n[1].Vector3,"ps":2}],"sn":"InverseLerp$2","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[1].Vector3,$n[1].Vector3]},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].Vector4,"ps":0},{"n":"b","pt":$n[1].Vector4,"ps":1},{"n":"value","pt":$n[1].Vector4,"ps":2}],"sn":"InverseLerp$3","rt":$n[1].Vector4,"p":[$n[1].Vector4,$n[1].Vector4,$n[1].Vector4]}]}; }, $n);
    /*Spine.Unity.MathUtilities end.*/

    /*Spine.Unity.SettingsTriState start.*/
    $m("Spine.Unity.SettingsTriState", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Disable","is":true,"t":4,"rt":$n[4].SettingsTriState,"sn":"Disable","box":function ($v) { return Bridge.box($v, Spine.Unity.SettingsTriState, System.Enum.toStringFn(Spine.Unity.SettingsTriState));}},{"a":2,"n":"Enable","is":true,"t":4,"rt":$n[4].SettingsTriState,"sn":"Enable","box":function ($v) { return Bridge.box($v, Spine.Unity.SettingsTriState, System.Enum.toStringFn(Spine.Unity.SettingsTriState));}},{"a":2,"n":"UseGlobalSetting","is":true,"t":4,"rt":$n[4].SettingsTriState,"sn":"UseGlobalSetting","box":function ($v) { return Bridge.box($v, Spine.Unity.SettingsTriState, System.Enum.toStringFn(Spine.Unity.SettingsTriState));}}]}; }, $n);
    /*Spine.Unity.SettingsTriState end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    $m("Spine.Unity.SkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[12].MeshAttachment,"ps":0}],"sn":"GetColor","rt":$n[1].Color,"p":[$n[12].MeshAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[12].RegionAttachment,"ps":0}],"sn":"GetColor$1","rt":$n[1].Color,"p":[$n[12].RegionAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[12].Skeleton,"ps":0}],"sn":"GetColor$2","rt":$n[1].Color,"p":[$n[12].Skeleton]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[12].Slot,"ps":0}],"sn":"GetColor$3","rt":$n[1].Color,"p":[$n[12].Slot]},{"a":2,"n":"GetColorTintBlack","is":true,"t":8,"pi":[{"n":"s","pt":$n[12].Slot,"ps":0}],"sn":"GetColorTintBlack","rt":$n[1].Color,"p":[$n[12].Slot]},{"a":2,"n":"GetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0}],"sn":"GetLocalPosition","rt":$n[1].Vector2,"p":[$n[12].Bone]},{"a":2,"n":"GetLocalQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0}],"sn":"GetLocalQuaternion","rt":$n[1].Quaternion,"p":[$n[12].Bone]},{"a":2,"n":"GetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[12].Skeleton,"ps":0}],"sn":"GetLocalScale","rt":$n[1].Vector2,"p":[$n[12].Skeleton]},{"a":2,"n":"GetLocalVertices","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[12].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetLocalVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[12].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"GetMaterial","is":true,"t":8,"pi":[{"n":"a","pt":spine.Attachment,"ps":0}],"sn":"GetMaterial","rt":$n[1].Material,"p":[spine.Attachment]},{"a":2,"n":"GetMatrix4x4","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0}],"sn":"GetMatrix4x4","rt":$n[1].Matrix4x4,"p":[$n[12].Bone]},{"a":2,"n":"GetQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0}],"sn":"GetQuaternion","rt":$n[1].Quaternion,"p":[$n[12].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0}],"sn":"GetSkeletonSpacePosition","rt":$n[1].Vector2,"p":[$n[12].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"boneLocal","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpacePosition$1","rt":$n[1].Vector2,"p":[$n[12].Bone,$n[1].Vector2]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1}],"sn":"GetWorldPosition","rt":$n[1].Vector3,"p":[$n[12].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2}],"sn":"GetWorldPosition$1","rt":$n[1].Vector3,"p":[$n[12].Bone,$n[1].Transform,$n[0].Single]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[12].PointAttachment,"ps":0},{"n":"bone","pt":$n[12].Bone,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$2","rt":$n[1].Vector3,"p":[$n[12].PointAttachment,$n[12].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[12].PointAttachment,"ps":0},{"n":"slot","pt":$n[12].Slot,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$3","rt":$n[1].Vector3,"p":[$n[12].PointAttachment,$n[12].Slot,$n[1].Transform]},{"a":2,"n":"GetWorldToLocalMatrix","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"ia","out":true,"pt":$n[0].Single,"ps":1},{"n":"ib","out":true,"pt":$n[0].Single,"ps":2},{"n":"ic","out":true,"pt":$n[0].Single,"ps":3},{"n":"id","out":true,"pt":$n[0].Single,"ps":4}],"sn":"GetWorldToLocalMatrix","rt":$n[0].Void,"p":[$n[12].Bone,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"GetWorldVertices","is":true,"t":8,"pi":[{"n":"a","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[12].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetWorldVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[12].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[12].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[12].MeshAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[12].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$1","rt":$n[0].Void,"p":[$n[12].MeshAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[12].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$2","rt":$n[0].Void,"p":[$n[12].RegionAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[12].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$3","rt":$n[0].Void,"p":[$n[12].RegionAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[12].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$4","rt":$n[0].Void,"p":[$n[12].Skeleton,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[12].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$5","rt":$n[0].Void,"p":[$n[12].Skeleton,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[12].Slot,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$6","rt":$n[0].Void,"p":[$n[12].Slot,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[12].Slot,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$7","rt":$n[0].Void,"p":[$n[12].Slot,$n[1].Color32]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"position","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalPosition","rt":$n[0].Void,"p":[$n[12].Bone,$n[1].Vector2]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"sn":"SetLocalPosition$1","rt":$n[0].Void,"p":[$n[12].Bone,$n[1].Vector3]},{"a":2,"n":"SetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[12].Skeleton,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalScale","rt":$n[0].Void,"p":[$n[12].Skeleton,$n[1].Vector2]},{"a":2,"n":"SetPositionSkeletonSpace","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"skeletonSpacePosition","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionSkeletonSpace","rt":$n[1].Vector2,"p":[$n[12].Bone,$n[1].Vector2]},{"a":2,"n":"WorldToLocal","is":true,"t":8,"pi":[{"n":"bone","pt":$n[12].Bone,"ps":0},{"n":"worldPosition","pt":$n[1].Vector2,"ps":1}],"sn":"WorldToLocal","rt":$n[1].Vector2,"p":[$n[12].Bone,$n[1].Vector2]},{"a":1,"n":"ByteToFloat","is":true,"t":4,"rt":$n[0].Single,"sn":"ByteToFloat","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    $m("Spine.Unity.WaitForSpineAnimation", function () { return {"nested":[$n[4].WaitForSpineAnimation.AnimationEventTypes],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].TrackEntry,$n[4].WaitForSpineAnimation.AnimationEventTypes],"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"ctor"},{"a":1,"n":"HandleComplete","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0}],"sn":"HandleComplete","rt":$n[0].Void,"p":[$n[12].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"NowWaitFor","rt":$n[4].WaitForSpineAnimation,"p":[$n[12].TrackEntry,$n[4].WaitForSpineAnimation.AnimationEventTypes]},{"a":3,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[12].TrackEntry,$n[4].WaitForSpineAnimation.AnimationEventTypes]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    $m("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", function () { return {"td":$n[4].WaitForSpineAnimation,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    $m("Spine.Unity.WaitForSpineAnimationComplete", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].TrackEntry,$n[0].Boolean],"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NowWaitFor$1","rt":$n[4].WaitForSpineAnimationComplete,"p":[$n[12].TrackEntry,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    $m("Spine.Unity.WaitForSpineAnimationEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0}],"sn":"NowWaitFor$1","rt":$n[4].WaitForSpineAnimationEnd,"p":[$n[12].TrackEntry]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    $m("Spine.Unity.WaitForSpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].AnimationState,spine.EventData,$n[0].Boolean],"pi":[{"n":"state","pt":$n[12].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[12].AnimationState,$n[0].String,$n[0].Boolean],"pi":[{"n":"state","pt":$n[12].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[4].SkeletonAnimation,spine.EventData,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[4].SkeletonAnimation,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[4].SkeletonAnimation,$n[0].String,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[4].SkeletonAnimation,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor3"},{"a":1,"n":"Clear","t":8,"pi":[{"n":"state","pt":$n[12].AnimationState,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[12].AnimationState]},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[12].TrackEntry,spine.Event]},{"a":1,"n":"HandleAnimationStateEventByName","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEventByName","rt":$n[0].Void,"p":[$n[12].TrackEntry,spine.Event]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[12].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor","rt":$n[4].WaitForSpineEvent,"p":[$n[12].AnimationState,spine.EventData,$n[0].Boolean]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[12].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor$1","rt":$n[4].WaitForSpineEvent,"p":[$n[12].AnimationState,$n[0].String,$n[0].Boolean]},{"a":1,"n":"Subscribe","t":8,"pi":[{"n":"state","pt":$n[12].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"Subscribe","rt":$n[0].Void,"p":[$n[12].AnimationState,spine.EventData,$n[0].Boolean]},{"a":1,"n":"SubscribeByName","t":8,"pi":[{"n":"state","pt":$n[12].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"SubscribeByName","rt":$n[0].Void,"p":[$n[12].AnimationState,$n[0].String,$n[0].Boolean]},{"a":2,"n":"WillUnsubscribeAfterFiring","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WillUnsubscribeAfterFiring","t":8,"rt":$n[0].Boolean,"fg":"WillUnsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WillUnsubscribeAfterFiring","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WillUnsubscribeAfterFiring"},"fn":"WillUnsubscribeAfterFiring"},{"a":1,"n":"m_AnimationState","t":4,"rt":$n[12].AnimationState,"sn":"m_AnimationState"},{"a":1,"n":"m_EventName","t":4,"rt":$n[0].String,"sn":"m_EventName"},{"a":1,"n":"m_TargetEvent","t":4,"rt":spine.EventData,"sn":"m_TargetEvent"},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_unsubscribeAfterFiring","t":4,"rt":$n[0].Boolean,"sn":"m_unsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    $m("Spine.Unity.WaitForSpineTrackEntryEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0}],"sn":"ctor"},{"a":1,"n":"HandleEnd","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0}],"sn":"HandleEnd","rt":$n[0].Void,"p":[$n[12].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0}],"sn":"NowWaitFor","rt":$n[4].WaitForSpineTrackEntryEnd,"p":[$n[12].TrackEntry]},{"a":1,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[12].TrackEntry,"ps":0}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[12].TrackEntry]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    $m("Spine.Unity.AnimationTools.TimelineExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.RotateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[12].SkeletonData,"ps":2}],"sn":"Evaluate","rt":$n[0].Single,"p":[spine.RotateTimeline,$n[0].Single,$n[12].SkeletonData],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TranslateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[12].SkeletonData,"ps":2}],"sn":"Evaluate$1","rt":$n[1].Vector2,"p":[spine.TranslateTimeline,$n[0].Single,$n[12].SkeletonData]},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":0},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"skeletonData","dv":null,"o":true,"pt":$n[12].SkeletonData,"ps":3}],"sn":"Evaluate$2","rt":$n[1].Vector2,"p":[spine.TranslateXTimeline,spine.TranslateYTimeline,$n[0].Single,$n[12].SkeletonData]},{"a":2,"n":"EvaluateRotateMix","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateRotateMix","rt":$n[0].Single,"p":[spine.TransformConstraintTimeline,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"EvaluateTranslateXYMix","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateTranslateXYMix","rt":$n[1].Vector2,"p":[spine.TransformConstraintTimeline,$n[0].Single]},{"a":2,"n":"FindTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[12].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"FindTimelineForBone","rt":System.Object,"p":[$n[12].Animation,$n[0].Int32]},{"a":2,"n":"FindTransformConstraintTimeline","is":true,"t":8,"pi":[{"n":"a","pt":$n[12].Animation,"ps":0},{"n":"transformConstraintIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTransformConstraintTimeline","rt":spine.TransformConstraintTimeline,"p":[$n[12].Animation,$n[0].Int32]},{"a":2,"n":"FindTranslateTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[12].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTranslateTimelineForBone","rt":spine.TranslateTimeline,"p":[$n[12].Animation,$n[0].Int32]}]}; }, $n);
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    }});
